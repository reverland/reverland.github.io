<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Position Independent Code (PIC) in Shared Libraries | Reverland的行知阁</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="linux," />
  

  <meta name="description" content="动态载入有好几个问题：

需要时间载入，每次引用都要重定位
让.text区域不能共享，浪费了RAM空间
.text必须能写入带来安全问题

PIC能解决这些问题：
PIC背后的思想很简单，为代码中的全局数据和函数引用外加一层重定向。通过利用链接和加载过程，可能让共享库中的text部分完全位置无关。它可以被映射到不同的内存地址无需修改。
洞见1：text和data段之间的偏移PIC依赖于数据段和代码">
<meta property="og:type" content="article">
<meta property="og:title" content="Position Independent Code (PIC) in Shared Libraries">
<meta property="og:url" content="http://reverland.org/linux/2015/03/19/position-independent-code-pic-in-shared-libraries/index.html">
<meta property="og:site_name" content="Reverland的行知阁">
<meta property="og:description" content="动态载入有好几个问题：

需要时间载入，每次引用都要重定位
让.text区域不能共享，浪费了RAM空间
.text必须能写入带来安全问题

PIC能解决这些问题：
PIC背后的思想很简单，为代码中的全局数据和函数引用外加一层重定向。通过利用链接和加载过程，可能让共享库中的text部分完全位置无关。它可以被映射到不同的内存地址无需修改。
洞见1：text和data段之间的偏移PIC依赖于数据段和代码">
<meta property="og:image" content="http://eli.thegreenplace.net/images/2011/code_data_got_1.png">
<meta property="og:image" content="http://eli.thegreenplace.net/images/2011/plt_before.png">
<meta property="og:image" content="http://eli.thegreenplace.net/images/2011/plt_after.png">
<meta property="og:updated_time" content="2015-11-15T06:01:31.551Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Position Independent Code (PIC) in Shared Libraries">
<meta name="twitter:description" content="动态载入有好几个问题：

需要时间载入，每次引用都要重定位
让.text区域不能共享，浪费了RAM空间
.text必须能写入带来安全问题

PIC能解决这些问题：
PIC背后的思想很简单，为代码中的全局数据和函数引用外加一层重定向。通过利用链接和加载过程，可能让共享库中的text部分完全位置无关。它可以被映射到不同的内存地址无需修改。
洞见1：text和data段之间的偏移PIC依赖于数据段和代码">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link rel="stylesheet" href="/css/styles.css" type="text/css">

  

  

  

</head>

<body>
  <div class="post-header CENTER">
   
  <div class="toolbox">
    <div class="toolbox-entry">盒子</div>
    <ul class="list-toolbox">
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/">博客</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/">分类</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/">标签</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/">友链</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/">关于</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml">RSS</a>
          </li>
        
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#洞见1：text和data段之间的偏移"><span class="toc-text">洞见1：text和data段之间的偏移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#洞见2：基于程序指针的取址"><span class="toc-text">洞见2：基于程序指针的取址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据索引"><span class="toc-text">数据索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局偏移表(GOT)"><span class="toc-text">全局偏移表(GOT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个例子"><span class="toc-text">一个例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用"><span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性绑定优化"><span class="toc-text">惰性绑定优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过程链接表(PLT)"><span class="toc-text">过程链接表(PLT)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一次"><span class="toc-text">第一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二次"><span class="toc-text">第二次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过PLT和GOT实现的PIC函数调用——实例"><span class="toc-text">通过PLT和GOT实现的PIC函数调用——实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过环境变量控制载入解析"><span class="toc-text">通过环境变量控制载入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PIC的代价"><span class="toc-text">PIC的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Footnotes"><span class="toc-text">Footnotes</span></a></li></ol>
  </div>


<div class="content-post CENTER">
   <article id="post-position-independent-code-pic-in-shared-libraries" class="article article-type-post" itemscope itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Position Independent Code (PIC) in Shared Libraries</h1>

    <div class="article-meta">
      <span>2015-03-19</span>

      <span> | </span>

      <span class="article-author">Liu Yuyang</span>

      <span> | </span>

      
  <span class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </span>


    </div>
  </header>

  <div class="article-content">
    
      <p>动态载入有好几个问题：</p>
<ul>
<li>需要时间载入，每次引用都要重定位</li>
<li>让<code>.text</code>区域不能共享，浪费了RAM空间</li>
<li><code>.text</code>必须能写入带来安全问题</li>
</ul>
<p>PIC能解决这些问题：</p>
<p>PIC背后的思想很简单，为代码中的全局数据和函数引用外加一层重定向。通过利用链接和加载过程，可能让共享库中的<code>text</code>部分完全位置无关。它可以被映射到不同的内存地址无需修改。</p>
<h2 id="洞见1：text和data段之间的偏移">洞见1：text和data段之间的偏移</h2><p>PIC依赖于数据段和代码段之间的偏移，这些数据在链接时就被链接器知道了。当链接结合几个目标文件时，链接器手机不同目标文件的各个段然后合成一个。因此，链接器知道段的尺寸相对位置。</p>
<p>比如说数据段紧接着代码段，在代码段中引用数据段中某个数据的相对地址就能通过简单的计算得到。当前代码在代码段中的偏移已知，代码段基址与数据段之间的偏移已知，调用的相对地址就是两者之差。</p>
<pre><code>(地址由低到高，位置都是已知的)
text基址
<span class="attribute">...</span>
某需要相对引用指令-------<span class="subst">\</span>
<span class="attribute">...</span>                       |
<span class="built_in">data</span>基址                  |相对地址
<span class="attribute">...</span>                       |
被引用的数据      -------/
<span class="attribute">...</span>
</code></pre><h2 id="洞见2：基于程序指针的取址">洞见2：基于程序指针的取址</h2><p>x86没有对eip操作的指令，不能通过程序指针取地址，但x64可以啊</p>
<p>x86很多指令需要绝对地址，通过相对与程序指针取址可以得到。</p>
<p>很多shellcode用这个获取程序指针：</p>
<pre><code><span class="keyword">call</span> something
something：
    <span class="keyword">pop</span> <span class="literal">ebx</span>
</code></pre><p><code>ebx</code>中现在就是程序指针的值了</p>
<h2 id="数据索引">数据索引</h2><h3 id="全局偏移表(GOT)">全局偏移表(GOT)</h3><p>面试被问及这个怎么组织的？我不是很明白什么意思。早年曾经就跟着这篇文章打开gdb很好奇的看got/plt是怎么回事。</p>
<p>通过以上两个洞见，在x86上实现PIC也是可能的。通过GOT完成。</p>
<p>GOT就是一个地址表，在数据段中。当一个代码段中的指令想引用某个变量，不是直接通过绝对地址(需要重定位),而是引用GOT中的条目。显然GOT的地址确定，GOT的条目则将保存变量的绝对地址。</p>
<p><img src="http://eli.thegreenplace.net/images/2011/code_data_got_1.png" alt="got"></p>
<p>GOT中的条目还是得重定位= =，但相对于载入时重定位，有两个好处</p>
<ul>
<li>重定位每个变量只重定位一次</li>
<li>数据段是可写的，不被进程共享。添加重定位没什么影响。将重定位从代码段移过来，让代码段只读并且在进程间可以共享。</li>
</ul>
<h3 id="一个例子">一个例子</h3><p><code>ml_main_pic.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为PIC的动态库</p>
<pre><code>~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/blackhat/</span>eli  gcc -fPIC -m32 -g -shared ml_main_pic.c -o libmlpic.so
</code></pre><p>反汇编</p>
<pre><code> ~/Work/project/blackhat/eli  objdump -d -Mintel libmlpic_dataonly.so   
<span class="label">
libmlpic_dataonly.so:</span>     file format elf32-i386
...
0000053c &lt;ml_func&gt;:
 53c:   <span class="number">55</span>                      <span class="keyword">push</span>   <span class="literal">ebp</span>
 <span class="number">53d</span>:   <span class="number">89</span> e5                   <span class="keyword">mov</span>    <span class="literal">ebp</span>,<span class="literal">esp</span>
 53f:   e8 1a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   55e &lt;__x86.get_pc_thunk.cx&gt;
 <span class="number">544</span>:   <span class="number">81</span> c1 bc 1a <span class="number">00</span> <span class="number">00</span>       <span class="keyword">add</span>    <span class="literal">ecx</span>,<span class="number">0x1abc</span>
 54a:   8b <span class="number">81</span> ec ff ff ff       <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ecx</span>-<span class="number">0x14</span>]
 <span class="number">550</span>:   8b <span class="number">10</span>                   <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">eax</span>]
 <span class="number">552</span>:   8b <span class="number">45</span> <span class="number">08</span>                <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0x8</span>]
 <span class="number">555</span>:   <span class="number">01</span> c2                   <span class="keyword">add</span>    <span class="literal">edx</span>,<span class="literal">eax</span>
 <span class="number">557</span>:   8b <span class="number">45</span> 0c                <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0xc</span>]
 55a:   <span class="number">01</span> d0                   <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
 55c:   <span class="number">5d</span>                      <span class="keyword">pop</span>    <span class="literal">ebp</span>
 <span class="number">55d</span>:   c3                      <span class="keyword">ret</span>    

0000055e &lt;__x86.get_pc_thunk.cx&gt;:
 55e:   8b 0c <span class="number">24</span>                <span class="keyword">mov</span>    <span class="literal">ecx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">esp</span>]
 <span class="number">561</span>:   c3                      <span class="keyword">ret</span>    
 <span class="number">562</span>:   <span class="number">66</span> <span class="number">90</span>                   <span class="keyword">xchg</span>   <span class="literal">ax</span>,<span class="literal">ax</span>
</code></pre><p>53f是获取程序指针的方法，把程序指针放到<code>ecx</code>中。</p>
<p>在544后，<code>ecx</code>就持有GOT的地址。</p>
<p>54a后，将<code>myglob</code>在GOT中的的绝对地址放入<code>eax</code></p>
<p>550后，<code>myglob</code>的值被置入<code>edx</code></p>
<p>然后就是简单的加上<code>a</code>和<code>b</code>。</p>
<p>通过readelf可以查看共享库文件中GOT节信息</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -S libmlpic_dataonly.so 
There are <span class="number">33</span> section headers, starting at offset <span class="number">0x1320</span>:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  ...
  [<span class="number">19</span>] .got              PROGBITS        <span class="number">00001f</span>e8 <span class="number">000f</span>e8 <span class="number">000018</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span>
  [<span class="number">20</span>] .got.plt          PROGBITS        <span class="number">00002000</span> <span class="number">001000</span> <span class="number">000014</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span>
  ...
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</code></pre><p>我们算算ELF中写的和编译器做的是否符合。</p>
<pre><code><span class="number">0x544</span>+<span class="number">0x1abc</span>=<span class="number">0x2000</span>
</code></pre><p>正好是<code>.got.plt</code>节的虚拟地址。再计算下myglob地址在GOT中的位置</p>
<pre><code><span class="number">0x2000</span>-<span class="number">0x14</span>=<span class="number">0x1fec</span>
</code></pre><p>我们看看ELF文件中的信息:</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlpic_dataonly<span class="class">.so</span>

Relocation <span class="tag">section</span> <span class="string">'.rel.dyn'</span> at offset <span class="number">0</span>x358 contains <span class="number">9</span> entries:
 Offset     Info    Type            Sym<span class="class">.Value</span>  Sym. Name
 ...
<span class="number">00001</span>fec  <span class="number">00000606</span> R_386_GLOB_DAT    <span class="number">00002018</span>   myglob
...
</code></pre><p>正好，这里有个重定位。这个重定位就是让链接器把符号地址直接放到这里。</p>
<p>通过gdb看看：</p>
<pre><code> ~/Work/project/blackhat/eli  gcc -m32 -o driver driver.o -L. -lmlpic_dataonly
 ~/Work/project/blackhat/eli  gdb -q driver 
Reading symbols from /home/lyy/Work/project/blackhat/eli/driver..<span class="string">.done</span>.
(gdb)  break ml_func
Breakpoint <span class="number">1</span> <span class="preprocessor">at</span> <span class="number">0x80484c0</span>
(gdb) r
Starting program: /home/lyy/Work/project/blackhat/eli/driver 
<span class="label">warning:</span> the debug information found <span class="keyword">in</span> <span class="string">"/usr/lib64/debug/lib64/ld-2.17.so.debug"</span> does <span class="keyword">not</span> match <span class="string">"/lib/ld-linux.so.2"</span> (CRC mismatch).

addr myglob = <span class="number">0x804a024</span>

Breakpoint <span class="number">1</span>, ml_func (a=<span class="number">1</span>, b=<span class="number">1</span>) <span class="preprocessor">at</span> ml_main_pic.c:<span class="number">5</span>
<span class="number">5</span>           return myglob + a + b<span class="comment">;</span>
(gdb) disas ml_func
Dump of assembler code for function ml_func:
   <span class="number">0xf7fd853c</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="literal">ebp</span>
   <span class="number">0xf7fd853d</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    <span class="literal">ebp</span>,<span class="literal">esp</span>
   <span class="number">0xf7fd853f</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">call</span>   <span class="number">0xf7fd855e</span> &lt;__x86.get_pc_thunk.cx&gt;
   <span class="number">0xf7fd8544</span> &lt;+<span class="number">8</span>&gt;:     <span class="keyword">add</span>    <span class="literal">ecx</span>,<span class="number">0x1abc</span>
=&gt; <span class="number">0xf7fd854a</span> &lt;+<span class="number">14</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ecx</span>-<span class="number">0x14</span>]
   <span class="number">0xf7fd8550</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">eax</span>]
   <span class="number">0xf7fd8552</span> &lt;+<span class="number">22</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0x8</span>]
   <span class="number">0xf7fd8555</span> &lt;+<span class="number">25</span>&gt;:    <span class="keyword">add</span>    <span class="literal">edx</span>,<span class="literal">eax</span>
   <span class="number">0xf7fd8557</span> &lt;+<span class="number">27</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0xc</span>]
   <span class="number">0xf7fd855a</span> &lt;+<span class="number">30</span>&gt;:    <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd855c</span> &lt;+<span class="number">32</span>&gt;:    <span class="keyword">pop</span>    <span class="literal">ebp</span>
   <span class="number">0xf7fd855d</span> &lt;+<span class="number">33</span>&gt;:    <span class="keyword">ret</span>    
End of assembler dump.
(gdb) i registers 
<span class="literal">eax</span>            <span class="number">0x1</span>      <span class="number">1</span>
<span class="literal">ecx</span>            <span class="number">0xf7fda000</span>       -<span class="number">134373376</span>
...
(gdb) p/x <span class="number">0xf7fda000</span>-<span class="number">0x14</span> # GOT中glob绝对地址地址
<span class="number">$2</span> = <span class="number">0xf7fd9fec</span>
(gdb) x/x <span class="number">0xf7fd9fec</span>
<span class="number">0xf7fd9fec</span>:     <span class="number">0x0804a024</span>
(gdb) p &amp;myglob 
<span class="number">$4</span> = (<span class="keyword">int</span> *) <span class="number">0x804a024</span> &lt;myglob&gt;
</code></pre><p>就是这样</p>
<h2 id="函数调用">函数调用</h2><p>额，函数调用，阿里电面时问我GOT干什么的，我说解析函数的吧。。。。。。(就是因为当年看得这篇留下的残缺印象)，当时为什么看这篇文章呢？因为发现函数调用竟然都不是直接调用的！！！</p>
<p>函数不是像数据这样简单的引用的。</p>
<h3 id="惰性绑定优化">惰性绑定优化</h3><p>共享库引用一个函数时，函数地址在载入时才能确定。解析这个地址的过程叫做绑定(binding)。这就是动态载入器把共享库载入进程内存空间时所做的。这个绑定过程不简单，载入器不得不通过在特殊的表中查找函数符号来实现。(共享库ELF目标文件确实有以此为目的的特殊的哈希表节)</p>
<p>解析函数花时间，一般函数比全局变量多太多了，更何况很多函数可能根本不会被调用(比如错误处理或特殊情况)。</p>
<p>为了加速函数绑定的过程，智能惰性绑定机制被设计出来。所谓惰性就是在需要的时候再做什么，计算机科学中很多应用比如<a href="http://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="external">惰性求值</a>和<a href="http://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="external">copy-on-write</a></p>
<p>惰性绑定机制通过又一层重定向实现——PLT.</p>
<h3 id="过程链接表(PLT)">过程链接表(PLT)</h3><p>PLT是可执行的<code>.text</code>一部分，包含一系列条目(每个条目对应一个共享库调用的外部函数)</p>
<p>每个PLT条目都是段简短的可执行代码。</p>
<p>代码调用PLT中的条目而不是直接调用函数，PLT中条目负责真正调用函数。</p>
<p>这个设计被成为蹦床(‘trampoline’)<a href="这让我想起了函数式编程的一种优化递归设计。">^1</a>，每个PLT条目对应也在GOT中一个包含函数实际偏移的条目，但仅仅动态载入器解析它后才会对应上。</p>
<p>PLT允许惰性解析，当共享库首次被载入后，函数调用还没被解析：</p>
<p><img src="http://eli.thegreenplace.net/images/2011/plt_before.png" alt="调用时的解析过程"></p>
<p>一点解说：PLT的第一个条目调用解析程序，该程序在动态链接器里(每个都有)。这个程序将把函数的实际地址解析。</p>
<h4 id="第一次">第一次</h4><p>于是乎，当func第一次被调用时，调用<code>PLT[n]</code>的例程，接着根据<code>GOT[n]</code>中的内容跳到准备解析的指令，接着调用解析器，解析器会把func函数的实际地址写入<code>GOT[n]</code>然后调用<code>func</code>。</p>
<h4 id="第二次">第二次</h4><p><img src="http://eli.thegreenplace.net/images/2011/plt_after.png" alt="事情不再相同"></p>
<p>这时候<code>GOT[n]</code>中已经有函数实际地址，从PLT条目直接就跳到函数func的实际代码开始执行。</p>
<p>不再需要解析器，只有一层多余的跳转。这样实际不用的函数永远不用被解析。</p>
<p>同时，这个设计实现了库中代码段完全位置无关。只有GOT中使用了绝对地址，而GOT在数据段中并且会被动态载入器重定位。即使PLT自身都是PIC的，能放到只读的代码段中。</p>
<p>解析器只是一段载入器里的程序，PLT条目中准备的参数，何时的重定向条目帮助它知道需要解析的符号和需要更新的GOT条目。</p>
<h3 id="通过PLT和GOT实现的PIC函数调用——实例">通过PLT和GOT实现的PIC函数调用——实例</h3><p>费曼说：What I can not create, I do not understand. 我们自己亲手做做</p>
<pre><code> ~/Work/project/blackhat/eli  cat ml_main_pic.c
<span class="keyword">int</span> myglob = <span class="number">42</span>;

<span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span>
</span>{
    <span class="keyword">return</span> a + <span class="number">1</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>
</span>{
    <span class="keyword">int</span> c = b + ml_util_func(a);
    myglob += c;
    <span class="keyword">return</span> b + myglob;
}

 ~/Work/project/blackhat/eli  gcc -fPIC -m32 -g -shared ml_main_pic.c -o libmlpic.so

 ~/Work/project/blackhat/eli  objdump -d -Mintel libmlpic.so 

libmlpic.so:     file format elf32-i386
...
<span class="number">00000440</span> &lt;ml_util_func@plt&gt;:
 <span class="number">440</span>:   ff a3 <span class="number">14</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       jmp    DWORD PTR [ebx+<span class="number">0x14</span>]
 <span class="number">446</span>:   <span class="number">68</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          push   <span class="number">0x10</span>
 <span class="number">44</span>b:   e9 c0 ff ff ff          jmp    <span class="number">410</span> &lt;_init+<span class="number">0x30</span>&gt;
...
<span class="number">0000057</span>c &lt;ml_util_func&gt;:
 <span class="number">57</span>c:   <span class="number">55</span>                      push   ebp
 <span class="number">57</span>d:   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">57f</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
 <span class="number">582</span>:   <span class="number">83</span> c0 <span class="number">01</span>                add    eax,<span class="number">0x1</span>
 <span class="number">585</span>:   <span class="number">5</span>d                      pop    ebp
 <span class="number">586</span>:   c3                      ret    

<span class="number">00000587</span> &lt;ml_func&gt;:
 <span class="number">587</span>:   <span class="number">55</span>                      push   ebp
 <span class="number">588</span>:   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">58</span>a:   <span class="number">53</span>                      push   ebx
 <span class="number">58</span>b:   <span class="number">83</span> ec <span class="number">24</span>                sub    esp,<span class="number">0x24</span>
 <span class="number">58</span>e:   e8 bd fe ff ff          call   <span class="number">450</span> &lt;__x86.get_pc_thunk.bx&gt;
 <span class="number">593</span>:   <span class="number">81</span> c3 <span class="number">6</span>d <span class="number">1</span>a <span class="number">00</span> <span class="number">00</span>       add    ebx,<span class="number">0x1a6d</span>
 <span class="number">599</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
 <span class="number">59</span>c:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    DWORD PTR [esp],eax
 <span class="number">59f</span>:   e8 <span class="number">9</span>c fe ff ff          call   <span class="number">440</span> &lt;ml_util_func@plt&gt;
 ...
</code></pre><p>注意59f行的调用，这时<code>ebx</code>是<code>GOT</code>的基址(做减法寻址。。。好奇怪)。</p>
<p>注意440行,PLT条目包含的三部分，一个指向GOT条目中指向的跳转，一个准备解析器参数，一个调用解析器。</p>
<p>我们不在乎410的解析器(PLT[0])</p>
<p>在593的时候获得了<code>eip</code>，接着被加上<code>0x1a6d</code>。GOT的基址就是这个了。</p>
<pre><code><span class="number">0x593</span>+<span class="number">0x1a6d</span>=<span class="number">0x2000</span>
</code></pre><p>可以用<code>readelf</code>看看</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -x <span class="class">.got</span><span class="class">.plt</span> libmlpic<span class="class">.so</span> 

Hex dump of <span class="tag">section</span> <span class="string">'.got.plt'</span>:
  <span class="number">0</span>x00002000 <span class="number">001</span>f0000 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">26040000</span> ............&amp;...
  <span class="number">0</span>x00002010 <span class="number">36040000</span> <span class="number">46040000</span>                   <span class="number">6</span>..<span class="class">.F</span>...
</code></pre><p>条目<code>ml_util_func@plt</code>查看的GOT条目在<code>+0x14</code>位置，即<code>0x2014</code>,上图中可见是<code>0x446</code></p>
<p>正好是<code>ml_util_func@plt</code>中<code>push</code>那一行。</p>
<p>为了让动态链接器能起作用，重定位条目也被添加来指定在GOT中的哪个位置重定位<code>ml_util_func</code></p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlpic.so

Relocation section '.rel.dyn' at offset 0x380 contains 9 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ef4  <span class="number">00000008</span> R_386_RELATIVE   
00001ef8  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002018</span>  <span class="number">00000008</span> R_386_RELATIVE   
00001fe8  <span class="number">00000106</span> R_386_GLOB_DAT    <span class="number">00000000</span>   _ITM_deregisterTMClone
00001fec  <span class="number">00000606</span> R_386_GLOB_DAT    <span class="number">0000201</span>c   myglob
00001ff0  <span class="number">00000206</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __cxa_finalize
00001ff4  <span class="number">00000306</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __gmon_start__
00001ff8  <span class="number">00000406</span> R_386_GLOB_DAT    <span class="number">00000000</span>   _Jv_RegisterClasses
00001ffc  <span class="number">00000506</span> R_386_GLOB_DAT    <span class="number">00000000</span>   _ITM_registerTMCloneTa

Relocation section '.rel.plt' at offset 0x3c8 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
<span class="number">0000200</span>c  <span class="number">00000207</span> R_386_JUMP_SLOT   <span class="number">00000000</span>   __cxa_finalize
<span class="number">00002010</span>  <span class="number">00000307</span> R_386_JUMP_SLOT   <span class="number">00000000</span>   __gmon_start__
<span class="number">00002014</span>  <span class="number">00000907</span> R_386_JUMP_SLOT   <span class="number">0000057</span>c   ml_util_func
</code></pre><p>最后一行很表示载入器应该把符号<code>ml_util_func</code>的地址放入<code>0x2014</code>中(这个函数的GOT条目)</p>
<p>以上是在elf文件中。虽然</p>
<p>我们在gdb中检查首次调用函数后GOT条目的更改：</p>
<pre><code> ~/Work/project/blackhat/eli  gdb -q ./driver
Reading symbols from /home/lyy/Work/project/blackhat/eli/driver..<span class="string">.done</span>.
(gdb) b ml_func
Breakpoint <span class="number">1</span> <span class="preprocessor">at</span> <span class="number">0x80484b0</span>
(gdb) run
Starting program: /home/lyy/Work/project/blackhat/eli/./driver 
<span class="label">warning:</span> the debug information found <span class="keyword">in</span> <span class="string">"/usr/lib64/debug/lib64/ld-2.17.so.debug"</span> does <span class="keyword">not</span> match <span class="string">"/lib/ld-linux.so.2"</span> (CRC mismatch).

addr myglob = <span class="number">0x804a024</span>

Breakpoint <span class="number">1</span>, ml_func (a=<span class="number">1</span>, b=<span class="number">1</span>) <span class="preprocessor">at</span> ml_main_pic.c:<span class="number">10</span>
<span class="number">10</span>          <span class="keyword">int</span> c = b + ml_util_func(a)<span class="comment">;</span>
(gdb) disas ml_func
Dump of assembler code for function ml_func:
   <span class="number">0xf7fd8587</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="literal">ebp</span>
   <span class="number">0xf7fd8588</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    <span class="literal">ebp</span>,<span class="literal">esp</span>
   <span class="number">0xf7fd858a</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">push</span>   <span class="literal">ebx</span>
   <span class="number">0xf7fd858b</span> &lt;+<span class="number">4</span>&gt;:     <span class="keyword">sub</span>    <span class="literal">esp</span>,<span class="number">0x24</span>
   <span class="number">0xf7fd858e</span> &lt;+<span class="number">7</span>&gt;:     <span class="keyword">call</span>   <span class="number">0xf7fd8450</span> &lt;__x86.get_pc_thunk.bx&gt;
   <span class="number">0xf7fd8593</span> &lt;+<span class="number">12</span>&gt;:    <span class="keyword">add</span>    <span class="literal">ebx</span>,<span class="number">0x1a6d</span>
=&gt; <span class="number">0xf7fd8599</span> &lt;+<span class="number">18</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0x8</span>]
   <span class="number">0xf7fd859c</span> &lt;+<span class="number">21</span>&gt;:    <span class="keyword">mov</span>    <span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">esp</span>],<span class="literal">eax</span>
   <span class="number">0xf7fd859f</span> &lt;+<span class="number">24</span>&gt;:    <span class="keyword">call</span>   <span class="number">0xf7fd8440</span> &lt;ml_util_func@plt&gt;
   <span class="number">0xf7fd85a4</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0xc</span>]
   <span class="number">0xf7fd85a7</span> &lt;+<span class="number">32</span>&gt;:    <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd85a9</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">mov</span>    <span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>-<span class="number">0xc</span>],<span class="literal">eax</span>
   <span class="number">0xf7fd85ac</span> &lt;+<span class="number">37</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebx</span>-<span class="number">0x14</span>]
   <span class="number">0xf7fd85b2</span> &lt;+<span class="number">43</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">eax</span>]
   <span class="number">0xf7fd85b4</span> &lt;+<span class="number">45</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>-<span class="number">0xc</span>]
   <span class="number">0xf7fd85b7</span> &lt;+<span class="number">48</span>&gt;:    <span class="keyword">add</span>    <span class="literal">edx</span>,<span class="literal">eax</span>
   <span class="number">0xf7fd85b9</span> &lt;+<span class="number">50</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebx</span>-<span class="number">0x14</span>]
   <span class="number">0xf7fd85bf</span> &lt;+<span class="number">56</span>&gt;:    <span class="keyword">mov</span>    <span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">eax</span>],<span class="literal">edx</span>
   <span class="number">0xf7fd85c1</span> &lt;+<span class="number">58</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebx</span>-<span class="number">0x14</span>]
   <span class="number">0xf7fd85c7</span> &lt;+<span class="number">64</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">eax</span>]
   <span class="number">0xf7fd85c9</span> &lt;+<span class="number">66</span>&gt;:    <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0xc</span>]
   <span class="number">0xf7fd85cc</span> &lt;+<span class="number">69</span>&gt;:    <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd85ce</span> &lt;+<span class="number">71</span>&gt;:    <span class="keyword">add</span>    <span class="literal">esp</span>,<span class="number">0x24</span>
---Type &lt;return&gt; to continue, <span class="keyword">or</span> q &lt;return&gt; to quit---q
Quit
(gdb) i registers <span class="literal">ebx</span>   #GOT基址
<span class="literal">ebx</span>            <span class="number">0xf7fda000</span>       -<span class="number">134373376</span>
(gdb) x/x <span class="number">0xf7fda000</span>+<span class="number">0x14</span>   # GOT中ml_util_func的地址
<span class="number">0xf7fda014</span>:     <span class="number">0xf7fd8446</span>  #和之前ELF文件中类似
(gdb) disas <span class="number">0xf7fd8440</span>  # ml_util_func@plt
Dump of assembler code for function ml_util_func@plt:
   <span class="number">0xf7fd8440</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">jmp</span>    <span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebx</span>+<span class="number">0x14</span>]
   <span class="number">0xf7fd8446</span> &lt;+<span class="number">6</span>&gt;:     <span class="keyword">push</span>   <span class="number">0x10</span>
   <span class="number">0xf7fd844b</span> &lt;+<span class="number">11</span>&gt;:    <span class="keyword">jmp</span>    <span class="number">0xf7fd8410</span>
End of assembler dump.
</code></pre><p>调用一次：</p>
<pre><code>(gdb) n
<span class="number">11</span>          myglob += c;
(gdb) x/x <span class="number">0xf7fda000</span>+<span class="number">0x14</span>
<span class="number">0xf7fda014</span>:     <span class="number">0xf7fd857c</span>
(gdb) p &amp;ml_util_func
$<span class="number">1</span> = (<span class="keyword">int</span> (*)(<span class="keyword">int</span>)) <span class="number">0xf7fd857c</span> &lt;ml_util_func&gt;
</code></pre><p>可见GOT条目已经被更改。</p>
<h2 id="通过环境变量控制载入解析">通过环境变量控制载入解析</h2><p>通过<code>LD_BIND_NOW</code>和<code>LD_BIND_NOT</code>来定义加载方式。</p>
<pre><code><span class="keyword">man</span> ld.<span class="keyword">so</span>
</code></pre><h3 id="PIC的代价">PIC的代价</h3><ul>
<li>所有PIC中外部数据代码引用都需要额外的重定向，需要更多的内存。</li>
<li>在x86平台上多占用了一个通用寄存器，结果就需要更多内存引用。</li>
</ul>
<h3 id="结论">结论</h3><p>x64的好像作者没有写了。。。。。。。</p>
<p>x64平台上，因为能相对<code>rip</code>寻址，不需要通过某种方式获取程序指针。</p>
<p>关于<code>.got</code>和<code>.got.plt</code>提下，就是为了区分数据和函数引用，一个从GOT基址负引用<code>ebx-0x14</code>一个正引用<code>ebx+0x14</code>。这个设计= =</p>
<h2 id="Footnotes">Footnotes</h2>
    
  </div>
</article>



<section class="disqus-comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>




</div>

  
<script>
  var disqus_shortname = 'reverlandblog';
  
  var disqus_url = 'http://reverland.org/linux/2015/03/19/position-independent-code-pic-in-shared-libraries/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"undefined"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0]
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->

</body>
</html>
