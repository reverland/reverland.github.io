<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Load Time Relocation of Shared Libraries | Reverland的行知阁</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="linux," />
  

  <meta name="description" content="想起昨天某厂电面被问到GOT怎么组织的= =，哈？我回头翻了翻Eli Bendersky的Load-time relocation of shared libraries和Position Independent Code (PIC) in shared libraries。Eli Bendersky的网站我非常喜欢，他总能把复杂的问题以一种探索性的方式直观的阐释。我记得当我非常好奇gdb的原理时">
<meta property="og:type" content="article">
<meta property="og:title" content="Load Time Relocation of Shared Libraries">
<meta property="og:url" content="http://reverland.org/linux/2015/03/18/load-time-relocation-of-shared-libraries/index.html">
<meta property="og:site_name" content="Reverland的行知阁">
<meta property="og:description" content="想起昨天某厂电面被问到GOT怎么组织的= =，哈？我回头翻了翻Eli Bendersky的Load-time relocation of shared libraries和Position Independent Code (PIC) in shared libraries。Eli Bendersky的网站我非常喜欢，他总能把复杂的问题以一种探索性的方式直观的阐释。我记得当我非常好奇gdb的原理时">
<meta property="og:image" content="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png">
<meta property="og:updated_time" content="2015-11-15T06:01:31.551Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Load Time Relocation of Shared Libraries">
<meta name="twitter:description" content="想起昨天某厂电面被问到GOT怎么组织的= =，哈？我回头翻了翻Eli Bendersky的Load-time relocation of shared libraries和Position Independent Code (PIC) in shared libraries。Eli Bendersky的网站我非常喜欢，他总能把复杂的问题以一种探索性的方式直观的阐释。我记得当我非常好奇gdb的原理时">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link rel="stylesheet" href="/css/styles.css" type="text/css">

  

  

  

</head>

<body>
  <div class="post-header CENTER">
   
  <div class="toolbox">
    <div class="toolbox-entry">盒子</div>
    <ul class="list-toolbox">
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/">博客</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/">分类</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/">标签</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/">友链</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/">关于</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml">RSS</a>
          </li>
        
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用重定位"><span class="toc-text">函数调用重定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为何需要调用重定向"><span class="toc-text">为何需要调用重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#于可执行文件中引用动态库中的数据"><span class="toc-text">于可执行文件中引用动态库中的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a>
  </div>


<div class="content-post CENTER">
   <article id="post-load-time-relocation-of-shared-libraries" class="article article-type-post" itemscope itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Load Time Relocation of Shared Libraries</h1>

    <div class="article-meta">
      <span>2015-03-18</span>

      <span> | </span>

      <span class="article-author">Liu Yuyang</span>

      <span> | </span>

      
  <span class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </span>


    </div>
  </header>

  <div class="article-content">
    
      <p>想起昨天某厂电面被问到GOT怎么组织的= =，哈？我回头翻了翻Eli Bendersky的<a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/" target="_blank" rel="external">Load-time relocation of shared libraries</a>和<a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="external">Position Independent Code (PIC) in shared libraries</a>。<a href="http://eli.thegreenplace.net" target="_blank" rel="external">Eli Bendersky</a>的网站我非常喜欢，他总能把复杂的问题以一种探索性的方式直观的阐释。我记得当我非常好奇gdb的原理时曾经看到过他的<a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/" target="_blank" rel="external">How debuggers work: Part 1 - Basics </a>和<a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/" target="_blank" rel="external">How debuggers work: Part 2 - Breakpoints</a>，都是难得一见的精品，值得一看</p>
<p>不吐槽面试了，作为面试简直是个惨不忍睹的失败展示，大概让面试官觉得我很low没发展前途，哈哈哈。不过被虐了感觉真好，要有空去面面各种开发测试产品设计。。。。。。一个人怎么能有这么多兴趣！</p>
<p>正文，省得过一段又忘的干干净净，意译<a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/" target="_blank" rel="external">Load-time relocation of shared libraries </a>x64对这个都没支持了= =</p>
<p>程序有时候，几乎总是要导入来自外部的目标代码。有两种载入的方式：</p>
<ul>
<li>载入时重定位</li>
<li>PIC(位置无关代码)</li>
</ul>
<p>讲讲第一种。</p>
<p>可执行文件，动态链接库，blablablabla的什么能直接被机器执行的文件，都是机器码(废话…)要让文件可以执行和装载，必须符合ELF文件规范。操作系统根据ELF文件中提供的信息，按照规范把对应的代码段映射到内存空间的对应位置上去。内存空间大概看上去像这样：</p>
<p><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="x86内存空间地址分布"></p>
<p>可以看到，文件映射，动态库啥的都是放到差不多中间的位置。</p>
<p>举个例子，我们关心几个问题，<code>ml_func</code>内如何解析(reference)<code>myglob</code>呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    myglob += a;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为非PIC，x86 动态共享库</p>
<pre><code> ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -shared -o libmlreloc.so ml_mainreloc.o
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">ml_mainreloc</span>.<span class="title">o</span>: <span class="title">warning</span>: <span class="title">relocation</span> <span class="title">against</span> `<span class="title">myglob</span>' <span class="title">in</span> <span class="title">readonly</span> <span class="title">section</span> `.<span class="title">text</span>'.</span>
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">warning</span>: <span class="title">creating</span> <span class="title">a</span> <span class="title">DT_TEXTREL</span> <span class="title">in</span> <span class="title">object</span>.</span>
</code></pre><p>把<code>myglob</code>重定位到了只读的<code>.text</code>。。。不过对研究没啥影响。</p>
<p>首先看看库的入口地址，链接器会从入口地址(‘.text’的开始位置)开始把代码载入调用者的进程空间。</p>
<pre><code> <span class="regexp">~/Work/</span>project<span class="regexp">/blackhat/</span>eli  readelf -h libmlreloc.so
ELF <span class="string">Header:</span>
    ...
  Entry point <span class="string">address:</span>               <span class="number">0x420</span>
    ...
</code></pre><p>反汇编共享库</p>
<pre><code>~/Work/project/blackhat/eli  objdump -d -Mintel libmlreloc.so

libmlreloc.so:     file format elf32-i386
...
<span class="number">0000054</span>c &lt;ml_func&gt;:
 <span class="number">54</span>c:   <span class="number">55</span>                      push   ebp
 <span class="number">54</span>d:   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">54f</span>:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    edx,DWORD PTR ds:<span class="number">0x0</span>
 <span class="number">555</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
 <span class="number">558</span>:   <span class="number">01</span> d0                   add    eax,edx
 <span class="number">55</span>a:   a3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    ds:<span class="number">0x0</span>,eax
 <span class="number">55f</span>:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    edx,DWORD PTR ds:<span class="number">0x0</span>
 <span class="number">565</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c                mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]
 <span class="number">568</span>:   <span class="number">01</span> d0                   add    eax,edx
 <span class="number">56</span>a:   <span class="number">5</span>d                      pop    ebp
 <span class="number">56</span>b:   c3                      ret    
 ...
</code></pre><p><code>myglob</code>即<code>ds:0x0</code>丫的是什么！这个地址，在载入其它程序进程空间后会被替代。</p>
<p>如何呢？</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x358 contains 11 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  <span class="number">00000008</span> R_386_RELATIVE   
00001eec  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00000551</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">0000055</span>b  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">00000561</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
</code></pre><p>看看动态库文件中怎么记录该怎么替换哪里要替换的信息吧</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x358 contains 11 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  <span class="number">00000008</span> R_386_RELATIVE   
00001eec  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00000551</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">0000055</span>b  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">00000561</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
</code></pre><p>有这么好几处要替换的，看下位置和objdump的位置一样。</p>
<p>根据ELF文件规则。这些地址这样替换:</p>
<pre><code>Offset位置的地址=Sym.<span class="function"><span class="title">Value</span><span class="params">(用nm可以看到将来映射后相对于虚拟载入基址的偏移)</span></span> + 库文件载入基址
</code></pre><p>下面看看看。作为初始化了的数据，<code>myglob</code>是放在<code>.data</code>中的。我们看看<code>.data</code>在哪。</p>
<pre><code> ~/Work/project/blackhat/eli  readelf --segments libmlreloc<span class="class">.so</span>

Elf file type is DYN (Shared <span class="tag">object</span> file)
Entry point <span class="number">0</span>x420
There are <span class="number">7</span> program headers, starting at offset <span class="number">52</span>

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           <span class="number">0</span>x000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000000 <span class="number">0</span>x005fc <span class="number">0</span>x005fc R E <span class="number">0</span>x1000
  LOAD           <span class="number">0</span>x000ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00134 <span class="number">0</span>x00138 RW  <span class="number">0</span>x1000
  DYNAMIC        <span class="number">0</span>x000ef4 <span class="number">0</span>x00001ef4 <span class="number">0</span>x00001ef4 <span class="number">0</span>x000f8 <span class="number">0</span>x000f8 RW  <span class="number">0</span>x4
  GNU_EH_FRAME   <span class="number">0</span>x000580 <span class="number">0</span>x00000580 <span class="number">0</span>x00000580 <span class="number">0</span>x0001c <span class="number">0</span>x0001c R   <span class="number">0</span>x4
  GNU_STACK      <span class="number">0</span>x000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000 <span class="number">0</span>x00000 RW  <span class="number">0</span>x4
  GNU_RELRO      <span class="number">0</span>x000ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00118 <span class="number">0</span>x00118 R   <span class="number">0</span>x1
  PAX_FLAGS      <span class="number">0</span>x000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000 <span class="number">0</span>x00000     <span class="number">0</span>x4

 Section to Segment mapping:
  Segment Sections...
   <span class="number">00</span>     <span class="class">.hash</span> <span class="class">.gnu</span><span class="class">.hash</span> <span class="class">.dynsym</span> <span class="class">.dynstr</span> <span class="class">.gnu</span><span class="class">.version</span> <span class="class">.gnu</span><span class="class">.version_r</span> <span class="class">.rel</span><span class="class">.dyn</span> <span class="class">.rel</span><span class="class">.plt</span> <span class="class">.init</span> <span class="class">.plt</span> <span class="class">.text</span> <span class="class">.fini</span> <span class="class">.eh_frame_hdr</span> <span class="class">.eh_frame</span> 
   <span class="number">01</span>     <span class="class">.init_array</span> <span class="class">.fini_array</span> <span class="class">.jcr</span> <span class="class">.dynamic</span> <span class="class">.got</span> <span class="class">.got</span><span class="class">.plt</span> <span class="class">.data</span> <span class="class">.bss</span> 
   <span class="number">02</span>     <span class="class">.dynamic</span> 
   <span class="number">03</span>     <span class="class">.eh_frame_hdr</span> 
   <span class="number">04</span>     
   <span class="number">05</span>     <span class="class">.init_array</span> <span class="class">.fini_array</span> <span class="class">.jcr</span> <span class="class">.dynamic</span> <span class="class">.got</span> 
   <span class="number">06</span>     
</code></pre><p><code>.data</code>是第二个段，载入后的虚拟地址是<code>0x1ee8</code>，大小是<code>0x00134</code></p>
<pre><code>In [<span class="number">18</span>]: <span class="function"><span class="title">hex</span><span class="params">(<span class="number">0</span>x1ee8+<span class="number">0</span>x134)</span></span>
Out[<span class="number">18</span>]: <span class="string">'0x201c'</span>
</code></pre><p>第二个段扩展到<code>0x201c</code>包含<code>myglob</code>(<code>0x2018</code>)</p>
<p>linux下有个方便的<code>dl_iterate_phdr</code>函数来查看运行时载入的动态链接库。gdb的<code>i shared</code>也可以看到载入库的地址，不过只能看到入口地址而不能看到每个段。</p>
<p>用这么个例子来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;link.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_handler</span><span class="params">(<span class="keyword">struct</span> dl_phdr_info* info, size_t size, <span class="keyword">void</span>* data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name=%s (%d segments) address=%p\n"</span>,</span><br><span class="line">            info-&gt;dlpi_name, info-&gt;dlpi_phnum, (<span class="keyword">void</span>*)info-&gt;dlpi_addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; info-&gt;dlpi_phnum; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\t\t header %2d: address=%10p\n"</span>, j,</span><br><span class="line">             (<span class="keyword">void</span>*) (info-&gt;dlpi_addr + info-&gt;dlpi_phdr[j].p_vaddr));</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\t\t\t type=%u, flags=0x%X\n"</span>,</span><br><span class="line">                 info-&gt;dlpi_phdr[j].p_type, info-&gt;dlpi_phdr[j].p_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    dl_iterate_phdr(header_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = ml_func(argc, argc);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那啥回调啥原理不说了，我也不懂，反正用来看载入地址就好。</p>
<pre><code>✘  ~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/blackhat/</span>eli  gcc -std=c99 -m32 -g -c driver.c -o driver.o
~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/blackhat/</span>eli  gcc -m32 -o driver driver.o -L. -lmlreloc 
</code></pre><p>直接gdb会话：</p>
<pre><code> ~/Work/project/blackhat/eli  gdb -q driver
Reading symbols from /home/reverland/Work/project/blackhat/eli/driver...done.
(gdb) b driver.c:<span class="number">31</span>
Breakpoint <span class="number">1</span> at <span class="number">0x804874b</span>: file driver.c, line <span class="number">31.</span>
(gdb) r
Starting program: /home/reverland/Work/project/blackhat/eli/driver 
warning: the debug information found in <span class="string">"/usr/lib64/debug/lib64/ld-2.17.so.debug"</span> does not match <span class="string">"/lib/ld-linux.so.2"</span> (CRC mismatch).
...
name=/home/reverland/Work/project/blackhat/eli/libmlreloc.so (<span class="number">7</span> segments) address=<span class="number">0xf7fd8000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7fd9ef4</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7fd8580</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>
...
(gdb) p &amp;myglob
$<span class="number">1</span> = (<span class="keyword">int</span> *) <span class="number">0xf7fda018</span> &lt;myglob&gt;
(gdb) 
</code></pre><p>忽视调试信息的警告，那个我记得好像是gentoo的某个bug。我们看到，<code>libmlreloc.so</code>被载入到了<code>0xf7fd8000</code>，别太在意这个地址，按理说ALSR啥的这个地址变化挺正常，虽然我记得gdb中默认禁用alsr了。。。</p>
<p>第二个段在<code>0xf7fd9ee8</code>。这正好就是载入基址(<code>0xf7fd8000</code>)+VirtAddr(就是映射到目标进程空间后的偏移<code>0x00001ee8</code>)</p>
<p>另一方面，我们看到<code>myglob</code>在<code>0xf7fda018</code>。这个地址正好是载入基址(<code>0xf7fd8000</code>)+myglob的偏移(<code>0x00002018</code>)</p>
<p>我们最后在gdb中看下现在的(载入动态库后)的反汇编结果：</p>
<pre><code>(gdb) disas /r ml_func
Dump of assembler code for function ml_func:
   <span class="number">0xf7fd854c</span> &lt;+<span class="number">0</span>&gt;:     <span class="number">55</span>      <span class="keyword">push</span>   <span class="literal">ebp</span>
   <span class="number">0xf7fd854d</span> &lt;+<span class="number">1</span>&gt;:     <span class="number">89</span> e5   <span class="keyword">mov</span>    <span class="literal">ebp</span>,<span class="literal">esp</span>
   <span class="number">0xf7fd854f</span> &lt;+<span class="number">3</span>&gt;:     8b <span class="number">15</span> <span class="number">18</span> a0 fd f7       <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> <span class="literal">ds</span>:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd8555</span> &lt;+<span class="number">9</span>&gt;:     8b <span class="number">45</span> <span class="number">08</span>        <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0x8</span>]
   <span class="number">0xf7fd8558</span> &lt;+<span class="number">12</span>&gt;:    <span class="number">01</span> d0   <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd855a</span> &lt;+<span class="number">14</span>&gt;:    a3 <span class="number">18</span> a0 fd f7  <span class="keyword">mov</span>    <span class="literal">ds</span>:<span class="number">0xf7fda018</span>,<span class="literal">eax</span>
   <span class="number">0xf7fd855f</span> &lt;+<span class="number">19</span>&gt;:    8b <span class="number">15</span> <span class="number">18</span> a0 fd f7       <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> <span class="literal">ds</span>:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd8565</span> &lt;+<span class="number">25</span>&gt;:    8b <span class="number">45</span> 0c        <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0xc</span>]
   <span class="number">0xf7fd8568</span> &lt;+<span class="number">28</span>&gt;:    <span class="number">01</span> d0   <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd856a</span> &lt;+<span class="number">30</span>&gt;:    <span class="number">5d</span>      <span class="keyword">pop</span>    <span class="literal">ebp</span>
   <span class="number">0xf7fd856b</span> &lt;+<span class="number">31</span>&gt;:    c3      <span class="keyword">ret</span>    
End of assembler dump.
</code></pre><p>呵，已经替换过了</p>
<p>综上，一切都很明显了，动态链接库ELF文件中有乱七八糟东西如何映射到目的进程的进程空间中去何处的信息，其中就包括有些地址要载入时替换的信息。操作系统负责这件事，在程序载入阶段计算地址，把该换的换掉。</p>
<h3 id="函数调用重定位">函数调用重定位</h3><p>换下<code>ml_main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ml_util_func</code>被调用,编译</p>
<pre><code> ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -g -c ml_main.c -o ml_mainreloc.o
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -shared -o libmlreloc.so ml_mainreloc.o
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">ml_mainreloc</span>.<span class="title">o</span>: <span class="title">warning</span>: <span class="title">relocation</span> <span class="title">against</span> `<span class="title">myglob</span>' <span class="title">in</span> <span class="title">readonly</span> <span class="title">section</span> `.<span class="title">text</span>'.</span>
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">warning</span>: <span class="title">creating</span> <span class="title">a</span> <span class="title">DT_TEXTREL</span> <span class="title">in</span> <span class="title">object</span>.</span>
</code></pre><p>啥玩意：</p>
<pre><code><span class="number">0000057</span>c &lt;ml_util_func&gt;:
 <span class="number">57</span>c:   <span class="number">55</span>                      push   %ebp
 <span class="number">57</span>d:   <span class="number">89</span> e5                   mov    %esp,%ebp
 <span class="number">57f</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax
 <span class="number">582</span>:   <span class="number">83</span> c0 <span class="number">01</span>                add    $<span class="number">0x1</span>,%eax
 <span class="number">585</span>:   <span class="number">5</span>d                      pop    %ebp
 <span class="number">586</span>:   c3                      ret    

<span class="number">00000587</span> &lt;ml_func&gt;:
 <span class="number">587</span>:   <span class="number">55</span>                      push   %ebp
 <span class="number">588</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp
 <span class="number">58</span>a:   <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp
 <span class="number">58</span>d:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax
 <span class="number">590</span>:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)
 <span class="number">593</span>:   e8 fc ff ff ff          call   <span class="number">594</span> &lt;ml_func+<span class="number">0xd</span>&gt;
 <span class="number">598</span>:   <span class="number">8</span>b <span class="number">55</span> <span class="number">0</span>c                mov    <span class="number">0xc</span>(%ebp),%edx
 <span class="number">59</span>b:   <span class="number">01</span> d0                   add    %edx,%eax
 <span class="number">59</span>d:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,-<span class="number">0x4</span>(%ebp)
 <span class="number">5</span>a0:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>,%edx
 <span class="number">5</span>a6:   <span class="number">8</span>b <span class="number">45</span> fc                mov    -<span class="number">0x4</span>(%ebp),%eax
 <span class="number">5</span>a9:   <span class="number">01</span> d0                   add    %edx,%eax
 <span class="number">5</span>ab:   a3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    %eax,<span class="number">0x0</span>
 <span class="number">5</span>b0:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>,%edx
 <span class="number">5</span>b6:   <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c                mov    <span class="number">0xc</span>(%ebp),%eax
 <span class="number">5</span>b9:   <span class="number">01</span> d0                   add    %edx,%eax
 <span class="number">5</span>bb:   c9                      leave  
 <span class="number">5</span>bc:   c3                      ret    
 <span class="number">5</span>bd:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax
 <span class="number">5</span>bf:   <span class="number">90</span>                      nop
</code></pre><p>注意<code>593</code>那行。</p>
<pre><code><span class="number">593</span>:   e8 fc ff ff ff          call   <span class="number">594</span> &lt;ml_func+<span class="number">0xd</span>&gt;
</code></pre><p><code>call(e8)</code>是相对寻址，<code>fffffffc</code>就是<code>-4</code>，即call指令调用自身(<code>598-4</code>)。</p>
<p>显然，这在载入时要被替换。看看ELF中关于重定位符号映射后偏移信息</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x380 contains 12 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  <span class="number">00000008</span> R_386_RELATIVE   
00001eec  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00000594</span>  <span class="number">00000902</span> R_386_PC32        <span class="number">0000057</span>c   ml_util_func
<span class="number">000005a2</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
...
</code></pre><p>当动态链接库载入时，<code>ml_util_func</code>所在的位置对链接器是已知的(基址(0xf7fd8000)+偏移(0x57c))，594这个要替换位置链接器也是已知的。</p>
<p>偏移地址通过<code>R_386_PC32</code>的规则计算就好<code>0x57c-0x597+0xffffffff=0xffffffe4</code></p>
<p>通过gdb会话可以看到是这样：</p>
<pre><code> ~/Work/project/blackhat/eli  gdb -q driver
Reading symbols from /home/lyy/Work/project/blackhat/eli/driver...done.
(gdb)  b driver.c:<span class="number">31</span>
Breakpoint <span class="number">1</span> at <span class="number">0x804874b</span>: file driver.c, line <span class="number">31.</span>
(gdb) r
Starting program: /home/lyy/Work/project/blackhat/eli/driver 
warning: the debug information found in <span class="string">"/usr/lib64/debug/lib64/ld-2.17.so.debug"</span> does not match <span class="string">"/lib/ld-linux.so.2"</span> (CRC mismatch).

name= (<span class="number">10</span> segments) address=(nil)
                 header  <span class="number">0</span>: address= <span class="number">0x8048034</span>
                         type=<span class="number">6</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address= <span class="number">0x8048174</span>
                         type=<span class="number">3</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">2</span>: address= <span class="number">0x8048000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">3</span>: address= <span class="number">0x8049ef8</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">4</span>: address= <span class="number">0x8049f04</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address= <span class="number">0x8048188</span>
                         type=<span class="number">4</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address= <span class="number">0x8048838</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">7</span>: address=     (nil)
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">8</span>: address= <span class="number">0x8049ef8</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">9</span>: address=     (nil)
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>

name=/home/lyy/Work/project/blackhat/eli/libmlreloc.so (<span class="number">7</span> segments) address=<span class="number">0xf7fd8000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7fd9ef4</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7fd85d4</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>

name=/lib32/libc.so<span class="number">.6</span> (<span class="number">11</span> segments) address=<span class="number">0xf7df4000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7df4034</span>
                         type=<span class="number">6</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7f67788</span>
                         type=<span class="number">3</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7df4000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7f9c1e4</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7f9dd9c</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7df4194</span>
                         type=<span class="number">4</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7f9c1e4</span>
                         type=<span class="number">7</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">7</span>: address=<span class="number">0xf7f677a0</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">8</span>: address=<span class="number">0xf7df4000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">9</span>: address=<span class="number">0xf7f9c1e4</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header <span class="number">10</span>: address=<span class="number">0xf7df4000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>

name=/lib/ld-linux.so<span class="number">.2</span> (<span class="number">7</span> segments) address=<span class="number">0xf7fdc000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7fdc000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7ffcc80</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7ffcef8</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7ff8f00</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7fdc000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7ffcc80</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7fdc000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>


Breakpoint <span class="number">1</span>, main (argc=<span class="number">1</span>, argv=<span class="number">0xffffcd84</span>) at driver.c:<span class="number">31</span>
<span class="number">31</span>      }
(gdb) disas ml_util_func 
Dump of assembler code <span class="keyword">for</span> function ml_util_func:
   <span class="number">0xf7fd857c</span> &lt;+<span class="number">0</span>&gt;:     push   ebp
   <span class="number">0xf7fd857d</span> &lt;+<span class="number">1</span>&gt;:     mov    ebp,esp
   <span class="number">0xf7fd857f</span> &lt;+<span class="number">3</span>&gt;:     mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
   <span class="number">0xf7fd8582</span> &lt;+<span class="number">6</span>&gt;:     add    eax,<span class="number">0x1</span>
   <span class="number">0xf7fd8585</span> &lt;+<span class="number">9</span>&gt;:     pop    ebp
   <span class="number">0xf7fd8586</span> &lt;+<span class="number">10</span>&gt;:    ret    
End of assembler dump.
(gdb) disas /r ml_func
Dump of assembler code <span class="keyword">for</span> function ml_func:
   <span class="number">0xf7fd8587</span> &lt;+<span class="number">0</span>&gt;:     <span class="number">55</span>      push   ebp
   <span class="number">0xf7fd8588</span> &lt;+<span class="number">1</span>&gt;:     <span class="number">89</span> e5   mov    ebp,esp
   <span class="number">0xf7fd858a</span> &lt;+<span class="number">3</span>&gt;:     <span class="number">83</span> ec <span class="number">14</span>        sub    esp,<span class="number">0x14</span>
   <span class="number">0xf7fd858d</span> &lt;+<span class="number">6</span>&gt;:     <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>        mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
   <span class="number">0xf7fd8590</span> &lt;+<span class="number">9</span>&gt;:     <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>        mov    DWORD PTR [esp],eax
   <span class="number">0xf7fd8593</span> &lt;+<span class="number">12</span>&gt;:    e8 e4 ff ff ff  call   <span class="number">0xf7fd857c</span> &lt;ml_util_func&gt;
   <span class="number">0xf7fd8598</span> &lt;+<span class="number">17</span>&gt;:    <span class="number">8</span>b <span class="number">55</span> <span class="number">0</span>c        mov    edx,DWORD PTR [ebp+<span class="number">0xc</span>]
   <span class="number">0xf7fd859b</span> &lt;+<span class="number">20</span>&gt;:    <span class="number">01</span> d0   add    eax,edx
   <span class="number">0xf7fd859d</span> &lt;+<span class="number">22</span>&gt;:    <span class="number">89</span> <span class="number">45</span> fc        mov    DWORD PTR [ebp-<span class="number">0x4</span>],eax
   <span class="number">0xf7fd85a0</span> &lt;+<span class="number">25</span>&gt;:    <span class="number">8</span>b <span class="number">15</span> <span class="number">18</span> a0 fd f7       mov    edx,DWORD PTR ds:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd85a6</span> &lt;+<span class="number">31</span>&gt;:    <span class="number">8</span>b <span class="number">45</span> fc        mov    eax,DWORD PTR [ebp-<span class="number">0x4</span>]
   <span class="number">0xf7fd85a9</span> &lt;+<span class="number">34</span>&gt;:    <span class="number">01</span> d0   add    eax,edx
   <span class="number">0xf7fd85ab</span> &lt;+<span class="number">36</span>&gt;:    a3 <span class="number">18</span> a0 fd f7  mov    ds:<span class="number">0xf7fda018</span>,eax
   <span class="number">0xf7fd85b0</span> &lt;+<span class="number">41</span>&gt;:    <span class="number">8</span>b <span class="number">15</span> <span class="number">18</span> a0 fd f7       mov    edx,DWORD PTR ds:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd85b6</span> &lt;+<span class="number">47</span>&gt;:    <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c        mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]
   <span class="number">0xf7fd85b9</span> &lt;+<span class="number">50</span>&gt;:    <span class="number">01</span> d0   add    eax,edx
   <span class="number">0xf7fd85bb</span> &lt;+<span class="number">52</span>&gt;:    c9      leave  
   <span class="number">0xf7fd85bc</span> &lt;+<span class="number">53</span>&gt;:    c3      ret    
End of assembler dump.
</code></pre><h2 id="为何需要调用重定向">为何需要调用重定向</h2><p>为什么动态库作为一个整体载入进程时，位置都是确定的，却要经过重定向计算？</p>
<p>简单来说，在声明时对<code>ml_util_func</code>以static关键字声明，把函数作为只模块内可用的话，就不存在重定位了。</p>
<pre><code> ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -g -c ml_main.c -o ml_mainreloc.o      
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -shared -o libmlreloc.so ml_mainreloc.o
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">ml_mainreloc</span>.<span class="title">o</span>: <span class="title">warning</span>: <span class="title">relocation</span> <span class="title">against</span> `<span class="title">myglob</span>' <span class="title">in</span> <span class="title">readonly</span> <span class="title">section</span> `.<span class="title">text</span>'.</span>
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">warning</span>: <span class="title">creating</span> <span class="title">a</span> <span class="title">DT_TEXTREL</span> <span class="title">in</span> <span class="title">object</span>.</span>
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  objdump -d -<span class="constant">Mintel</span> libmlreloc.so                

libmlreloc.<span class="symbol">so:</span>     file format elf32-i386

<span class="constant">Disassembly</span> <span class="keyword">of</span> section .<span class="symbol">init:</span>

<span class="number">0000054</span>c &lt;ml_util_func&gt;:
 <span class="number">54</span><span class="symbol">c:</span>   <span class="number">55</span>                      push   ebp
 <span class="number">54</span><span class="symbol">d:</span>   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">54</span><span class="symbol">f:</span>   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,<span class="constant">DWORD</span> <span class="constant">PTR</span> [ebp+<span class="number">0x8</span>]
 <span class="number">552</span>:   <span class="number">83</span> c0 <span class="number">01</span>                add    eax,<span class="number">0x1</span>
 <span class="number">555</span>:   <span class="number">5</span>d                      pop    ebp
 <span class="number">556</span>:   c3                      ret    

<span class="number">00000557</span> &lt;ml_func&gt;:
 <span class="number">557</span>:   <span class="number">55</span>                      push   ebp
 <span class="number">558</span>:   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">55</span><span class="symbol">a:</span>   <span class="number">83</span> ec <span class="number">14</span>                sub    esp,<span class="number">0x14</span>
 <span class="number">55</span><span class="symbol">d:</span>   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,<span class="constant">DWORD</span> <span class="constant">PTR</span> [ebp+<span class="number">0x8</span>]
 <span class="number">560</span>:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    <span class="constant">DWORD</span> <span class="constant">PTR</span> [esp],eax
 <span class="number">563</span>:   e8 e4 ff ff ff          call   <span class="number">54</span>c &lt;ml_util_func&gt;
 ...
</code></pre><p>产生这个现象的原因就此一目了然，如果动态库中存在全局变量，也许会被覆盖和改写，其它载入的动态库就不能知道这个变量的相对位置，需要动态重定位。</p>
<h3 id="于可执行文件中引用动态库中的数据">于可执行文件中引用动态库中的数据</h3><p>上例中<code>myglob</code>变量只在动态库内部使用，如果在外部引用呢？这存在一个特殊的重定位过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> myglob;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr myglob = %p\n"</span>, (<span class="keyword">void</span>*)&amp;myglob);</span><br><span class="line">    <span class="keyword">int</span> t = ml_func(argc, argc);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译运行：</p>
<pre><code> ✘  ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -std=c99 -m32 -g -c driver.c -o driver.o    
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -o driver driver.o -<span class="constant">L</span>. -lmlreloc   
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  ./driver
addr myglob = <span class="number">0x804a024</span>
</code></pre><p><code>0x804a024</code>显然是在主进程而不是后来载入的动态库虚拟地址区域。而<code>myglob</code>是被赋值的。</p>
<p>从gdb中查看引用<code>myglob</code>的位置：</p>
<pre><code>(gdb) p &amp;myglob
<span class="variable">$1</span> = (&lt;data variable, no debug info&gt; *) <span class="number">0x804a024</span> &lt;myglob&gt;
</code></pre><p>查看elf文件</p>
<pre><code> ✘  ~/Work/project/blackhat/eli  readelf -r driver

Relocation section '.rel.dyn' at offset 0x440 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  <span class="number">00000406</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __gmon_start__
<span class="number">0804a024</span>  <span class="number">00000805</span> R_386_COPY        <span class="number">0804a024</span>   myglob
</code></pre><p>有个<code>R_386_COPY</code>类型，该类型表示直接把符号复制到<code>Sym.Value</code>的位置。</p>
<p>在<code>.symtab</code>有相应信息告诉我如何把<code>myglob</code>拷贝，包括尺寸<code>4</code></p>
<pre><code>~/Work/project/blackhat/eli  readelf -s libmlreloc.so 

Symbol table <span class="string">'.symtab'</span> <span class="keyword">contains</span> <span class="number">50</span> entries:
   Num:    <span class="keyword">Value</span>  <span class="built_in">Size</span> <span class="keyword">Type</span>    <span class="keyword">Bind</span>   Vis      Ndx <span class="keyword">Name</span>
   ...
    <span class="number">39</span>: <span class="number">00002018</span>     <span class="number">4</span> OBJECT  GLOBAL <span class="keyword">DEFAULT</span>   <span class="number">21</span> myglob
   ...
</code></pre><h2 id="结论">结论</h2><p>载入时重定位是linux下解析载入的内部数据和代码引用的一种方法。PIC是更高级和流行的方式，甚至x86-64已经不支持载入时重定位。</p>
<p>无论如何，希望此文能帮助拨开现代操作系统链接和载入动态库魔法迷雾。</p>
<p>Next, <a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="external">Position Independent Code (PIC) in shared libraries</a></p>

    
  </div>
</article>



<section class="disqus-comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>




</div>

  
<script>
  var disqus_shortname = 'reverlandblog';
  
  var disqus_url = 'http://reverland.org/linux/2015/03/18/load-time-relocation-of-shared-libraries/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"undefined"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0]
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->

</body>
</html>
