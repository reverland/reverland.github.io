<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>The ES6 Features I Use These Days | Reverland的行知阁</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="ES2015,javascript," />
  

  <meta name="description" content="ES6ES6标准，也称ES2015。在2015年6月正式批准，这是javascript语言标准从2009年首次大版本更新。
这个版本带来了很多新东西，说是新东西，估计基本读者也都见过。比如python中常用的Destructuring assignment、模块导入、generator和map与set，java中的WeakHashMap、Proxy，在coffeescript中常用的class关键">
<meta property="og:type" content="article">
<meta property="og:title" content="The ES6 Features I Use These Days">
<meta property="og:url" content="http://reverland.org/javascript/2015/11/21/the-es6-features-i-use-these-days/index.html">
<meta property="og:site_name" content="Reverland的行知阁">
<meta property="og:description" content="ES6ES6标准，也称ES2015。在2015年6月正式批准，这是javascript语言标准从2009年首次大版本更新。
这个版本带来了很多新东西，说是新东西，估计基本读者也都见过。比如python中常用的Destructuring assignment、模块导入、generator和map与set，java中的WeakHashMap、Proxy，在coffeescript中常用的class关键">
<meta property="og:updated_time" content="2015-11-24T03:24:23.024Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The ES6 Features I Use These Days">
<meta name="twitter:description" content="ES6ES6标准，也称ES2015。在2015年6月正式批准，这是javascript语言标准从2009年首次大版本更新。
这个版本带来了很多新东西，说是新东西，估计基本读者也都见过。比如python中常用的Destructuring assignment、模块导入、generator和map与set，java中的WeakHashMap、Proxy，在coffeescript中常用的class关键">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link rel="stylesheet" href="/css/styles.css" type="text/css">

  

  

  

</head>

<body>
  <div class="post-header CENTER">
   
  <div class="toolbox">
    <div class="toolbox-entry">盒子</div>
    <ul class="list-toolbox">
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/">博客</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/">分类</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/">标签</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/">友链</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/">关于</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml">RSS</a>
          </li>
        
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-text">ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Template_String"><span class="toc-text">Template String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#destructuring_assign"><span class="toc-text">destructuring assign</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spread_Operator"><span class="toc-text">Spread Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrow_Function"><span class="toc-text">Arrow Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
  </div>


<div class="content-post CENTER">
   <article id="post-the-es6-features-i-use-these-days" class="article article-type-post" itemscope itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">The ES6 Features I Use These Days</h1>

    <div class="article-meta">
      <span>2015-11-21</span>

      <span> | </span>

      <span class="article-author">Liu Yuyang</span>

      <span> | </span>

      
  <span class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </span>


    </div>
  </header>

  <div class="article-content">
    
      <h2 id="ES6">ES6</h2><p>ES6标准，也称ES2015。在2015年6月正式批准，这是javascript语言标准从2009年首次大版本更新。</p>
<p>这个版本带来了很多新东西，说是新东西，估计基本读者也都见过。比如python中常用的Destructuring assignment、模块导入、generator和map与set，java中的WeakHashMap、Proxy，在coffeescript中常用的class关键字与子类、模板字符串和剩余参数与默认参数等等。处处都已经有了ES6的影子。</p>
<p>最近做了几件事：</p>
<ol>
<li>把nltk中wordnet corpus reader的python代码看了看，依葫芦画瓢画了个纯javascript版。</li>
<li>热情地把<a href="http://eloquentjavascript.net/" target="_blank" rel="external">Eloquent Javascript</a>的项目和练习复习一遍，然后继续接着往下看。</li>
</ol>
<p>对此，有了两个新认识：</p>
<ol>
<li>Python是门强大的语言。特别是前几天在python中看到async关键字之后…</li>
<li>javascript是门强大的语言但并不简单，ES6让它更强大也更好用更简单</li>
</ol>
<p>这时候发现有几个地方用ES6特性非常方便。</p>
<p>本文不会解释这些特性是什么，所以，如果是查资料查到这里，略过吧。</p>
<h2 id="Generator">Generator</h2><p>在<a href="https://github.com/nltk/nltk/blob/develop/nltk/corpus/reader/wordnet.py" target="_blank" rel="external">nltk wordnet corpus</a>中，对wordnet data文件进行逐行解析的时候，这样处理一行内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_iter = iter(line.split())</span><br><span class="line">_next_token = <span class="keyword">lambda</span>: next(_iter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the lemma and part-of-speech</span></span><br><span class="line">    lemma = _next_token()</span><br><span class="line">    pos = _next_token()</span><br><span class="line">    <span class="comment"># get the number of synsets for this lemma</span></span><br><span class="line">    n_synsets = int(_next_token())</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>显然，对每一行，首先生成一个iterator，这个iterator返回这一行用空格分隔的每一个单词。好在ES6中也支持generator/iterator了，对应如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token = util.getIterator(line.split(<span class="regexp">/\s+/</span>).filter(v=&gt;v!==<span class="string">''</span>));</span><br><span class="line"><span class="comment">// or let token = line.split(/\s+/).filter(v=&gt;v!=='')[Symbol.iterator]();</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// lemma and pos</span></span><br><span class="line">  lemma = token.next().value;</span><br><span class="line">  pos = token.next().value;</span><br><span class="line">  <span class="comment">// get how many synsets for this lemma</span></span><br><span class="line">  nSynsets = <span class="built_in">parseInt</span>(token.next().value);</span><br><span class="line">  assert(nSynsets &gt; <span class="number">0</span>);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>其中，<code>getIterator</code>定义为一个generator函数，调用这个函数则生成对应的generator，下面的<code>for...of</code>用到了<a href="http://devdocs.io/javascript/global\_objects/symbol/iterator" target="_blank" rel="external"><code>array</code>对象本身就有一个generator函数</a>的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">util.getIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nltk中生成ngram的方法的js实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">ngrams</span>(<span class="params">sequence, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Sadly, you cant use arrow function as generator here.</span></span><br><span class="line">  <span class="keyword">let</span>  g = (<span class="function"><span class="keyword">function</span> *(<span class="params">sequence</span>)</span>&#123;<span class="keyword">yield</span> *sequence&#125;)(sequence);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> history = [];</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    history.push(g.next().value);</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> g) &#123;</span><br><span class="line">    history.push(item);</span><br><span class="line">    <span class="comment">// look out here.</span></span><br><span class="line">    <span class="comment">// yield history; will yield reference.</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Array</span>.from(history);</span><br><span class="line">    history.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collections">Collections</h2><p>当我尝试用js实现<a href="http://www.matrix67.com/blog/archives/5044" target="_blank" rel="external">matrix67几年前在其博客讲到的新词发现算法</a>时，需要把一个穷举一个序列的所有分割可能。我这样实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitSet</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> *<span class="title">_splitAll</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> left = s.substr(<span class="number">0</span>, i);</span><br><span class="line">      <span class="keyword">let</span> right = s.substr(i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> wl <span class="keyword">of</span> _splitAll(left)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> wr <span class="keyword">of</span> _splitAll(right)) &#123;</span><br><span class="line">          <span class="keyword">yield</span> wl + <span class="string">" "</span> + wr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> set = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> _splitAll(s))&#123;</span><br><span class="line">    set.push(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想得很好，通过将序列分为左右两部分递归简化处理。结果发现同一分割出现了多词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62; splitSet(&#34;abc&#34;)&#10;[ &#39;abc&#39;, &#39;a bc&#39;, &#39;a b c&#39;, &#39;ab c&#39;, &#39;a b c&#39; ]</span><br></pre></td></tr></table></figure>
<p>相同的结果需要排除，这时候ES6中的<code>Set</code>就很方便了…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> _splitAll(s))&#123;</span><br><span class="line">  set.add(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br></pre></td></tr></table></figure>
<h2 id="Promise">Promise</h2><p>事实上，任何能使用Promise+Generator的地方我都会用，当然ES7中有了async和await关键字。比如在<a href="https://greasyfork.org/en/scripts/12758-youdaodict" target="_blank" rel="external">youdaodict Userscript</a>中实现调用audio API来播放有道mp3音频文件<a href="stackoverflow.com/questions/28554022/how-can-i-play-sound-with-a-greasemonkey-script-in-firefox-when-theres-a-conte">实现跨域发音的函数</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//console.log("[DEBUG] PLAYOUND")</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">playSound</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> source = context.createBufferSource();</span><br><span class="line">    source.buffer = buffer;</span><br><span class="line">    source.connect(context.destination);</span><br><span class="line">    source.start(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> AudioContext()</span><br><span class="line">  <span class="keyword">var</span> soundUrl = <span class="string">`https://dict.youdao.com/dictvoice?type=2&amp;audio=<span class="subst">$&#123;word&#125;</span>`</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = GM_xmlhttpRequest(&#123;</span><br><span class="line">      method: <span class="string">"GET"</span>,</span><br><span class="line">      url: soundUrl,</span><br><span class="line">      responseType: <span class="string">'arraybuffer'</span>,</span><br><span class="line">      onload: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          context.decodeAudioData(res.response, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">            resolve(buffer);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  p.then(playSound, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般的观点是，凡是关系到异步返回值的时候，都应该尽量使用Promise，保证<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20&amp;%20performance/ch3.md" target="_blank" rel="external">回调只被执行一次、更好的错误处理、更明晰的流程结构</a>。</p>
<p>Promise和Generator现在常作为将来ES7中<code>async/await</code>的过渡。比如著名的<code>co</code>模块，以下是一个简化<code>co</code>实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = g.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (result.done)</span><br><span class="line">        <span class="keyword">return</span> result.value;</span><br><span class="line">      <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle(it.next(res))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle(it.next())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是对<code>generator</code>中每个<code>yield</code>出一个promise时，检查这个promise是否已经完成，<br>完成就返回值。没有就在该promise上注册回调让其把完成后的值传回<code>generator</code>并等待<code>generator</code>再返回下一个Promise。</p>
<p>好绕是不是?我跑题了抱歉。</p>
<h2 id="Template_String">Template String</h2><p>其实上面的例子已经用到这个特性了。再举个例子，Coffeescript中可以这样写正则：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OPERATOR = <span class="regexp">/// ^ (</span><br><span class="line">  ?: [-=]&gt;             <span class="comment"># function</span></span><br><span class="line">   | [-+*/%&lt;&gt;&amp;|^!?=]=  <span class="comment"># compound assign / compare</span></span><br><span class="line">   | &gt;&gt;&gt;=?             <span class="comment"># zero-fill right shift</span></span><br><span class="line">   | ([-+:])\1         <span class="comment"># doubles</span></span><br><span class="line">   | ([&amp;|&lt;&gt;])\2=?      <span class="comment"># logic / shift</span></span><br><span class="line">   | \?\.              <span class="comment"># soak access</span></span><br><span class="line">   | \.&#123;2,3&#125;           <span class="comment"># range or splat</span></span><br><span class="line">) ///</span></span><br></pre></td></tr></table></figure>
<p>非常方便不是？虽然我开始是在<a href="www.nltk.org/book/ch03.html">nltk</a>中看到了这个功能，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'That U.S.A. poster-print costs $12.40...'</span></span><br><span class="line">pattern = <span class="string">r'''(?x)    # set flag to allow verbose regexps</span><br><span class="line">    ([A-Z]\.)+        # abbreviations, e.g. U.S.A.</span><br><span class="line">  | \w+(-\w+)*        # words with optional internal hyphens</span><br><span class="line">  | \$?\d+(\.\d+)?%?  # currency and percentages, e.g. $12.40, 82%</span><br><span class="line">  | \.\.\.            # ellipsis</span><br><span class="line">  | [][.,;"'?():-_`]  # these are separate tokens;</span><br><span class="line">'''</span></span><br><span class="line">nltk.regexp_tokenize(text, pattern)</span><br><span class="line">[<span class="string">'That'</span>, <span class="string">'U.S.A.'</span>, <span class="string">'poster-print'</span>, <span class="string">'costs'</span>, <span class="string">'$12.40'</span>, <span class="string">'...'</span>]</span><br></pre></td></tr></table></figure>
<p>想了想如何在js中自己实现，忽然想到了template string这个特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> returnS;</span><br><span class="line">  <span class="comment">// remove all space;</span></span><br><span class="line">  returnS = strings[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> comment = <span class="regexp">/\/\/.*\n/g</span>;</span><br><span class="line">  returnS = returnS.replace(comment, <span class="string">""</span>);</span><br><span class="line">  returnS = returnS.replace(<span class="regexp">/\s+/g</span>,<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">return</span> returnS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r<span class="string">`</span><br><span class="line">    ([A-Z]\.)+        // abbreviations, e.g. U.S.A.</span><br><span class="line">  | \w+(-\w+)*        // words with optional internal hyphens</span><br><span class="line">  | \$?\d+(\.\d+)?%?  // currency and percentages, e.g. $12.40, 82%</span><br><span class="line">  | \.\.\.            // ellipsis</span><br><span class="line">  | [][.,;"'?():-_\`] // these are separate tokens; includes ], [</span><br><span class="line">`</span></span><br></pre></td></tr></table></figure>
<p>这里用到了<a href="http://devdocs.io/javascript/template_strings" target="_blank" rel="external">Tagged template strings</a>的特性。</p>
<p>另外，如果是多行连续文本时也应该使用template string。</p>
<h2 id="class">class</h2><p>从本质上讲，javascript中的所有面向对象机制都是建构在原型链上的，但class这种语法糖也能比较方便。在coffeescript中我觉得那种浓烈ruby风的写法更合心意一些，<code>class</code>关键字总有些不怎么顺手的地方，比如 <em>设置类静态变量</em> 和有争议的 <em>mixin</em> 。参照nltk wordnet corpus reader类的时候也简单实践了下class关键字、继承等的使用。简单使用还是挺顺手的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synset</span> <span class="keyword">extends</span> <span class="title">_WordNetObject</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* lemma.pos.number to get a synset */</span></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// initialized by the Reader</span></span><br><span class="line">    <span class="keyword">this</span>._name = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._offset = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._lexname = <span class="literal">null</span>; <span class="comment">// lexicographer file e.g. noun.animal</span></span><br><span class="line">    <span class="keyword">this</span>._pos = <span class="literal">null</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2 id="destructuring_assign">destructuring assign</h2><p>这是，非常好用的语法糖。终于可以</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h2 id="Spread_Operator">Spread Operator</h2><p>各种语法糖，处理rest parameter时省心很多，而且返回的是一个真正的Array对象。比较有意思的一个例子是，有次见有人讨论如何把<code>Math.min</code>应用到数组上。他说到javascript高级程序设计上的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认为应该把<code>this</code>绑定到<code>null</code>而不是<code>Math</code>，于是我才知道<code>apply</code>时还是要小心不要污染全局变量空间。。。不过这个例子，我去翻了下<a href="https://github.com/v8/v8/blob/44c44521ae11859478b42004f57ea93df52526ee/src/js/math.js#L110-135" target="_blank" rel="external">v8的math.js</a>和<a href="https://github.com/ricardoquesada/Spidermonkey/blob/master/js/src/jsmath.cpp#L593-L616" target="_blank" rel="external">spidermonkey的Math实现</a>，都不关this什么事，所以，我觉得，爱绑定啥都行。。。</p>
<p>关键在于，有了spread operator之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.min(...array);</span><br></pre></td></tr></table></figure>
<p>就行了。这些类似的应用场景很多的，比如打印数组中每个成员</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...array);</span><br></pre></td></tr></table></figure>
<p>少写多少代码：）</p>
<h2 id="Arrow_Function">Arrow Function</h2><p>在前面的例子中你应该已经见到过，箭头函数让书写匿名函数(lambda)变得异常方便(少打很多字)，除了不能用箭头函数写一个generator这个设定有些意外。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(v=&gt;v+<span class="number">1</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>另外，箭头函数的this是提前绑定到所在词法作用域内的(和调用者无关、apply等指定的<code>this</code>都无关)，有兴趣的同学大概可以去看看v8和SpiderMonkey怎么实现的。</p>
<h2 id="Proxy">Proxy</h2><p>差点忘了这个，因为，目前，截至到本文发稿，v8并不支持标准中的新特性(<code>--harmony_proxies</code>开启的是已废弃的Proxy API)，所以node也不支持。firefox倒是支持非常好哈哈。</p>
<p>在python中，标准库中有个较<code>defaultdict</code>的东西。有什么作用看看下面的例子就知道了。事实上，nltk wordnet corpus reader生成映射的时候很依赖这个功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [3]: from collections import defaultdict</span><br><span class="line"></span><br><span class="line">In [4]: expanded_dict = defaultdict(dict)</span><br><span class="line"></span><br><span class="line">In [5]: expanded_dict['a']['b'] = 1</span><br><span class="line"></span><br><span class="line">In [6]: expanded_dict</span><br><span class="line">Out[6]: defaultdict(&lt;type 'dict'&gt;, &#123;'a': &#123;'b': 1&#125;&#125;)</span><br><span class="line"></span><br><span class="line">In [7]: dict['a']['b']</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-7-07dd2e624242&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 dict['a']['b']</span><br><span class="line"></span><br><span class="line">TypeError: 'type' object has no attribute '__getitem__'</span><br></pre></td></tr></table></figure>
<p>显然我们不想让不存在的东西报错，我们也不想每次都写个if语句判断是吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dct[<span class="string">'a'</span>]:</span><br><span class="line">    dct[<span class="string">'a'</span>] = &#123;&#125;</span><br><span class="line">dct[<span class="string">'a'</span>][<span class="string">'b'</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果你知道<code>dct</code>中有哪些键当然也能全首先赋成字典，但是，很多情况下你并不知道有哪些键，还得依靠if来判断。<code>defaultdict</code>优雅的解决了这个问题。</p>
<p>遗憾的是，javascript中没有这种东西。忽然想到了<a href="https://hacks.mozilla.org/2015/07/es6-in-depth-proxies-and-reflect/" target="_blank" rel="external">ES6 in Depth: Proxies</a>中的例子，想到可以依靠这个特性自己实现一个<code>defaultdict</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Defaultdict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  handler = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, prop, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(prop <span class="keyword">in</span> target)) &#123;</span><br><span class="line">        target[prop] = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, handler);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> expandedDct = <span class="keyword">new</span> Defaultdict();</span><br><span class="line">expandedDct.a.b = <span class="number">1</span>;</span><br><span class="line">expandedDct.c.d = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(expandedDct.a.b)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(expandedDct));</span><br></pre></td></tr></table></figure>
<p>目前只有firefox支持标准的Proxy API。当然V8/node中可以polyfill出来，请自行github。</p>
<p>用<code>Proxy</code>可以结合<code>Map</code>来实现<code>Map</code>版本的DefaultMap哈哈。</p>
<p></p><p style="color:red">PS: 浏览器调试工具会调用一些方法。比如，你新建一个<code>expandedDct</code>之后，如果在firebug中想用<code>.</code>来查看变量，会对其调用很多方法。。。结果就是<code>expandedDct</code>多了很多firebug探查对象属性用到的函数名。。。我在这个问题上纠结了几乎两个小时没明白为啥多了这些奇怪的键而且一会儿有一会儿没。切切注意！！</p><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62; Object.keys(expandedDct)&#10;[&#34;a&#34;, &#34;c&#34;, &#34;length&#34;, &#34;fullPath&#34;, &#34;fileSize&#34;, &#34;header&#34;, &#34;body&#34;, &#34;getSourceLink&#34;]</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>以上，就是最近感觉比较有意思的一些ES6特性，就这样吧。</p>
<p>Have fun！</p>

    
  </div>
</article>



<section class="disqus-comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>




</div>

  
<script>
  var disqus_shortname = 'reverlandblog';
  
  var disqus_url = 'http://reverland.org/javascript/2015/11/21/the-es6-features-i-use-these-days/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"undefined"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0]
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->

</body>
</html>
